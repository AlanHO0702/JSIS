@page
@model PcbErpApi.Pages.CUR.FlowDesignerModel
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery
@{
    ViewData["Title"] = "é›»å­ç°½æ ¸æµç¨‹è¨­è¨ˆ";
    var currentPrcId = Model.CurrentFlow?.PRCID ?? "";
    var isEnabled = Model.CurrentFlow?.Finished == 1;
    var isReadOnly = isEnabled ? "true" : "false";
    var antiForgeryToken = Antiforgery.GetAndStoreTokens(HttpContext).RequestToken;
}

<style>
    .flow-designer-container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 100px);
        padding: 10px;
    }

    .toolbar {
        display: flex;
        gap: 5px;
        padding: 10px;
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }

    .toolbar button {
        padding: 8px 16px;
        border: 1px solid #007bff;
        background-color: #007bff;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .toolbar button:hover {
        background-color: #0056b3;
    }

    .toolbar button:disabled {
        background-color: #ccc;
        border-color: #ccc;
        cursor: not-allowed;
    }

    .toolbar button.secondary {
        background-color: #6c757d;
        border-color: #6c757d;
    }

    .toolbar button.success {
        background-color: #28a745;
        border-color: #28a745;
    }

    .toolbar button.danger {
        background-color: #dc3545;
        border-color: #dc3545;
    }

    .toolbar button.warning {
        background-color: #ffc107;
        border-color: #ffc107;
        color: #000;
    }

    .flow-info-panel {
        display: flex;
        gap: 10px;
        padding: 10px;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 10px;
        align-items: center;
    }

    .flow-info-panel label {
        font-weight: bold;
        margin-right: 5px;
    }

    .flow-info-panel input,
    .flow-info-panel select {
        padding: 5px 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    }

    .status-badge {
        padding: 5px 15px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
    }

    .status-badge.enabled {
        background-color: #d4edda;
        color: #155724;
    }

    .status-badge.disabled {
        background-color: #f8d7da;
        color: #721c24;
    }

    .main-container {
        display: flex;
        flex: 1;
        gap: 10px;
        overflow: hidden;
    }

    .sidebar {
        width: 150px;
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        overflow-y: auto;
    }

    .sidebar h3 {
        font-size: 16px;
        margin-bottom: 10px;
        color: #333;
    }

    .node-item {
        padding: 10px;
        margin-bottom: 8px;
        background-color: #007bff;
        color: white;
        border-radius: 4px;
        cursor: move;
        text-align: center;
        font-size: 14px;
        transition: background-color 0.2s;
    }

    .node-item:hover {
        background-color: #0056b3;
    }

    .node-item.notify {
        background-color: #6c757d;
    }

    .node-item.proc {
        background-color: #28a745;
    }

    .drawflow-container {
        flex: 1;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        position: relative;
        overflow: hidden;
    }

    #drawflow {
        width: 100%;
        height: 100%;
        position: relative;
        background-image: linear-gradient(90deg, #f0f0f0 1px, transparent 0),
                          linear-gradient(180deg, #f0f0f0 1px, transparent 0);
        background-size: 20px 20px;
    }

    .drawflow .drawflow-node {
        background-color: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        padding: 15px;
        min-width: 150px;
    }

    .drawflow .drawflow-node .title {
        font-weight: bold;
        margin-bottom: 5px;
        color: #333;
        text-align: center;
    }

    .drawflow .drawflow-node .content {
        font-size: 12px;
        color: #666;
    }

    .drawflow .connection {
        stroke: #4ea9ff;
        stroke-width: 0.8px;
        fill: none;
    }

    .drawflow .drawflow-node.selected {
        border-color: #ff6600;
        box-shadow: 0 0 12px rgba(255, 102, 0, 0.5);
    }

    /* icon é¢¨æ ¼ç¯€é»åœ¨ selected æ™‚æ”¹ç”¨å…§å®¹å®¹å™¨é«˜äº®ï¼Œé¿å…é€æ˜ç¯€é»çœ‹ä¸å‡ºé¸å– */
    .drawflow .drawflow-node.node-flowstart.selected .flag-node,
    .drawflow .drawflow-node.node-flowend.selected .flag-node,
    .drawflow .drawflow-node.node-manager.selected .icon-node,
    .drawflow .drawflow-node.node-notify.selected .icon-node {
        background: rgba(255, 166, 0, 0.14);
        border: 1px solid #ff8c00;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(255, 140, 0, 0.35);
    }

    .drawflow .drawflow-node.multi-selected:not(.selected) {
        outline: 1px dashed #ff8c00;
        outline-offset: 2px;
        border-radius: 8px;
    }

    .drawflow .drawflow-node.node-flowstart.multi-selected .flag-node,
    .drawflow .drawflow-node.node-flowend.multi-selected .flag-node,
    .drawflow .drawflow-node.node-manager.multi-selected .icon-node,
    .drawflow .drawflow-node.node-notify.multi-selected .icon-node {
        background: rgba(255, 166, 0, 0.1);
        border: 1px solid rgba(255, 140, 0, 0.7);
        border-radius: 8px;
    }

    .drawflow .drawflow-node.flowstart,
    .drawflow .drawflow-node.flowend,
    .drawflow .drawflow-node.node-flowstart,
    .drawflow .drawflow-node.node-flowend {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        min-width: 0 !important;
        width: auto !important;
        max-width: none !important;
        padding: 0 !important;
        border-radius: 0 !important;
    }

    .drawflow .drawflow-node.flowstart .flag-node,
    .drawflow .drawflow-node.flowend .flag-node,
    .drawflow .drawflow-node.node-flowstart .flag-node,
    .drawflow .drawflow-node.node-flowend .flag-node {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        padding: 14px 16px;
        margin: 0;
        user-select: none;
    }

    .drawflow .drawflow-node.flowstart .flag-node .flag-icon,
    .drawflow .drawflow-node.flowend .flag-node .flag-icon,
    .drawflow .drawflow-node.node-flowstart .flag-node .flag-icon,
    .drawflow .drawflow-node.node-flowend .flag-node .flag-icon {
        font-size: 34px;
        line-height: 1;
    }

    .drawflow .drawflow-node.flowstart .flag-node .flag-label,
    .drawflow .drawflow-node.flowend .flag-node .flag-label,
    .drawflow .drawflow-node.node-flowstart .flag-node .flag-label,
    .drawflow .drawflow-node.node-flowend .flag-node .flag-label {
        font-size: 10px;
        font-weight: bold;
        line-height: 1.1;
    }

    .drawflow .drawflow-node.flowstart .flag-node .flag-icon,
    .drawflow .drawflow-node.flowstart .flag-node .flag-label,
    .drawflow .drawflow-node.node-flowstart .flag-node .flag-icon,
    .drawflow .drawflow-node.node-flowstart .flag-node .flag-label {
        color: #1e8e3e;
    }

    .drawflow .drawflow-node.flowend .flag-node .flag-icon,
    .drawflow .drawflow-node.flowend .flag-node .flag-label,
    .drawflow .drawflow-node.node-flowend .flag-node .flag-icon,
    .drawflow .drawflow-node.node-flowend .flag-node .flag-label {
        color: #dc3545;
    }

    .drawflow .drawflow-node.node-notify,
    .drawflow .drawflow-node.node-manager {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        min-width: 0 !important;
        width: auto !important;
        max-width: none !important;
        padding: 0 !important;
        border-radius: 0 !important;
    }

    .drawflow .drawflow-node.node-notify .icon-node,
    .drawflow .drawflow-node.node-manager .icon-node {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        padding: 14px 16px;
        margin: 0;
        user-select: none;
    }

    .transition-label-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 6;
    }

    .transition-label {
        position: absolute;
        transform: translate(-50%, -50%);
        font-size: 12px;
        color: #1d1d1d;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 3px;
        padding: 1px 4px;
        white-space: nowrap;
        line-height: 1.2;
    }

    .drawflow .drawflow-node.node-notify .icon-node .icon,
    .drawflow .drawflow-node.node-manager .icon-node .icon {
        font-size: 30px;
        line-height: 1;
    }

    .drawflow .drawflow-node.node-notify .icon-node .label,
    .drawflow .drawflow-node.node-manager .icon-node .label {
        display: block;
        font-size: 10px;
        font-weight: bold;
        line-height: 1.1;
        text-align: center;
        margin-top: 2px;
        white-space: nowrap;
    }

    .drawflow .drawflow-node.node-notify .icon-node .icon,
    .drawflow .drawflow-node.node-notify .icon-node .label {
        color: #3d6cb9;
    }

    .drawflow .drawflow-node.node-manager .icon-node .icon,
    .drawflow .drawflow-node.node-manager .icon-node .label {
        color: #3a3a3a;
    }

    .alert {
        padding: 12px 20px;
        border-radius: 4px;
        margin-bottom: 10px;
    }

    .alert-success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }

    .alert-error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }

    #openFlowDialog .table-scroll {
        flex: 1;
        overflow-x: auto;
        overflow-y: auto;
        margin-bottom: 15px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }

    #flowListTable {
        width: max-content;
        min-width: 1400px;
        border-collapse: collapse;
        font-size: 13px;
    }

    #flowListTable th,
    #flowListTable td {
        white-space: nowrap;
    }
</style>

<div class="flow-designer-container">
    <!-- æç¤ºè¨Šæ¯ -->
    @if (TempData["Success"] != null)
    {
        <div class="alert alert-success">@TempData["Success"]</div>
    }
    @if (TempData["Error"] != null)
    {
        <div class="alert alert-error">@TempData["Error"]</div>
    }

    <!-- å·¥å…·åˆ— -->
    <div class="toolbar">
        <button type="button" onclick="showNewFlowDialog()">
            <span>ğŸ“„</span> æ–°å¢
        </button>
        <button type="button" onclick="showOpenFlowDialog()">
            <span>ğŸ“‚</span> é–‹å•Ÿæª”æ¡ˆ
        </button>
        <button type="button" onclick="saveFlow()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>ğŸ’¾</span> å­˜æª”
        </button>
        <button type="button" class="secondary" onclick="showFlowContentDialog()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>ğŸ”„</span> è®€å–æµç¨‹
        </button>
        <button type="button" class="danger" onclick="deleteFlow()" @(string.IsNullOrEmpty(currentPrcId) || isEnabled ? "disabled" : "")>
            <span>ğŸ—‘ï¸</span> åˆªé™¤
        </button>
        <button type="button" class="secondary" onclick="autoArrangeFlow()" @(string.IsNullOrEmpty(currentPrcId) || isEnabled ? "disabled" : "")>
            <span>ğŸ”€</span> æµç¨‹æ–¹å‘
        </button>
        <button type="button" class="secondary" onclick="showActivityProperties()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>â„¹ï¸</span> æ´»å‹•å…§å®¹
        </button>
        <button type="button" class="secondary" onclick="showCopyFlowDialog()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>ğŸ“‹</span> è¤‡è£½æµç¨‹
        </button>
        <button type="button" class="warning" onclick="toggleFlowStatus()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>âš¡</span> @(isEnabled ? "åœç”¨" : "å•Ÿç”¨")
        </button>
    </div>

    <!-- æµç¨‹è³‡è¨Šé¡¯ç¤ºå€ -->
    @if (Model.CurrentFlow != null)
    {
        <div class="flow-info-panel">
            <div>
                <label>æµç¨‹ä»£ç¢¼:</label>
                <input type="text" value="@Model.CurrentFlow.PRCID" readonly style="width: 150px;" />
            </div>
            <div>
                <label>æµç¨‹åç¨±:</label>
                <input type="text" value="@Model.CurrentFlow.PRCNAME" readonly style="width: 250px;" />
            </div>
            <div>
                <label>ç‹€æ…‹:</label>
                <span class="status-badge @(isEnabled ? "enabled" : "disabled")">
                    @(isEnabled ? "å•Ÿç”¨" : "åœç”¨")
                </span>
            </div>
            <div>
                <label>å»ºç«‹è€…:</label>
                <span>@Model.CurrentFlow.CREATOR</span>
            </div>
            <div>
                <label>å»ºç«‹æ—¥æœŸ:</label>
                <span>@Model.CurrentFlow.CDATE?.ToString("yyyy-MM-dd HH:mm")</span>
            </div>
        </div>
    }

    <!-- ä¸»è¦å€åŸŸ -->
    <div class="main-container">
        <!-- å·¦å´å·¥å…·æ¬„ -->
        <div class="sidebar">
            <h3>æ‹–æ”¾å…ƒä»¶</h3>
            <div class="node-item" draggable="true" ondragstart="dragNode(event, 'activity')" data-node="activity">
                ä¸€èˆ¬æ´»å‹•
            </div>
            <div class="node-item notify" draggable="true" ondragstart="dragNode(event, 'notify')" data-node="notify">
                é€šçŸ¥æ´»å‹•
            </div>
            <div class="node-item proc" draggable="true" ondragstart="dragNode(event, 'proc')" data-node="proc">
                ç¨‹åºæ´»å‹•
            </div>
        </div>

        <!-- ç¹ªåœ–å€åŸŸ -->
        <div class="drawflow-container">
            <div id="drawflow" ondrop="dropNode(event)" ondragover="allowDrop(event)"></div>
            <div id="transitionLabelLayer" class="transition-label-layer"></div>
        </div>
    </div>
</div>

<!-- æ–°å¢æµç¨‹å°è©±æ¡† -->
<div id="newFlowDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:30px; border:2px solid #ddd; border-radius:8px; z-index:1000; box-shadow: 0 4px 16px rgba(0,0,0,0.2);">
    <h3 style="margin-top:0;">æ–°å¢æµç¨‹</h3>
    <form method="post" asp-page-handler="Create">
        <div style="margin-bottom:15px;">
            <label style="display:block; font-weight:bold; margin-bottom:5px;">æµç¨‹ä»£ç¢¼:</label>
            <input type="text" name="prcId" required style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" />
        </div>
        <div style="margin-bottom:15px;">
            <label style="display:block; font-weight:bold; margin-bottom:5px;">æµç¨‹åç¨±:</label>
            <input type="text" name="prcName" required style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" />
        </div>
        <div style="margin-bottom:20px;">
            <label style="display:block; font-weight:bold; margin-bottom:5px;">æµç¨‹èªªæ˜:</label>
            <textarea name="descrip" rows="3" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;"></textarea>
        </div>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
            <button type="submit" style="padding:8px 20px; background-color:#007bff; color:white; border:none; border-radius:4px; cursor:pointer;">å»ºç«‹</button>
            <button type="button" onclick="closeNewFlowDialog()" style="padding:8px 20px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;">å–æ¶ˆ</button>
        </div>
    </form>
</div>

<!-- é–‹å•Ÿæµç¨‹å°è©±æ¡† -->
<div id="openFlowDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border:2px solid #ddd; border-radius:8px; z-index:1000; box-shadow: 0 4px 16px rgba(0,0,0,0.2); width:900px; max-width:90vw; max-height:80vh; flex-direction:column;">
    <h3 style="margin-top:0; margin-bottom:15px;">é–‹å•Ÿæµç¨‹</h3>

    <!-- æµç¨‹åˆ—è¡¨è¡¨æ ¼ -->
    <div class="table-scroll">
        <table id="flowListTable">
            <thead style="position:sticky; top:0; background-color:#f5f5f5; z-index:1;">
                <tr style="border-bottom:2px solid #ddd;">
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:60px;">å•Ÿç”¨</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:120px;">æµç¨‹ä»£ç¢¼</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:200px;">æµç¨‹åç¨±</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:100px;">å»ºç«‹è€…</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:100px;">ä¿®æ”¹è€…</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:150px;">å»ºç«‹æ—¥æœŸ</th>
                    <th style="padding:10px; text-align:left;">èªªæ˜</th>
                </tr>
            </thead>
            <tbody id="flowListBody">
                <!-- æµç¨‹åˆ—è¡¨å°‡é€šé JavaScript å‹•æ…‹è¼‰å…¥ -->
            </tbody>
        </table>
    </div>

    <div style="display:flex; gap:10px; justify-content:flex-end;">
        <button type="button" onclick="openSelectedFlowFromTable()" style="padding:8px 20px; background-color:#007bff; color:white; border:none; border-radius:4px; cursor:pointer;">é–‹å•Ÿ</button>
        <button type="button" onclick="closeOpenFlowDialog()" style="padding:8px 20px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;">å–æ¶ˆ</button>
    </div>
</div>

<!-- æµç¨‹å…§å®¹å°è©±æ¡† -->
<div id="flowContentDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border:2px solid #ddd; border-radius:8px; z-index:1000; box-shadow: 0 4px 16px rgba(0,0,0,0.2); width:860px; max-width:92vw; max-height:86vh; overflow:auto;">
    <h3 style="margin-top:0; margin-bottom:15px;">æµç¨‹å…§å®¹</h3>

    <div style="display:grid; grid-template-columns: 110px 1fr 110px 1fr; gap:10px; align-items:center; margin-bottom:15px;">
        <label style="font-weight:bold;">æµç¨‹ä»£ç¢¼:</label>
        <input id="flowContentPrcId" type="text" readonly style="padding:6px; border:1px solid #ddd; border-radius:4px;" />
        <label style="font-weight:bold;">æµç¨‹åç¨±:</label>
        <input id="flowContentPrcName" type="text" style="padding:6px; border:1px solid #ddd; border-radius:4px;" />
        <label style="font-weight:bold;">æµç¨‹æè¿°:</label>
        <input id="flowContentDescrip" type="text" style="grid-column: span 3; padding:6px; border:1px solid #ddd; border-radius:4px;" />
    </div>

    <div style="display:flex; gap:12px; height:360px;">
        <div style="width:220px; display:flex; flex-direction:column; gap:8px;">
            <label style="font-weight:bold;">æµç¨‹äº‹ä»¶:</label>
            <select id="flowContentEvtList" size="14" style="flex:1; border:1px solid #ddd; border-radius:4px; padding:6px;" onchange="onFlowContentEventChanged()"></select>
        </div>
        <div style="flex:1; display:flex; flex-direction:column; gap:8px;">
            <label style="font-weight:bold;">ONEXEC:</label>
            <textarea id="flowContentOnExec" style="flex:1; border:1px solid #ddd; border-radius:4px; padding:8px; font-family:Consolas, monospace;"></textarea>
        </div>
    </div>

    <div style="display:flex; justify-content:space-between; margin-top:14px;">
        <div style="display:flex; gap:8px;">
            <button id="flowContentBtnInsertVar" type="button" style="padding:8px 14px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;">æ’å…¥åƒæ•¸</button>
            <button id="flowContentBtnInsertFunc" type="button" style="padding:8px 14px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;">æ’å…¥å‡½å¼</button>
            <button id="flowContentBtnDelete" type="button" style="padding:8px 14px; background-color:#dc3545; color:white; border:none; border-radius:4px; cursor:pointer;">åˆªé™¤æµç¨‹</button>
        </div>
        <div style="display:flex; gap:8px;">
            <button id="flowContentBtnOk" type="button" style="padding:8px 20px; background-color:#007bff; color:white; border:none; border-radius:4px; cursor:pointer;" onclick="closeFlowContentDialog()">ç¢ºå®š</button>
            <button type="button" style="padding:8px 20px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;" onclick="closeFlowContentDialog()">å–æ¶ˆ</button>
        </div>
    </div>
</div>

<!-- é®ç½©å±¤ -->
<div id="dialogOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:999;" onclick="closeAllDialogs()"></div>

@section Scripts {
    <!-- Drawflow CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/drawflow@0.0.60/dist/drawflow.min.css">

    <!-- å››æ–¹å‘é€£æ¥é»å®šä½ (è¦†å¯« Drawflow é è¨­çš„å·¦å³é…ç½®) -->
    <style>
        /* è®“ inputs/outputs å®¹å™¨è¦†è“‹æ•´å€‹ç¯€é»ï¼Œä»¥ä¾¿å››æ–¹å‘å®šä½ */
        .drawflow .drawflow-node .inputs,
        .drawflow .drawflow-node .outputs {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            overflow: visible;
            pointer-events: none;
        }

        .drawflow .drawflow-node .input,
        .drawflow .drawflow-node .output {
            position: absolute;
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.2s;
            width: 10px;
            height: 10px;
        }

        /* æ»‘é¼ ç§»åˆ°ç¯€é»æ™‚æ‰é¡¯ç¤ºé€£æ¥é» */
        .drawflow .drawflow-node:hover .input,
        .drawflow .drawflow-node:hover .output {
            opacity: 1;
        }

        /* æœ‰é€£ç·šçš„é€£æ¥é»æ°¸é é¡¯ç¤º */
        .drawflow .drawflow-node .input.connected,
        .drawflow .drawflow-node .output.connected {
            opacity: 1;
        }

        /* input_1 = å·¦å´ä¸­å¤® */
        .drawflow .drawflow-node .inputs .input_1 {
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* input_2 = é ‚éƒ¨ä¸­å¤® */
        .drawflow .drawflow-node .inputs .input_2 {
            left: 50%;
            top: -5px;
            transform: translateX(-50%);
        }

        /* output_1 = å³å´ä¸­å¤® */
        .drawflow .drawflow-node .outputs .output_1 {
            right: -5px;
            left: auto;
            top: 50%;
            transform: translateY(-50%);
        }

        /* output_2 = åº•éƒ¨ä¸­å¤® */
        .drawflow .drawflow-node .outputs .output_2 {
            left: 50%;
            bottom: -5px;
            top: auto;
            right: auto;
            transform: translateX(-50%);
        }
    </style>

    <!-- Drawflow JS -->
    <script src="https://cdn.jsdelivr.net/npm/drawflow@0.0.60/dist/drawflow.min.js"></script>

    <script>
        let editor = null;
        let isLoadingFlow = false;
        let currentFlowDetail = null;
        let currentTransitions = [];
        let currentActIdToNodeIdMap = {};
        const multiSelectedNodeIds = new Set();
        let lastMovedNodePositions = {};
        let isSyncingGroupMove = false;
        const isReadOnly = @isReadOnly;
        const antiForgeryToken = '@antiForgeryToken';

        function appendAntiForgeryToken(form) {
            const tokenInput = document.createElement('input');
            tokenInput.type = 'hidden';
            tokenInput.name = '__RequestVerificationToken';
            tokenInput.value = antiForgeryToken;
            form.appendChild(tokenInput);
        }

        // ç›´æ¥å¾ URL æŸ¥è©¢åƒæ•¸è®€å– prcIdï¼Œé¿å… Razor å‚³éæ™‚çš„ç·¨ç¢¼å•é¡Œ
        function getPrcIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('prcId') || '';
        }

        const currentPrcId = getPrcIdFromUrl();

        function getNodeIdFromElement(nodeEl) {
            if (!nodeEl || !nodeEl.id || !nodeEl.id.startsWith('node-')) return null;
            return nodeEl.id.substring(5);
        }

        function getNodePosition(nodeId) {
            const nodeData = editor?.getNodeFromId(Number(nodeId));
            if (!nodeData) return null;
            return {
                x: Number(nodeData.pos_x) || 0,
                y: Number(nodeData.pos_y) || 0
            };
        }

        function seedSelectedNodePositions() {
            lastMovedNodePositions = {};
            multiSelectedNodeIds.forEach(nodeId => {
                const pos = getNodePosition(nodeId);
                if (pos) lastMovedNodePositions[nodeId] = pos;
            });
        }

        function applyMultiSelectionClasses() {
            document.querySelectorAll('.drawflow-node.multi-selected')
                .forEach(el => el.classList.remove('multi-selected'));

            multiSelectedNodeIds.forEach(nodeId => {
                const nodeEl = document.getElementById('node-' + nodeId);
                if (nodeEl) nodeEl.classList.add('multi-selected');
            });
        }

        function setNodePosition(nodeId, x, y) {
            const moduleName = editor?.module || 'Home';
            const moduleData = editor?.drawflow?.drawflow?.[moduleName]?.data;
            const dataNode = moduleData?.[nodeId];
            if (!dataNode) return;

            dataNode.pos_x = x;
            dataNode.pos_y = y;

            const nodeEl = document.getElementById('node-' + nodeId);
            if (nodeEl) {
                if (nodeEl.style.transform && nodeEl.style.transform !== 'none') {
                    nodeEl.style.transform = `translate(${x}px, ${y}px)`;
                } else {
                    nodeEl.style.left = `${x}px`;
                    nodeEl.style.top = `${y}px`;
                }
            }

            if (typeof editor.updateConnectionNodes === 'function') {
                editor.updateConnectionNodes('node-' + nodeId);
            }
        }

        function moveSelectedNodesByDelta(leaderNodeId, dx, dy) {
            if (multiSelectedNodeIds.size < 2) return;
            if (!multiSelectedNodeIds.has(String(leaderNodeId))) return;
            if (!dx && !dy) return;

            isSyncingGroupMove = true;
            try {
                multiSelectedNodeIds.forEach(nodeId => {
                    if (nodeId === String(leaderNodeId)) return;
                    const pos = getNodePosition(nodeId);
                    if (!pos) return;
                    setNodePosition(nodeId, pos.x + dx, pos.y + dy);
                });
            } finally {
                isSyncingGroupMove = false;
            }
        }

        function handleShiftMultiSelect(event) {
            const nodeEl = event.target.closest('.drawflow-node');

            if (!nodeEl) {
                if (!event.shiftKey && multiSelectedNodeIds.size > 0) {
                    multiSelectedNodeIds.clear();
                    applyMultiSelectionClasses();
                }
                return;
            }

            const nodeId = getNodeIdFromElement(nodeEl);
            if (!nodeId) return;

            if (event.shiftKey) {
                if (multiSelectedNodeIds.has(nodeId)) {
                    multiSelectedNodeIds.delete(nodeId);
                } else {
                    multiSelectedNodeIds.add(nodeId);
                }
                seedSelectedNodePositions();
                applyMultiSelectionClasses();
            } else if (multiSelectedNodeIds.has(nodeId)) {
                seedSelectedNodePositions();
            } else if (multiSelectedNodeIds.size > 0) {
                multiSelectedNodeIds.clear();
                applyMultiSelectionClasses();
            }
        }

        // åˆå§‹åŒ– Drawflow
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.getElementById('drawflow');
            editor = new Drawflow(container);

            editor.start();
            container.addEventListener('mousedown', handleShiftMultiSelect, true);

            // å¦‚æœæœ‰æµç¨‹è³‡æ–™ï¼Œè¼‰å…¥æµç¨‹åœ–
            if (currentPrcId) {
                loadFlowChart(currentPrcId);
            }

            // ä¿æŒ edit æ¨¡å¼è®“ä½¿ç”¨è€…èƒ½è‡ªç”±æª¢è¦–/æ‹–å‹•ç¯€é»
            // ä¸ä½¿ç”¨ Drawflow çš„ view æ¨¡å¼ï¼Œå› ç‚ºå®ƒæœƒå®Œå…¨é–å®šç¯€é»æ‹–å‹•
            // å•Ÿç”¨æµç¨‹æ™‚ï¼Œé€éäº‹ä»¶æ””æˆªé˜²æ­¢çµæ§‹ä¿®æ”¹ï¼ˆæ–°å¢é€£ç·šã€åˆªé™¤ç¯€é»ï¼‰
            if (isReadOnly) {
                editor.on('connectionCreated', function(info) {
                    if (!isLoadingFlow) {
                        editor.removeSingleConnection(info.output_id, info.input_id, info.output_class, info.input_class);
                    }
                });
                editor.on('nodeRemoved', function() {
                    if (!isLoadingFlow) {
                        alert('å·²å•Ÿç”¨çš„æµç¨‹ç„¡æ³•ä¿®æ”¹');
                    }
                });
            }

            editor.on('nodeMoved', function(nodeId) {
                const movedNodeId = String(nodeId);
                const currentPos = getNodePosition(movedNodeId);
                const prevPos = lastMovedNodePositions[movedNodeId];

                if (!isSyncingGroupMove && currentPos && prevPos) {
                    const dx = currentPos.x - prevPos.x;
                    const dy = currentPos.y - prevPos.y;
                    moveSelectedNodesByDelta(movedNodeId, dx, dy);
                }

                if (currentPos) {
                    lastMovedNodePositions[movedNodeId] = currentPos;
                }

                renderTransitionLabels();
            });
            editor.on('zoom', renderTransitionLabels);
            editor.on('translate', renderTransitionLabels);
            window.addEventListener('resize', renderTransitionLabels);
        });

        // æ ¹æ“šç¯€é»ç›¸å°ä½ç½®é¸æ“‡æœ€ä½³é€£æ¥åŸ 
        // output_1=å³, output_2=ä¸‹, input_1=å·¦, input_2=ä¸Š
        function getBestPorts(srcPos, dstPos) {
            if (!srcPos || !dstPos) {
                return { output: 'output_1', input: 'input_1' };
            }
            const dx = dstPos.x - srcPos.x;
            const dy = dstPos.y - srcPos.y;

            // ç›®æ¨™åœ¨ä¸‹æ–¹ä¸”å‚ç›´è·é›¢å¤§æ–¼æ°´å¹³è·é›¢ â†’ ä½¿ç”¨ ä¸‹â†’ä¸Š é€£æ¥
            if (dy > 0 && Math.abs(dy) > Math.abs(dx)) {
                return { output: 'output_2', input: 'input_2' }; // ä¸‹ â†’ ä¸Š
            }
            // å…¶é¤˜æƒ…æ³ä½¿ç”¨ å³â†’å·¦ æ°´å¹³é€£æ¥
            return { output: 'output_1', input: 'input_1' };
        }

        // æ¨™è¨˜æœ‰é€£ç·šçš„é€£æ¥é»ï¼Œè®“å®ƒå€‘æ°¸é é¡¯ç¤º
        function markConnectedPorts() {
            // å…ˆæ¸…é™¤æ‰€æœ‰ connected class
            document.querySelectorAll('.drawflow-node .connected').forEach(el => el.classList.remove('connected'));

            // å¾ Drawflow åŒ¯å‡ºè³‡æ–™å–å¾—é€£ç·šè³‡è¨Š
            const flowData = editor.export();
            const moduleData = flowData.drawflow?.Home?.data || {};

            for (const nodeId in moduleData) {
                const node = moduleData[nodeId];
                const nodeEl = document.getElementById('node-' + nodeId);
                if (!nodeEl) continue;

                // æ¨™è¨˜æœ‰é€£ç·šçš„ output ç«¯å£
                if (node.outputs) {
                    for (const outName in node.outputs) {
                        if (node.outputs[outName].connections && node.outputs[outName].connections.length > 0) {
                            const portEl = nodeEl.querySelector('.' + outName);
                            if (portEl) portEl.classList.add('connected');
                        }
                    }
                }
                // æ¨™è¨˜æœ‰é€£ç·šçš„ input ç«¯å£
                if (node.inputs) {
                    for (const inName in node.inputs) {
                        if (node.inputs[inName].connections && node.inputs[inName].connections.length > 0) {
                            const portEl = nodeEl.querySelector('.' + inName);
                            if (portEl) portEl.classList.add('connected');
                        }
                    }
                }
            }
        }

        function getNodeCenterByActId(actId) {
            const nodeId = currentActIdToNodeIdMap[actId];
            if (!nodeId) return null;

            const nodeData = editor.getNodeFromId(Number(nodeId));
            if (!nodeData) return null;

            const nodeEl = document.getElementById('node-' + nodeId);
            const width = nodeEl?.offsetWidth || 0;
            const height = nodeEl?.offsetHeight || 0;

            return {
                x: (nodeData.pos_x || 0) + (width / 2),
                y: (nodeData.pos_y || 0) + (height / 2)
            };
        }

        function renderTransitionLabels() {
            const layer = document.getElementById('transitionLabelLayer');
            if (!layer || !editor) return;

            layer.innerHTML = '';
            const zoom = editor.zoom || 1;
            const canvasX = editor.canvas_x || 0;
            const canvasY = editor.canvas_y || 0;

            currentTransitions.forEach(tra => {
                const caption = (tra.caption || tra.CAPTION || '').trim();
                if (!caption) return;

                const srcAct = tra.srcact || tra.SRCACT;
                const dstAct = tra.dstact || tra.DSTACT;
                const srcCenter = getNodeCenterByActId(srcAct);
                const dstCenter = getNodeCenterByActId(dstAct);
                if (!srcCenter || !dstCenter) return;

                const midX = (srcCenter.x + dstCenter.x) / 2;
                const midY = (srcCenter.y + dstCenter.y) / 2;

                const label = document.createElement('div');
                label.className = 'transition-label';
                label.textContent = caption;
                label.style.left = `${(midX * zoom) + canvasX}px`;
                label.style.top = `${(midY * zoom) + canvasY - 8}px`;
                layer.appendChild(label);
            });
        }

        function getNodeVisualConfig(actId, actName, actType) {
            const normalizedActId = (actId || '').toLowerCase();
            const normalizedName = (actName || '').toLowerCase();

            if (normalizedActId === 'flowstart') {
                return {
                    nodeClass: 'node-flowstart',
                    html: `
                        <div class="flag-node">
                            <div class="flag-icon">âš‘</div>
                            <div class="flag-label">æµç¨‹é–‹å§‹</div>
                        </div>
                    `
                };
            }

            if (normalizedActId === 'flowend') {
                return {
                    nodeClass: 'node-flowend',
                    html: `
                        <div class="flag-node">
                            <div class="flag-icon">âš</div>
                            <div class="flag-label">æµç¨‹çµæŸ</div>
                        </div>
                    `
                };
            }

            const isNotify = normalizedName.includes('å‰¯æœ¬é€šçŸ¥')
                || normalizedName.includes('å‰¯æœ¬')
                || normalizedActId.includes('notify');

            if (isNotify) {
                return {
                    nodeClass: 'node-notify',
                    html: `
                        <div class="icon-node">
                            <div class="icon" title="${actName || 'å‰¯æœ¬é€šçŸ¥'}">âœ‰</div>
                            <div class="label">${actName || 'å‰¯æœ¬é€šçŸ¥'}</div>
                        </div>
                    `
                };
            }

            return {
                nodeClass: 'node-manager',
                html: `
                    <div class="icon-node">
                        <div class="icon" title="${actName || 'ç°½æ ¸ä¸»ç®¡'}">ğŸ‘¨â€ğŸ’¼</div>
                        <div class="label">${actName || 'ç°½æ ¸ä¸»ç®¡'}</div>
                    </div>
                `
            };
        }

        // è¼‰å…¥æµç¨‹åœ–
        async function loadFlowChart(prcId) {
            isLoadingFlow = true;
            try {
                const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(prcId)}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || errorData.message || 'è¼‰å…¥æµç¨‹åœ–å¤±æ•—');
                }

                const data = await response.json();
                currentFlowDetail = data;
                console.log('è¼‰å…¥çš„æµç¨‹è³‡æ–™:', data);

                // æ¸…ç©ºç¾æœ‰çš„ç·¨è¼¯å™¨å…§å®¹
                editor.clear();
                multiSelectedNodeIds.clear();
                lastMovedNodePositions = {};
                applyMultiSelectionClasses();

                // å»ºç«‹ ACTID èˆ‡ Drawflow ç¯€é» ID çš„æ˜ å°„
                const actIdToNodeIdMap = {};
                currentActIdToNodeIdMap = {};
                currentTransitions = data.transitions || [];

                // è¼‰å…¥æ´»å‹•ç¯€é»
                if (data.activities && data.activities.length > 0) {
                    data.activities.forEach(act => {
                        // ä½¿ç”¨å¤§å¯«æ¬„ä½åç¨±ï¼ˆC# API å›å‚³çš„æ ¼å¼ï¼‰
                        const actId = act.actid || act.ACTID || '';
                        const actName = act.actname || act.ACTNAME || actId;
                        const actType = act.acttype || act.ACTTYPE || 0;
                        const x = act.x || act.X || 100;
                        const y = act.y || act.Y || 100;

                        const visual = getNodeVisualConfig(actId, actName, actType);

                        // æ–°å¢ç¯€é»åˆ°ç·¨è¼¯å™¨ (2 inputs: å·¦/ä¸Š, 2 outputs: å³/ä¸‹)
                        try {
                            const nodeId = editor.addNode(
                                actName,
                                2,  // è¼¸å…¥æ•¸é‡ (input_1=å·¦, input_2=ä¸Š)
                                2,  // è¼¸å‡ºæ•¸é‡ (output_1=å³, output_2=ä¸‹)
                                x,
                                y,
                                visual.nodeClass,
                                { actid: actId, acttype: actType },
                                visual.html
                            );
                            // å»ºç«‹æ˜ å°„ï¼šACTID -> Drawflow ç¯€é» ID
                            actIdToNodeIdMap[actId] = nodeId;
                            currentActIdToNodeIdMap[actId] = nodeId;
                            console.log('å·²æ–°å¢ç¯€é»:', actId, actName, '-> Drawflow ID:', nodeId);
                        } catch (e) {
                            console.error('æ–°å¢ç¯€é»å¤±æ•—:', e, act);
                        }
                    });
                }

                // å»ºç«‹æ´»å‹•ä½ç½®æŸ¥è©¢è¡¨ (ç”¨æ–¼æ™ºæ…§é€£æ¥åŸ é¸æ“‡)
                const actPositions = {};
                if (data.activities) {
                    data.activities.forEach(act => {
                        const id = act.actid || act.ACTID || '';
                        actPositions[id] = {
                            x: act.x || act.X || 100,
                            y: act.y || act.Y || 100
                        };
                    });
                }

                // ç­‰å¾…ç¯€é»æ¸²æŸ“å®Œæˆå¾Œå†å»ºç«‹é€£ç·š
                setTimeout(() => {
                    if (data.transitions && data.transitions.length > 0) {
                        data.transitions.forEach(tra => {
                            try {
                                const srcAct = tra.srcact || tra.SRCACT;
                                const dstAct = tra.dstact || tra.DSTACT;

                                if (srcAct && dstAct) {
                                    const srcNodeId = actIdToNodeIdMap[srcAct];
                                    const dstNodeId = actIdToNodeIdMap[dstAct];

                                    if (srcNodeId && dstNodeId) {
                                        // æ ¹æ“šç¯€é»ç›¸å°ä½ç½®é¸æ“‡æœ€ä½³é€£æ¥åŸ 
                                        const ports = getBestPorts(actPositions[srcAct], actPositions[dstAct]);
                                        editor.addConnection(
                                            srcNodeId,
                                            dstNodeId,
                                            ports.output,
                                            ports.input
                                        );
                                        console.log('å·²å»ºç«‹é€£ç·š:', srcAct, '->', dstAct, `(${ports.output} â†’ ${ports.input})`);
                                    } else {
                                        console.warn('æ‰¾ä¸åˆ°ç¯€é» ID:', { srcAct, srcNodeId, dstAct, dstNodeId });
                                    }
                                }
                            } catch (e) {
                                console.warn('ç„¡æ³•å»ºç«‹é€£ç·š:', e, tra);
                            }
                        });
                    }

                    console.log('æµç¨‹åœ–è¼‰å…¥å®Œæˆ');
                    markConnectedPorts();
                    renderTransitionLabels();
                    isLoadingFlow = false;
                }, 100);

            } catch (error) {
                isLoadingFlow = false;
                console.error('è¼‰å…¥æµç¨‹åœ–å¤±æ•—:', error);
                alert('è¼‰å…¥æµç¨‹åœ–å¤±æ•—: ' + error.message);
            }
        }

        async function showFlowContentDialog() {
            if (!currentPrcId) {
                alert('è«‹å…ˆé–‹å•ŸFLOWæµç¨‹æª”');
                return;
            }

            try {
                let detail = currentFlowDetail;
                if (!detail || !detail.flow) {
                    const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}`);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || errorData.message || 'è¼‰å…¥æµç¨‹å…§å®¹å¤±æ•—');
                    }
                    detail = await response.json();
                    currentFlowDetail = detail;
                }

                const flow = detail.flow || {};
                const events = detail.events || [];

                document.getElementById('flowContentPrcId').value = flow.prcid || flow.PRCID || currentPrcId;
                document.getElementById('flowContentPrcName').value = flow.prcname || flow.PRCNAME || '';
                document.getElementById('flowContentDescrip').value = flow.descrip || flow.DESCRIP || '';

                const evtList = document.getElementById('flowContentEvtList');
                evtList.innerHTML = '';
                events.forEach(evt => {
                    const evtName = evt.evtname || evt.EVTNAME || '';
                    const option = document.createElement('option');
                    option.value = evtName;
                    option.textContent = evtName;
                    option.dataset.onexec = evt.onexec || evt.ONEXEC || '';
                    evtList.appendChild(option);
                });

                if (evtList.options.length > 0) {
                    evtList.selectedIndex = 0;
                    onFlowContentEventChanged();
                } else {
                    document.getElementById('flowContentOnExec').value = '';
                }

                applyFlowContentReadOnlyState();

                document.getElementById('flowContentDialog').style.display = 'block';
                document.getElementById('dialogOverlay').style.display = 'block';
            } catch (error) {
                console.error('é–‹å•Ÿæµç¨‹å…§å®¹å¤±æ•—:', error);
                alert('é–‹å•Ÿæµç¨‹å…§å®¹å¤±æ•—: ' + error.message);
            }
        }

        function onFlowContentEventChanged() {
            const evtList = document.getElementById('flowContentEvtList');
            const selected = evtList.options[evtList.selectedIndex];
            document.getElementById('flowContentOnExec').value = selected ? (selected.dataset.onexec || '') : '';
        }

        function applyFlowContentReadOnlyState() {
            const flow = currentFlowDetail?.flow || {};
            const finished = (flow.finished ?? flow.Finished ?? 0) === 1;

            document.getElementById('flowContentPrcId').readOnly = true;
            document.getElementById('flowContentPrcName').readOnly = finished;
            document.getElementById('flowContentDescrip').readOnly = finished;
            document.getElementById('flowContentOnExec').readOnly = finished;

            document.getElementById('flowContentBtnDelete').disabled = finished;
            document.getElementById('flowContentBtnInsertVar').disabled = finished;
            document.getElementById('flowContentBtnInsertFunc').disabled = finished;
            document.getElementById('flowContentBtnOk').disabled = finished;
        }

        function closeFlowContentDialog() {
            document.getElementById('flowContentDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        // å¾ Drawflow åŒ¯å‡ºè³‡æ–™ä¸­æå–ç¯€é»ä½ç½®
        function extractNodePositions() {
            const flowData = editor.export();
            const positions = [];
            const moduleData = flowData.drawflow?.Home?.data || {};

            for (const nodeId in moduleData) {
                const node = moduleData[nodeId];
                const actId = node.data?.actid;
                if (actId) {
                    positions.push({
                        actId: actId,
                        x: Math.round(node.pos_x),
                        y: Math.round(node.pos_y)
                    });
                }
            }
            return positions;
        }

        // å„²å­˜æµç¨‹
        async function saveFlow() {
            if (!currentPrcId) {
                alert('è«‹å…ˆé–‹å•Ÿæˆ–å»ºç«‹æµç¨‹');
                return;
            }

            try {
                // å„²å­˜ç¯€é»ä½ç½®åˆ° XFLdActï¼ˆå•Ÿç”¨çš„æµç¨‹ä¹Ÿå¯ä»¥å­˜ä½ç½®ï¼‰
                const positions = extractNodePositions();
                const posResponse = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}/positions`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(positions)
                });

                if (!posResponse.ok) {
                    const err = await posResponse.json();
                    throw new Error(err.error || 'å„²å­˜ä½ç½®å¤±æ•—');
                }

                if (isReadOnly) {
                    alert('ç¯€é»ä½ç½®å·²å„²å­˜');
                    return;
                }

                // éå”¯è®€æ™‚ï¼Œä¹Ÿå„²å­˜å®Œæ•´çš„æµç¨‹åœ–è³‡æ–™
                const flowData = editor.export();
                const flowChart = JSON.stringify(flowData);

                const form = document.createElement('form');
                form.method = 'post';
                form.action = '?handler=Save';

                const prcIdInput = document.createElement('input');
                prcIdInput.type = 'hidden';
                prcIdInput.name = 'prcId';
                prcIdInput.value = currentPrcId;
                form.appendChild(prcIdInput);

                const flowChartInput = document.createElement('input');
                flowChartInput.type = 'hidden';
                flowChartInput.name = 'flowChart';
                flowChartInput.value = flowChart;
                form.appendChild(flowChartInput);

                appendAntiForgeryToken(form);
                document.body.appendChild(form);
                form.submit();

            } catch (error) {
                console.error('å„²å­˜å¤±æ•—:', error);
                alert('å„²å­˜å¤±æ•—: ' + error.message);
            }
        }

        // åˆªé™¤æµç¨‹
        function deleteFlow() {
            if (!currentPrcId) return;
            if (!confirm('ç¢ºå®šè¦åˆªé™¤æ­¤æµç¨‹å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚')) return;

            const form = document.createElement('form');
            form.method = 'post';
            form.action = '?handler=Delete';

            const prcIdInput = document.createElement('input');
            prcIdInput.type = 'hidden';
            prcIdInput.name = 'prcId';
            prcIdInput.value = currentPrcId;
            form.appendChild(prcIdInput);

            appendAntiForgeryToken(form);
            document.body.appendChild(form);
            form.submit();
        }

        // åˆ‡æ›å•Ÿç”¨ç‹€æ…‹
        function toggleFlowStatus() {
            if (!currentPrcId) return;

            const form = document.createElement('form');
            form.method = 'post';
            form.action = '?handler=ToggleStatus';

            const prcIdInput = document.createElement('input');
            prcIdInput.type = 'hidden';
            prcIdInput.name = 'prcId';
            prcIdInput.value = currentPrcId;
            form.appendChild(prcIdInput);

            appendAntiForgeryToken(form);
            document.body.appendChild(form);
            form.submit();
        }

        // é¡¯ç¤ºæµç¨‹äº‹ä»¶
        function showFlowEvents() {
            alert('æµç¨‹äº‹ä»¶åŠŸèƒ½å¾…å¯¦ä½œ');
        }

        // é‡æ–°è¼‰å…¥æµç¨‹
        function reloadFlow() {
            if (!currentPrcId) return;

            if (confirm('ç¢ºå®šè¦é‡æ–°è¼‰å…¥æµç¨‹ï¼Ÿæœªå„²å­˜çš„è®Šæ›´å°‡æœƒéºå¤±ã€‚')) {
                window.location.reload();
            }
        }

        // è‡ªå‹•æ’åˆ—æµç¨‹ä½ˆå±€
        function autoArrangeFlow() {
            if (!currentPrcId || isReadOnly) return;

            alert('è‡ªå‹•æ’åˆ—ä½ˆå±€åŠŸèƒ½é–‹ç™¼ä¸­...\n\næ­¤åŠŸèƒ½å°‡è‡ªå‹•èª¿æ•´ç¯€é»ä½ç½®ï¼Œè®“æµç¨‹åœ–æ›´æ•´é½Šç¾è§€ã€‚');

            // TODO: å¯¦ä½œè‡ªå‹•æ’åˆ—æ¼”ç®—æ³•
            // å¯ä»¥ä½¿ç”¨åˆ†å±¤ä½ˆå±€æˆ–åŠ›å°å‘ä½ˆå±€
        }

        // é¡¯ç¤ºæ´»å‹•å±¬æ€§ç·¨è¼¯å°è©±æ¡†
        function showActivityProperties() {
            if (!currentPrcId) return;

            // å–å¾—ç›®å‰é¸ä¸­çš„ç¯€é»
            const selectedNodes = editor.getNodesFromName('selected');

            if (!selectedNodes || selectedNodes.length === 0) {
                alert('è«‹å…ˆé¸æ“‡ä¸€å€‹æ´»å‹•ç¯€é»');
                return;
            }

            alert('æ´»å‹•å…§å®¹ç·¨è¼¯åŠŸèƒ½é–‹ç™¼ä¸­...\n\næ­¤åŠŸèƒ½å°‡å…è¨±æ‚¨ç·¨è¼¯é¸ä¸­ç¯€é»çš„è©³ç´°å±¬æ€§ï¼š\n- æ´»å‹•åç¨±\n- æ´»å‹•é¡å‹\n- è™•ç†äººå“¡\n- ç›¸é—œåƒæ•¸');

            // TODO: å¯¦ä½œæ´»å‹•å±¬æ€§ç·¨è¼¯å°è©±æ¡†
        }

        // æ‹–æ”¾åŠŸèƒ½
        function dragNode(event, nodeType) {
            event.dataTransfer.setData('nodeType', nodeType);
        }

        function allowDrop(event) {
            event.preventDefault();
        }

        function dropNode(event) {
            event.preventDefault();
            if (isReadOnly) {
                alert('å·²å•Ÿç”¨çš„æµç¨‹ç„¡æ³•ä¿®æ”¹');
                return;
            }

            const nodeType = event.dataTransfer.getData('nodeType');
            const container = document.getElementById('drawflow');
            const rect = container.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            let nodeName = '';
            let actType = 0;
            switch (nodeType) {
                case 'activity':
                    nodeName = 'ç°½æ ¸ä¸»ç®¡';
                    actType = 0;
                    break;
                case 'notify':
                    nodeName = 'å‰¯æœ¬é€šçŸ¥';
                    actType = 2;
                    break;
                case 'proc':
                    nodeName = 'ç°½æ ¸ä¸»ç®¡';
                    actType = 1;
                    break;
            }

            const actId = 'node_' + Date.now();
            const visual = getNodeVisualConfig(actId, nodeName, actType);
            editor.addNode(
                nodeName,
                2,
                2,
                x,
                y,
                visual.nodeClass,
                { type: nodeType, actid: actId, acttype: actType },
                visual.html
            );
        }

        // å°è©±æ¡†æ§åˆ¶
        function showNewFlowDialog() {
            document.getElementById('newFlowDialog').style.display = 'block';
            document.getElementById('dialogOverlay').style.display = 'block';
        }

        function closeNewFlowDialog() {
            document.getElementById('newFlowDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        let selectedFlowRow = null;
        let selectedPrcId = null;

        async function showOpenFlowDialog() {
            document.getElementById('openFlowDialog').style.display = 'flex';
            document.getElementById('dialogOverlay').style.display = 'block';

            // è¼‰å…¥æµç¨‹åˆ—è¡¨
            await loadFlowList();
        }

        async function loadFlowList() {
            try {
                const response = await fetch('/api/FlowDesigner');
                if (!response.ok) throw new Error('è¼‰å…¥æµç¨‹åˆ—è¡¨å¤±æ•—');

                const flows = await response.json();
                const tbody = document.getElementById('flowListBody');
                tbody.innerHTML = '';

                flows.forEach(flow => {
                    const tr = document.createElement('tr');
                    tr.style.cursor = 'pointer';
                    tr.style.borderBottom = '1px solid #eee';

                    // ç¢ºä¿æ­£ç¢ºå–å¾—æµç¨‹ ID
                    const prcId = flow.PRCID || flow.prcid || '';
                    tr.dataset.prcid = prcId;

                    // é»æ“Šè¡Œé¸æ“‡æµç¨‹
                    tr.onclick = function() {
                        if (selectedFlowRow) {
                            selectedFlowRow.style.backgroundColor = '';
                        }
                        tr.style.backgroundColor = '#e7f1fd';
                        selectedFlowRow = tr;
                        selectedPrcId = prcId;  // ç›´æ¥ä½¿ç”¨è®Šæ•¸è€Œä¸æ˜¯ dataset
                    };

                    // é›™æ“Šç›´æ¥é–‹å•Ÿ
                    tr.ondblclick = function() {
                        window.location.href = `?prcId=${encodeURIComponent(prcId)}`;
                    };

                    // Hover æ•ˆæœ
                    tr.onmouseenter = function() {
                        if (tr !== selectedFlowRow) {
                            tr.style.backgroundColor = '#f8f9fa';
                        }
                    };
                    tr.onmouseleave = function() {
                        if (tr !== selectedFlowRow) {
                            tr.style.backgroundColor = '';
                        }
                    };

                    const finished = flow.Finished === 1 || flow.finished === 1;
                    const cdate = flow.CDATE || flow.cdate;
                    const formattedDate = cdate ? new Date(cdate).toLocaleString('zh-TW', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    }) : '';

                    // ä½¿ç”¨ textContent é¿å… HTML å¯¦é«”ç·¨ç¢¼å•é¡Œ
                    const td1 = document.createElement('td');
                    td1.style.cssText = 'padding:8px; border-right:1px solid #eee; text-align:center;';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = finished;
                    checkbox.disabled = true;
                    checkbox.style.pointerEvents = 'none';
                    td1.appendChild(checkbox);

                    const td2 = document.createElement('td');
                    td2.style.cssText = 'padding:8px; border-right:1px solid #eee; font-family:Consolas,monospace; font-weight:500;';
                    td2.textContent = prcId;

                    const td3 = document.createElement('td');
                    td3.style.cssText = 'padding:8px; border-right:1px solid #eee;';
                    td3.textContent = flow.PRCNAME || flow.prcname || '';

                    const td4 = document.createElement('td');
                    td4.style.cssText = 'padding:8px; border-right:1px solid #eee;';
                    td4.textContent = flow.CREATOR || flow.creator || '';

                    const td5 = document.createElement('td');
                    td5.style.cssText = 'padding:8px; border-right:1px solid #eee;';
                    td5.textContent = flow.MODIFICATOR || flow.modificator || '';

                    const td6 = document.createElement('td');
                    td6.style.cssText = 'padding:8px; border-right:1px solid #eee;';
                    td6.textContent = formattedDate;

                    const td7 = document.createElement('td');
                    td7.style.cssText = 'padding:8px;';
                    td7.textContent = flow.DESCRIP || flow.descrip || '';

                    tr.appendChild(td1);
                    tr.appendChild(td2);
                    tr.appendChild(td3);
                    tr.appendChild(td4);
                    tr.appendChild(td5);
                    tr.appendChild(td6);
                    tr.appendChild(td7);

                    tbody.appendChild(tr);
                });

            } catch (error) {
                console.error('è¼‰å…¥æµç¨‹åˆ—è¡¨å¤±æ•—:', error);
                alert('è¼‰å…¥æµç¨‹åˆ—è¡¨å¤±æ•—: ' + error.message);
            }
        }

        function closeOpenFlowDialog() {
            document.getElementById('openFlowDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
            selectedFlowRow = null;
            selectedPrcId = null;
        }

        function showCopyFlowDialog() {
            alert('è¤‡è£½æµç¨‹åŠŸèƒ½å¾…å¯¦ä½œ');
        }

        function openSelectedFlowFromTable() {
            if (!selectedPrcId) {
                alert('è«‹é¸æ“‡æµç¨‹');
                return;
            }
            window.location.href = `?prcId=${encodeURIComponent(selectedPrcId)}`;
        }

        function closeAllDialogs() {
            document.getElementById('newFlowDialog').style.display = 'none';
            document.getElementById('openFlowDialog').style.display = 'none';
            document.getElementById('flowContentDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }
    </script>
}
