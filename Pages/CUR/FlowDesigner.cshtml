@page
@model PcbErpApi.Pages.CUR.FlowDesignerModel
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery
@{
    ViewData["Title"] = "é›»å­ç°½æ ¸æµç¨‹è¨­è¨ˆ";
    var currentPrcId = Model.CurrentFlow?.PRCID ?? "";
    var isEnabled = Model.CurrentFlow?.Finished == 1;
    var isReadOnly = isEnabled ? "true" : "false";
    var antiForgeryToken = Antiforgery.GetAndStoreTokens(HttpContext).RequestToken;
}

<style>
    .flow-designer-container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 100px);
        padding: 10px;
    }

    .toolbar {
        display: flex;
        gap: 5px;
        padding: 10px;
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 10px;
        flex-wrap: wrap;
    }

    .toolbar button {
        padding: 8px 16px;
        border: 1px solid #007bff;
        background-color: #007bff;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .toolbar button:hover {
        background-color: #0056b3;
    }

    .toolbar button:disabled {
        background-color: #ccc;
        border-color: #ccc;
        cursor: not-allowed;
    }

    .toolbar button.secondary {
        background-color: #6c757d;
        border-color: #6c757d;
    }

    .toolbar button.success {
        background-color: #28a745;
        border-color: #28a745;
    }

    .toolbar button.danger {
        background-color: #dc3545;
        border-color: #dc3545;
    }

    .toolbar button.warning {
        background-color: #ffc107;
        border-color: #ffc107;
        color: #000;
    }

    .flow-info-panel {
        display: flex;
        gap: 10px;
        padding: 10px;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 10px;
        align-items: center;
    }

    .flow-info-panel label {
        font-weight: bold;
        margin-right: 5px;
    }

    .flow-info-panel input,
    .flow-info-panel select {
        padding: 5px 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    }

    .status-badge {
        padding: 5px 15px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
    }

    .status-badge.enabled {
        background-color: #d4edda;
        color: #155724;
    }

    .status-badge.disabled {
        background-color: #f8d7da;
        color: #721c24;
    }

    .main-container {
        display: flex;
        flex: 1;
        gap: 10px;
        overflow: hidden;
    }

    .sidebar {
        width: 150px;
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        overflow-y: auto;
    }

    .sidebar h3 {
        font-size: 16px;
        margin-bottom: 10px;
        color: #333;
    }

    .node-item {
        padding: 10px;
        margin-bottom: 8px;
        background-color: #007bff;
        color: white;
        border-radius: 4px;
        cursor: move;
        text-align: center;
        font-size: 14px;
        transition: background-color 0.2s;
    }

    .node-item:hover {
        background-color: #0056b3;
    }

    .node-item.notify {
        background-color: #6c757d;
    }

    .node-item.proc {
        background-color: #28a745;
    }

    .drawflow-container {
        flex: 1;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        position: relative;
        overflow: hidden;
    }

    #drawflow {
        width: 100%;
        height: 100%;
        position: relative;
        background-image: linear-gradient(90deg, #f0f0f0 1px, transparent 0),
                          linear-gradient(180deg, #f0f0f0 1px, transparent 0);
        background-size: 20px 20px;
    }

    .drawflow .drawflow-node {
        background-color: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        padding: 15px;
        min-width: 150px;
    }

    .drawflow .drawflow-node .title {
        font-weight: bold;
        margin-bottom: 5px;
        color: #333;
        text-align: center;
    }

    .drawflow .drawflow-node .content {
        font-size: 12px;
        color: #666;
    }

    .drawflow .connection {
        stroke: #4ea9ff;
        stroke-width: 1.1px;
        fill: none;
    }

    .drawflow .connection .main-path {
        cursor: pointer;
        stroke-width: 1.1px;
    }

    .drawflow .connection.selected .main-path {
        stroke: #ff8c00 !important;
        stroke-width: 2.2px !important;
    }

    .drawflow .drawflow-node.selected {
        border-color: #ff6600;
        box-shadow: 0 0 12px rgba(255, 102, 0, 0.5);
    }

    /* icon é¢¨æ ¼ç¯€é»åœ¨ selected æ™‚æ”¹ç”¨å…§å®¹å®¹å™¨é«˜äº®ï¼Œé¿å…é€æ˜ç¯€é»çœ‹ä¸å‡ºé¸å– */
    .drawflow .drawflow-node.node-flowstart.selected .flag-node,
    .drawflow .drawflow-node.node-flowend.selected .flag-node,
    .drawflow .drawflow-node.node-manager.selected .icon-node,
    .drawflow .drawflow-node.node-notify.selected .icon-node {
        background: rgba(255, 166, 0, 0.14);
        border: 1px solid #ff8c00;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(255, 140, 0, 0.35);
    }

    .drawflow .drawflow-node.multi-selected:not(.selected) {
        outline: 1px dashed #ff8c00;
        outline-offset: 2px;
        border-radius: 8px;
    }

    .drawflow .drawflow-node.node-flowstart.multi-selected .flag-node,
    .drawflow .drawflow-node.node-flowend.multi-selected .flag-node,
    .drawflow .drawflow-node.node-manager.multi-selected .icon-node,
    .drawflow .drawflow-node.node-notify.multi-selected .icon-node {
        background: rgba(255, 166, 0, 0.1);
        border: 1px solid rgba(255, 140, 0, 0.7);
        border-radius: 8px;
    }

    .drawflow .drawflow-node.flowstart,
    .drawflow .drawflow-node.flowend,
    .drawflow .drawflow-node.node-flowstart,
    .drawflow .drawflow-node.node-flowend {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        min-width: 0 !important;
        width: auto !important;
        max-width: none !important;
        padding: 0 !important;
        border-radius: 0 !important;
    }

    .drawflow .drawflow-node.flowstart .flag-node,
    .drawflow .drawflow-node.flowend .flag-node,
    .drawflow .drawflow-node.node-flowstart .flag-node,
    .drawflow .drawflow-node.node-flowend .flag-node {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        padding: 14px 16px;
        margin: 0;
        user-select: none;
    }

    .drawflow .drawflow-node.flowstart .flag-node .flag-icon,
    .drawflow .drawflow-node.flowend .flag-node .flag-icon,
    .drawflow .drawflow-node.node-flowstart .flag-node .flag-icon,
    .drawflow .drawflow-node.node-flowend .flag-node .flag-icon {
        font-size: 34px;
        line-height: 1;
    }

    .drawflow .drawflow-node.flowstart .flag-node .flag-label,
    .drawflow .drawflow-node.flowend .flag-node .flag-label,
    .drawflow .drawflow-node.node-flowstart .flag-node .flag-label,
    .drawflow .drawflow-node.node-flowend .flag-node .flag-label {
        font-size: 10px;
        font-weight: bold;
        line-height: 1.1;
    }

    .drawflow .drawflow-node.flowstart .flag-node .flag-icon,
    .drawflow .drawflow-node.flowstart .flag-node .flag-label,
    .drawflow .drawflow-node.node-flowstart .flag-node .flag-icon,
    .drawflow .drawflow-node.node-flowstart .flag-node .flag-label {
        color: #1e8e3e;
    }

    .drawflow .drawflow-node.flowend .flag-node .flag-icon,
    .drawflow .drawflow-node.flowend .flag-node .flag-label,
    .drawflow .drawflow-node.node-flowend .flag-node .flag-icon,
    .drawflow .drawflow-node.node-flowend .flag-node .flag-label {
        color: #dc3545;
    }

    .drawflow .drawflow-node.node-notify,
    .drawflow .drawflow-node.node-manager {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        min-width: 0 !important;
        width: auto !important;
        max-width: none !important;
        padding: 0 !important;
        border-radius: 0 !important;
    }

    .drawflow .drawflow-node.node-notify .icon-node,
    .drawflow .drawflow-node.node-manager .icon-node {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        padding: 14px 16px;
        margin: 0;
        user-select: none;
    }

    .transition-label-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 6;
    }

    .transition-label {
        position: absolute;
        transform: translate(-50%, -50%);
        font-size: 12px;
        color: #1d1d1d;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 3px;
        padding: 1px 4px;
        white-space: nowrap;
        line-height: 1.2;
    }

    .drawflow .drawflow-node.node-notify .icon-node .icon,
    .drawflow .drawflow-node.node-manager .icon-node .icon {
        font-size: 30px;
        line-height: 1;
    }

    .drawflow .drawflow-node.node-notify .icon-node .label,
    .drawflow .drawflow-node.node-manager .icon-node .label {
        display: block;
        font-size: 10px;
        font-weight: bold;
        line-height: 1.1;
        text-align: center;
        margin-top: 2px;
        white-space: nowrap;
    }

    .drawflow .drawflow-node.node-notify .icon-node .icon,
    .drawflow .drawflow-node.node-notify .icon-node .label {
        color: #3d6cb9;
    }

    .drawflow .drawflow-node.node-manager .icon-node .icon,
    .drawflow .drawflow-node.node-manager .icon-node .label {
        color: #3a3a3a;
    }

    .alert {
        padding: 12px 20px;
        border-radius: 4px;
        margin-bottom: 10px;
    }

    .alert-success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }

    .alert-error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }

    #openFlowDialog .table-scroll {
        flex: 1;
        overflow-x: auto;
        overflow-y: auto;
        margin-bottom: 15px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }

    #flowListTable {
        width: max-content;
        min-width: 1400px;
        border-collapse: collapse;
        font-size: 13px;
    }

    #flowListTable th,
    #flowListTable td {
        white-space: nowrap;
    }
</style>

<div class="flow-designer-container">
    <!-- æç¤ºè¨Šæ¯ -->
    @if (TempData["Success"] != null)
    {
        <div class="alert alert-success">@TempData["Success"]</div>
    }
    @if (TempData["Error"] != null)
    {
        <div class="alert alert-error">@TempData["Error"]</div>
    }

    <!-- å·¥å…·åˆ— -->
    <div class="toolbar">
        <button type="button" onclick="showNewFlowDialog()">
            <span>ğŸ“„</span> æ–°å¢
        </button>
        <button type="button" onclick="showOpenFlowDialog()">
            <span>ğŸ“‚</span> é–‹å•Ÿæª”æ¡ˆ
        </button>
        <button type="button" onclick="saveFlow()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>ğŸ’¾</span> å­˜æª”
        </button>
        <button type="button" onclick="showFlowContentDialog()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>ğŸ”„</span> è®€å–æµç¨‹
        </button>
        <button type="button" class="danger" onclick="handleDeleteSelectedNodes()" @(string.IsNullOrEmpty(currentPrcId) || isEnabled ? "disabled" : "")>
            <span>ğŸ—‘ï¸</span> åˆªé™¤
        </button>
        <button type="button" onclick="autoArrangeFlow()" @(string.IsNullOrEmpty(currentPrcId) || isEnabled ? "disabled" : "")>
            <span>ğŸ”€</span> æµç¨‹æ–¹å‘
        </button>
        <button type="button" onclick="showActivityProperties()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>â„¹ï¸</span> æ´»å‹•å…§å®¹
        </button>
        <button type="button" onclick="showCopyFlowDialog()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>ğŸ“‹</span> è¤‡è£½æµç¨‹
        </button>
        <button type="button" class="warning" onclick="toggleFlowStatus()" @(string.IsNullOrEmpty(currentPrcId) ? "disabled" : "")>
            <span>âš¡</span> @(isEnabled ? "åœç”¨" : "å•Ÿç”¨")
        </button>
    </div>

    <!-- æµç¨‹è³‡è¨Šé¡¯ç¤ºå€ -->
    @if (Model.CurrentFlow != null)
    {
        <div class="flow-info-panel">
            <div>
                <label>æµç¨‹ä»£ç¢¼:</label>
                <input type="text" value="@Model.CurrentFlow.PRCID" readonly style="width: 150px;" />
            </div>
            <div>
                <label>æµç¨‹åç¨±:</label>
                <input type="text" value="@Model.CurrentFlow.PRCNAME" readonly style="width: 250px;" />
            </div>
            <div>
                <label>ç‹€æ…‹:</label>
                <span class="status-badge @(isEnabled ? "enabled" : "disabled")">
                    @(isEnabled ? "å•Ÿç”¨" : "åœç”¨")
                </span>
            </div>
            <div>
                <label>å»ºç«‹è€…:</label>
                <span>@Model.CurrentFlow.CREATOR</span>
            </div>
            <div>
                <label>å»ºç«‹æ—¥æœŸ:</label>
                <span>@Model.CurrentFlow.CDATE?.ToString("yyyy-MM-dd HH:mm")</span>
            </div>
        </div>
    }

    <!-- ä¸»è¦å€åŸŸ -->
    <div class="main-container">
        <!-- å·¦å´å·¥å…·æ¬„ -->
        <div class="sidebar">
            <h3>æ‹–æ”¾å…ƒä»¶</h3>
            <div class="node-item" draggable="true" ondragstart="dragNode(event, 'activity')" data-node="activity">
                ä¸€èˆ¬æ´»å‹•
            </div>
            <div class="node-item notify" draggable="true" ondragstart="dragNode(event, 'notify')" data-node="notify">
                å‰¯æœ¬é€šçŸ¥
            </div>
            <div class="node-item proc" draggable="true" ondragstart="dragNode(event, 'proc')" data-node="proc">
                ç³»çµ±è™•ç†
            </div>
        </div>

        <!-- ç¹ªåœ–å€åŸŸ -->
        <div class="drawflow-container">
            <div id="drawflow" ondrop="dropNode(event)" ondragover="allowDrop(event)"></div>
            <div id="transitionLabelLayer" class="transition-label-layer"></div>
        </div>
    </div>
</div>

<!-- æ–°å¢æµç¨‹å°è©±æ¡† -->
<div id="newFlowDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:30px; border:2px solid #ddd; border-radius:8px; z-index:1000; box-shadow: 0 4px 16px rgba(0,0,0,0.2);">
    <h3 style="margin-top:0;">æ–°å¢æµç¨‹</h3>
    <form method="post" asp-page-handler="Create">
        <div style="margin-bottom:15px;">
            <label style="display:block; font-weight:bold; margin-bottom:5px;">æµç¨‹ä»£ç¢¼:</label>
            <input type="text" name="prcId" required style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" />
        </div>
        <div style="margin-bottom:15px;">
            <label style="display:block; font-weight:bold; margin-bottom:5px;">æµç¨‹åç¨±:</label>
            <input type="text" name="prcName" required style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;" />
        </div>
        <div style="margin-bottom:20px;">
            <label style="display:block; font-weight:bold; margin-bottom:5px;">æµç¨‹èªªæ˜:</label>
            <textarea name="descrip" rows="3" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:4px;"></textarea>
        </div>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
            <button type="submit" style="padding:8px 20px; background-color:#007bff; color:white; border:none; border-radius:4px; cursor:pointer;">å»ºç«‹</button>
            <button type="button" onclick="closeNewFlowDialog()" style="padding:8px 20px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;">å–æ¶ˆ</button>
        </div>
    </form>
</div>

<!-- é–‹å•Ÿæµç¨‹å°è©±æ¡† -->
<div id="openFlowDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border:2px solid #ddd; border-radius:8px; z-index:1000; box-shadow: 0 4px 16px rgba(0,0,0,0.2); width:900px; max-width:90vw; max-height:80vh; flex-direction:column;">
    <h3 style="margin-top:0; margin-bottom:15px;">é–‹å•Ÿæµç¨‹</h3>

    <!-- æµç¨‹åˆ—è¡¨è¡¨æ ¼ -->
    <div class="table-scroll">
        <table id="flowListTable">
            <thead style="position:sticky; top:0; background-color:#f5f5f5; z-index:1;">
                <tr style="border-bottom:2px solid #ddd;">
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:60px;">å•Ÿç”¨</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:120px;">æµç¨‹ä»£ç¢¼</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:200px;">æµç¨‹åç¨±</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:100px;">å»ºç«‹è€…</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:100px;">ä¿®æ”¹è€…</th>
                    <th style="padding:10px; text-align:left; border-right:1px solid #ddd; width:150px;">å»ºç«‹æ—¥æœŸ</th>
                    <th style="padding:10px; text-align:left;">èªªæ˜</th>
                </tr>
            </thead>
            <tbody id="flowListBody">
                <!-- æµç¨‹åˆ—è¡¨å°‡é€šé JavaScript å‹•æ…‹è¼‰å…¥ -->
            </tbody>
        </table>
    </div>

    <div style="display:flex; gap:10px; justify-content:flex-end;">
        <button type="button" onclick="openSelectedFlowFromTable()" style="padding:8px 20px; background-color:#007bff; color:white; border:none; border-radius:4px; cursor:pointer;">é–‹å•Ÿ</button>
        <button type="button" onclick="closeOpenFlowDialog()" style="padding:8px 20px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer;">å–æ¶ˆ</button>
    </div>
</div>

<!-- è¤‡è£½æµç¨‹å°è©±æ¡† -->
<div id="copyFlowDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:15px; border:1px solid #ddd; border-radius:4px; z-index:1000; box-shadow: 0 2px 8px rgba(0,0,0,0.15); width:380px; font-size:12px;">
    <h3 style="margin-top:0; margin-bottom:12px; font-size:14px; font-weight:bold;">è¤‡è£½æµç¨‹</h3>

    <div style="margin-bottom:10px;">
        <label style="display:block; font-weight:bold; margin-bottom:3px; font-size:12px;">ä¾†æºæµç¨‹ä»£ç¢¼:</label>
        <select id="copySourcePrcId" style="width:100%; padding:5px; border:1px solid #ddd; border-radius:3px; font-size:12px;">
            <option value="">-- è«‹é¸æ“‡ä¾†æºæµç¨‹ --</option>
        </select>
    </div>

    <div style="margin-bottom:10px;">
        <label style="display:block; font-weight:bold; margin-bottom:3px; font-size:12px;">ç›®çš„æµç¨‹ä»£ç¢¼:</label>
        <input id="copyTargetPrcId" type="text" required style="width:100%; padding:5px; border:1px solid #ddd; border-radius:3px; font-size:12px;" placeholder="è«‹è¼¸å…¥æ–°çš„æµç¨‹ä»£ç¢¼" />
    </div>

    <div style="margin-bottom:10px;">
        <label style="display:block; font-weight:bold; margin-bottom:3px; font-size:12px;">ç›®çš„æµç¨‹åç¨±:</label>
        <input id="copyTargetPrcName" type="text" required style="width:100%; padding:5px; border:1px solid #ddd; border-radius:3px; font-size:12px;" placeholder="è«‹è¼¸å…¥æµç¨‹åç¨±" />
    </div>

    <div style="margin-bottom:12px;">
        <label style="display:block; font-weight:bold; margin-bottom:3px; font-size:12px;">ç›®çš„æµç¨‹æè¿°:</label>
        <textarea id="copyTargetDescrip" rows="2" style="width:100%; padding:5px; border:1px solid #ddd; border-radius:3px; font-size:12px; resize:vertical;" placeholder="è«‹è¼¸å…¥æµç¨‹æè¿°"></textarea>
    </div>

    <div style="display:flex; gap:6px; justify-content:flex-end;">
        <button type="button" onclick="executeCopyFlow()" style="padding:5px 12px; background-color:#007bff; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">è¤‡è£½</button>
        <button type="button" onclick="closeCopyFlowDialog()" style="padding:5px 12px; background-color:#6c757d; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">å–æ¶ˆ</button>
    </div>
</div>

<!-- æµç¨‹å…§å®¹å°è©±æ¡† -->
<div id="flowContentDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border:2px solid #ddd; border-radius:8px; z-index:1000; box-shadow: 0 4px 16px rgba(0,0,0,0.2); width:620px;">
    <h3 style="margin-top:0; margin-bottom:12px;">æµç¨‹å…§å®¹</h3>

    <!-- æµç¨‹åŸºæœ¬è³‡è¨Š -->
    <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:12px;">
        <!-- ç¬¬ä¸€è¡Œï¼šæµç¨‹ä»£ç¢¼ + åˆªé™¤æµç¨‹æŒ‰éˆ•ï¼ˆé å³ï¼‰ -->
        <div style="display:flex; gap:8px; align-items:center;">
            <label style="font-weight:bold; width:80px;">æµç¨‹ä»£ç¢¼:</label>
            <input id="flowContentPrcId" type="text" readonly style="width:250px; padding:5px; border:1px solid #ddd; border-radius:4px; font-size:13px;" />
            <div style="flex:1;"></div>
            <button id="flowContentBtnDelete" type="button" onclick="deleteFlow()" style="padding:6px 12px; background-color:#dc3545; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">åˆªé™¤æµç¨‹</button>
        </div>

        <!-- ç¬¬äºŒè¡Œï¼šæµç¨‹åç¨± -->
        <div style="display:flex; gap:8px; align-items:center;">
            <label style="font-weight:bold; width:80px;">æµç¨‹åç¨±:</label>
            <input id="flowContentPrcName" type="text" style="width:250px; padding:5px; border:1px solid #ddd; border-radius:4px; font-size:13px;" />
        </div>

        <!-- ç¬¬ä¸‰è¡Œï¼šæµç¨‹æè¿° + æ’å…¥åƒæ•¸ + æ’å…¥å‡½å¼ï¼ˆé å³ï¼‰ -->
        <div style="display:flex; gap:8px; align-items:center;">
            <label style="font-weight:bold; width:80px;">æµç¨‹æè¿°:</label>
            <input id="flowContentDescrip" type="text" style="flex:1; padding:5px; border:1px solid #ddd; border-radius:4px; font-size:13px;" />
            <button id="flowContentBtnInsertVar" type="button" onclick="showInsertParamDialog()" style="padding:6px 12px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">æ’å…¥åƒæ•¸</button>
            <button id="flowContentBtnInsertFunc" type="button" onclick="showInsertFuncDialog()" style="padding:6px 12px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;">æ’å…¥å‡½å¼</button>
        </div>
    </div>

    <!-- ä¸­é–“å€åŸŸï¼šæµç¨‹äº‹ä»¶ + ONEXEC -->
    <div style="display:flex; gap:0;">
        <!-- å·¦å´ï¼šæµç¨‹äº‹ä»¶åˆ—è¡¨ -->
        <div style="width:160px;">
            <select id="flowContentEvtList" size="10" style="height:268px; border:1px solid #ddd; border-radius:4px 0 0 4px; border-right:none; padding:4px; font-size:13px;" onchange="onFlowContentEventChanged()"></select>
        </div>

        <!-- å³å´ï¼šONEXEC -->
        <div style="flex:1;">
            <textarea id="flowContentOnExec" style="width:100%; height:268px; border:1px solid #ddd; border-radius:0 4px 4px 0; padding:6px; font-family:Consolas, monospace; font-size:13px; resize:none; box-sizing:border-box;"></textarea>
        </div>
    </div>

    <!-- åº•éƒ¨ï¼šç¢ºå®šã€å–æ¶ˆæŒ‰éˆ• -->
    <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:12px;">
        <button id="flowContentBtnOk" type="button" style="padding:6px 16px; background-color:#007bff; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;" onclick="closeFlowContentDialog()">ç¢ºå®š</button>
        <button type="button" style="padding:6px 16px; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer; font-size:13px;" onclick="closeFlowContentDialog()">å–æ¶ˆ</button>
    </div>
</div>

<!-- æ´»å‹•å…§å®¹å°è©±æ¡†ï¼ˆå…ˆå®Œæˆé–‹å•Ÿèˆ‡é¡¯ç¤ºï¼ŒæŒ‰éˆ•åŠŸèƒ½å¾ŒçºŒå¯¦ä½œï¼‰ -->
<div id="activityContentDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:14px; border:2px solid #ddd; border-radius:8px; z-index:1000; box-shadow: 0 4px 16px rgba(0,0,0,0.2); width:640px; max-width:88vw; font-size:12px;">
    <h3 style="margin-top:0; margin-bottom:8px; font-size:22px; white-space:nowrap;">æ´»å‹•å…§å®¹</h3>

    <div style="display:flex; flex-direction:column; gap:6px; margin-bottom:10px;">
        <div style="display:flex; align-items:center; gap:6px;">
            <label style="font-weight:bold; width:56px; flex-shrink:0; white-space:nowrap;">æ´»å‹•ä»£ç¢¼:</label>
            <input id="activityContentActId" type="text" readonly style="width:136px; padding:3px 4px; border:1px solid #ddd; border-radius:0; font-size:12px;" />
        </div>
        <div style="display:flex; align-items:center; gap:6px;">
            <label style="font-weight:bold; width:56px; flex-shrink:0; white-space:nowrap;">æ´»å‹•åç¨±:</label>
            <input id="activityContentActName" type="text" readonly style="width:136px; padding:3px 4px; border:1px solid #ddd; border-radius:0; font-size:12px;" />
        </div>
        <div style="display:flex; align-items:center; gap:6px;">
            <label style="font-weight:bold; width:56px; flex-shrink:0; white-space:nowrap;">æ´»å‹•æè¿°:</label>
            <input id="activityContentDescrip" type="text" readonly style="width:210px; padding:3px 4px; border:1px solid #ddd; border-radius:0; font-size:12px;" />
        </div>
        <div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
            <label style="font-weight:bold; width:56px; flex-shrink:0; white-space:nowrap;">æ”¶ä»¶é¡å‹:</label>
            <select id="activityContentRecType" onchange="onActivityRecTypeChange()" style="width:118px; padding:3px 4px; border:1px solid #ddd; border-radius:0; font-size:12px;">
                <option value="">-- è«‹é¸æ“‡ --</option>
            </select>
            <label id="activityContentRecParamLabel" style="font-weight:bold; white-space:nowrap; display:none;">æ”¶ä»¶æŒ‡å®š:</label>
            <select id="activityContentRecParam" onchange="onActivityRecParamChange()" style="width:150px; padding:3px 4px; border:1px solid #ddd; border-radius:0; font-size:12px; display:none;">
                <option value="">-- è«‹é¸æ“‡ --</option>
            </select>
            <label style="display:flex; align-items:center; gap:4px; white-space:nowrap;"><input id="activityContentIsEmail" type="checkbox" disabled /> Emailé€šçŸ¥ä¸‹ä¸€é—œ</label>
        </div>
    </div>

    <div style="display:flex; gap:12px; align-items:center; margin-bottom:10px;">
        <label style="display:flex; align-items:center; gap:4px; white-space:nowrap;"><input id="activityContentAllowAdd" type="checkbox" disabled /> å¯åŠ ç°½</label>
        <label style="display:flex; align-items:center; gap:4px; white-space:nowrap;"><input id="activityContentAllowReject" type="checkbox" disabled /> å¯é€€å›</label>
        <label style="display:flex; align-items:center; gap:4px; font-weight:bold; white-space:nowrap;"><input id="activityContentIsMultiSign" type="checkbox" disabled /> æ˜¯æœƒç°½</label>
    </div>

    <div style="display:flex; gap:0; margin-bottom:10px;">
        <div style="flex:0 0 20%; min-width:0;">
            <select id="activityContentEvtList" size="11" style="width:100%; height:224px; border:1px solid #ddd; border-radius:4px 0 0 4px; border-right:none; padding:4px; font-size:12px;" onchange="onActivityContentEventChanged()"></select>
        </div>
        <div style="flex:1; min-width:0;">
            <textarea id="activityContentOnExec" readonly style="width:100%; height:224px; border:1px solid #ddd; border-radius:0 4px 4px 0; padding:5px; font-family:Consolas, monospace; font-size:12px; resize:none; box-sizing:border-box;"></textarea>
        </div>
    </div>

    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
        <div style="display:flex; gap:6px; flex-wrap:nowrap;">
            <button id="activityContentBtnMultiSign" type="button" disabled onclick="if (!this.disabled) openMultiSignDialog(document.getElementById('activityContentActId').value, false)" style="width:82px; padding:5px 0; background-color:#e9ecef; color:#333; border:1px solid #adb5bd; border-radius:4px; font-size:12px; cursor:not-allowed; white-space:nowrap;">è¨­å®šæœƒç°½</button>
            <button id="activityContentBtnMultiSignView" type="button" disabled onclick="if (!this.disabled) openMultiSignDialog(document.getElementById('activityContentActId').value, true)" style="width:82px; padding:5px 0; background-color:#e9ecef; color:#666; border:1px solid #adb5bd; border-radius:4px; font-size:12px; cursor:not-allowed; white-space:nowrap;">æª¢è¦–æœƒç°½</button>
            <button id="activityContentBtnMultiSignCancel" type="button" disabled onclick="if (!this.disabled) cancelMultiSign()" style="width:82px; padding:5px 0; background-color:#e9ecef; color:#333; border:1px solid #adb5bd; border-radius:4px; font-size:12px; cursor:not-allowed; white-space:nowrap;">å–æ¶ˆæœƒç°½</button>
            <button id="activityContentBtnInsertVar" type="button" disabled onclick="if (!this.disabled) showInsertParamDialogForActivity()" style="width:82px; padding:5px 0; background-color:#e9ecef; color:#333; border:1px solid #adb5bd; border-radius:4px; font-size:12px; cursor:not-allowed; white-space:nowrap;">æ’å…¥åƒæ•¸</button>
            <button id="activityContentBtnInsertFunc" type="button" disabled onclick="if (!this.disabled) showInsertFuncDialogForActivity()" style="width:82px; padding:5px 0; background-color:#e9ecef; color:#333; border:1px solid #adb5bd; border-radius:4px; font-size:12px; cursor:not-allowed; white-space:nowrap;">æ’å…¥å‡½å¼</button>
        </div>
        <div style="display:flex; gap:8px;">
            <button id="activityContentBtnSave" type="button" onclick="saveActivityContent()" style="width:68px; padding:5px 0; background-color:#28a745; color:white; border:none; border-radius:4px; cursor:pointer; font-size:12px; white-space:nowrap;">ç¢ºå®š</button>
            <button id="activityContentBtnCancel" type="button" onclick="closeActivityContentDialog()" style="width:68px; padding:5px 0; background-color:#6c757d; color:white; border:none; border-radius:4px; cursor:pointer; font-size:12px; white-space:nowrap;">å–æ¶ˆ</button>
        </div>
    </div>
</div>

<!-- æœƒç°½è¨­å®šå°è©±æ¡† -->
<div id="multiSignDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:12px; border:2px solid #ddd; border-radius:6px; z-index:1001; box-shadow: 0 4px 16px rgba(0,0,0,0.2); width:550px; max-width:90vw; max-height:80vh; flex-direction:column;">
    <h3 style="margin-top:0; margin-bottom:10px; font-size:16px;">æœƒç°½è¨­å®š</h3>

    <!-- æ ¸å‡†çš„åŒæ„äººæ•¸ -->
    <div style="margin-bottom:8px;">
        <label style="font-weight:bold; color:#dc3545; display:block; margin-bottom:3px; font-size:12px;">æ ¸å‡†çš„åŒæ„äººæ•¸</label>
        <input id="multiSignAllowCount" type="number" min="1" value="1" style="width:80px; padding:3px; border:1px solid #ddd; border-radius:3px; text-align:center; font-size:12px;" />
    </div>

    <!-- æœƒç°½äººå“¡é¸æ“‡ -->
    <div style="margin-bottom:8px;">
        <label style="font-weight:bold; display:block; margin-bottom:3px; font-size:12px;">æœƒç°½äººå“¡</label>
        <div style="display:flex; gap:6px; align-items:flex-start;">
            <select id="multiSignUserSelect" style="flex:1; padding:3px; border:1px solid #ddd; border-radius:3px; font-size:12px;">
                <option value="">-- è«‹é¸æ“‡å“¡å·¥ --</option>
            </select>
            <button id="multiSignBtnAdd" type="button" onclick="addMultiSignUser()" style="padding:3px 10px; background-color:#28a745; color:white; border:none; border-radius:3px; cursor:pointer; white-space:nowrap; font-size:12px;">åŠ å…¥</button>
            <button id="multiSignBtnDelete" type="button" onclick="deleteMultiSignUser()" style="padding:3px 10px; background-color:#dc3545; color:white; border:none; border-radius:3px; cursor:pointer; white-space:nowrap; font-size:12px;">åˆªé™¤</button>
        </div>
    </div>

    <!-- æœƒç°½äººå“¡åˆ—è¡¨ -->
    <div style="flex:1; overflow-y:auto; margin-bottom:10px; min-height:200px; border:1px solid #ddd; border-radius:3px;">
        <table id="multiSignUserTable" style="width:100%; border-collapse:collapse; font-size:12px;">
            <thead style="position:sticky; top:0; background-color:#f5f5f5; z-index:1;">
                <tr style="border-bottom:2px solid #ddd;">
                    <th style="padding:6px; text-align:left; width:35%;">æœƒç°½äººå“¡å·¥è™Ÿ</th>
                    <th style="padding:6px; text-align:left; width:65%;">æœƒç°½äººå“¡å§“å</th>
                </tr>
            </thead>
            <tbody id="multiSignUserTableBody">
                <!-- æœƒç°½äººå“¡åˆ—è¡¨å°‡é€šé JavaScript å‹•æ…‹è¼‰å…¥ -->
            </tbody>
        </table>
    </div>

    <!-- æŒ‰éˆ•çµ„ -->
    <div style="display:flex; gap:6px; justify-content:flex-end;">
        <button type="button" onclick="saveMultiSignSetting()" style="padding:5px 15px; background-color:#007bff; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">ç¢ºå®š</button>
        <button type="button" onclick="closeMultiSignDialog()" style="padding:5px 15px; background-color:#6c757d; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">å–æ¶ˆ</button>
    </div>
</div>

<!-- æ’å…¥åƒæ•¸å°è©±æ¡† -->
<div id="insertParamDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:12px; border:1px solid #ddd; border-radius:4px; z-index:1001; box-shadow: 0 2px 8px rgba(0,0,0,0.15); width:280px; max-width:90vw; max-height:60vh; flex-direction:column; font-size:12px;">
    <h3 style="margin-top:0; margin-bottom:8px; flex-shrink:0; font-size:13px; font-weight:bold;">æ’å…¥åƒæ•¸</h3>

    <!-- åƒæ•¸åˆ—è¡¨ -->
    <div style="flex:1; overflow-y:auto; margin-bottom:8px; min-height:0;">
        <table id="paramListTable" style="width:100%; border-collapse:collapse; font-size:12px;">
            <thead style="position:sticky; top:0; background-color:#f5f5f5; z-index:1;">
                <tr style="border-bottom:1px solid #ddd;">
                    <th style="padding:5px 6px; text-align:left; font-size:12px;">åƒæ•¸åç¨±</th>
                </tr>
            </thead>
            <tbody id="paramListBody">
                <!-- åƒæ•¸åˆ—è¡¨å°‡é€šé JavaScript å‹•æ…‹è¼‰å…¥ -->
            </tbody>
        </table>
    </div>

    <div style="display:flex; gap:6px; justify-content:flex-end; flex-shrink:0;">
        <button id="insertParamBtnOk" type="button" onclick="insertSelectedParam()" style="padding:4px 12px; background-color:#007bff; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">ç¢ºå®š</button>
        <button type="button" onclick="closeInsertParamDialog()" style="padding:4px 12px; background-color:#6c757d; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">å–æ¶ˆ</button>
    </div>
</div>

<!-- æ’å…¥å‡½å¼å°è©±æ¡† -->
<div id="insertFuncDialog" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:12px; border:1px solid #ddd; border-radius:4px; z-index:1001; box-shadow: 0 2px 8px rgba(0,0,0,0.15); width:450px; max-width:90vw; max-height:60vh; flex-direction:column; font-size:12px;">
    <h3 style="margin-top:0; margin-bottom:8px; flex-shrink:0; font-size:13px; font-weight:bold;">æ’å…¥å‡½å¼</h3>

    <!-- å‡½å¼åˆ—è¡¨ -->
    <div style="flex:1; overflow-y:auto; margin-bottom:8px; min-height:0;">
        <table id="funcListTable" style="width:100%; border-collapse:collapse; font-size:12px;">
            <thead style="position:sticky; top:0; background-color:#f5f5f5; z-index:1;">
                <tr style="border-bottom:1px solid #ddd;">
                    <th style="padding:5px 6px; text-align:left; width:40%; border-right:1px solid #ccc; font-size:12px;">å‡½å¼</th>
                    <th style="padding:5px 6px; text-align:left; width:60%; font-size:12px;">èªªæ˜</th>
                </tr>
            </thead>
            <tbody id="funcListBody">
                <!-- å‡½å¼åˆ—è¡¨å°‡é€šé JavaScript å‹•æ…‹è¼‰å…¥ -->
            </tbody>
        </table>
    </div>

    <div style="display:flex; gap:6px; justify-content:flex-end; flex-shrink:0;">
        <button id="insertFuncBtnOk" type="button" onclick="insertSelectedFunc()" style="padding:4px 12px; background-color:#007bff; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">ç¢ºå®š</button>
        <button type="button" onclick="closeInsertFuncDialog()" style="padding:4px 12px; background-color:#6c757d; color:white; border:none; border-radius:3px; cursor:pointer; font-size:12px;">å–æ¶ˆ</button>
    </div>
</div>

<!-- é®ç½©å±¤ -->
<div id="dialogOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:999;" onclick="closeAllDialogs()"></div>

@section Scripts {
    <!-- Drawflow CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/drawflow@0.0.60/dist/drawflow.min.css">

    <!-- å››æ–¹å‘é€£æ¥é»å®šä½ (è¦†å¯« Drawflow é è¨­çš„å·¦å³é…ç½®) -->
    <style>
        /* è¦†å¯« Drawflow é è¨­é€£ç·šç²—ç´°ï¼ˆDrawflow CSS è¼ƒæ™šè¼‰å…¥ï¼Œéœ€åœ¨é€™è£¡å¼·åˆ¶è¦†è“‹ï¼‰ */
        .drawflow .connection .main-path {
            stroke: #4ea9ff !important;
            stroke-width: 1.1px !important;
            fill: none;
        }

        .drawflow .connection.selected .main-path {
            stroke: #ff8c00 !important;
            stroke-width: 2.2px !important;
        }

        /* è®“ inputs/outputs å®¹å™¨è¦†è“‹æ•´å€‹ç¯€é»ï¼Œä»¥ä¾¿å››æ–¹å‘å®šä½ */
        .drawflow .drawflow-node .inputs,
        .drawflow .drawflow-node .outputs {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            overflow: visible;
            pointer-events: none;
        }

        .drawflow .drawflow-node .input,
        .drawflow .drawflow-node .output {
            position: absolute;
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.2s;
            width: 10px;
            height: 10px;
        }

        /* åªåœ¨ç¯€é»è¢«é¸å–æ™‚é¡¯ç¤ºé€£æ¥é»ï¼Œæœªé»é¸æµç¨‹æ™‚ä¸é¡¯ç¤º */
        .drawflow .drawflow-node.selected .input,
        .drawflow .drawflow-node.selected .output,
        .drawflow .drawflow-node.multi-selected .input,
        .drawflow .drawflow-node.multi-selected .output {
            opacity: 1;
        }

        /* é€£æ¥é»ç·¨è™Ÿ: 1=ä¸Š, 2=å³, 3=ä¸‹, 4=å·¦ */
        .drawflow .drawflow-node .inputs .input_1,
        .drawflow .drawflow-node .outputs .output_1 {
            left: 50%;
            top: -5px;
            transform: translateX(-50%);
        }

        .drawflow .drawflow-node .inputs .input_2,
        .drawflow .drawflow-node .outputs .output_2 {
            right: -5px;
            left: auto;
            top: 50%;
            transform: translateY(-50%);
        }

        .drawflow .drawflow-node .inputs .input_3,
        .drawflow .drawflow-node .outputs .output_3 {
            left: 50%;
            bottom: -5px;
            top: auto;
            right: auto;
            transform: translateX(-50%);
        }

        .drawflow .drawflow-node .inputs .input_4,
        .drawflow .drawflow-node .outputs .output_4 {
            left: -5px;
            top: 50%;
            transform: translateY(-50%);
        }
    </style>

    <!-- Drawflow JS -->
    <script src="https://cdn.jsdelivr.net/npm/drawflow@0.0.60/dist/drawflow.min.js"></script>

    <script>
        let editor = null;
        let isLoadingFlow = false;
        let currentFlowDetail = null;
        let currentTransitions = [];
        let currentActIdToNodeIdMap = {};
        const multiSelectedNodeIds = new Set();
        let selectedConnection = null;
        let lastMovedNodePositions = {};
        let isSyncingGroupMove = false;
        const isReadOnly = @isReadOnly;
        const antiForgeryToken = '@antiForgeryToken';

        function appendAntiForgeryToken(form) {
            const tokenInput = document.createElement('input');
            tokenInput.type = 'hidden';
            tokenInput.name = '__RequestVerificationToken';
            tokenInput.value = antiForgeryToken;
            form.appendChild(tokenInput);
        }

        // ç›´æ¥å¾ URL æŸ¥è©¢åƒæ•¸è®€å– prcIdï¼Œé¿å… Razor å‚³éæ™‚çš„ç·¨ç¢¼å•é¡Œ
        function getPrcIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('prcId') || '';
        }

        const currentPrcId = getPrcIdFromUrl();

        function getNodeIdFromElement(nodeEl) {
            if (!nodeEl || !nodeEl.id || !nodeEl.id.startsWith('node-')) return null;
            return nodeEl.id.substring(5);
        }

        function getNodePosition(nodeId) {
            const nodeData = editor?.getNodeFromId(Number(nodeId));
            if (!nodeData) return null;
            return {
                x: Number(nodeData.pos_x) || 0,
                y: Number(nodeData.pos_y) || 0
            };
        }

        function getNodePortContext(nodeId, fallbackPos) {
            const nodeData = nodeId ? editor?.getNodeFromId(Number(nodeId)) : null;
            const nodeEl = nodeId ? document.getElementById('node-' + nodeId) : null;

            return {
                x: Number(nodeData?.pos_x ?? fallbackPos?.x) || 0,
                y: Number(nodeData?.pos_y ?? fallbackPos?.y) || 0,
                width: Number(nodeEl?.offsetWidth ?? fallbackPos?.width) || 150,
                height: Number(nodeEl?.offsetHeight ?? fallbackPos?.height) || 80
            };
        }

        function extractNodeIdFromConnectionToken(token) {
            if (!token) return null;
            const nodeMatch = token.match(/node-(\d+)/i);
            if (nodeMatch) return Number(nodeMatch[1]);
            const suffixMatch = token.match(/(\d+)$/);
            if (suffixMatch) return Number(suffixMatch[1]);
            return null;
        }

        function getConnectionInfoFromElement(connectionEl) {
            if (!connectionEl) return null;
            const classes = Array.from(connectionEl.classList || []);
            const outputClass = classes.find(c => /^output_\d+$/.test(c));
            const inputClass = classes.find(c => /^input_\d+$/.test(c));
            const outputToken = classes.find(c => c.startsWith('node_out_'));
            const inputToken = classes.find(c => c.startsWith('node_in_'));
            const outputId = extractNodeIdFromConnectionToken(outputToken);
            const inputId = extractNodeIdFromConnectionToken(inputToken);

            if (!outputClass || !inputClass || !Number.isFinite(outputId) || !Number.isFinite(inputId)) {
                return null;
            }

            return {
                element: connectionEl,
                output_id: outputId,
                input_id: inputId,
                output_class: outputClass,
                input_class: inputClass
            };
        }

        function ensureConnectionArrows() {
            const svgNs = 'http://www.w3.org/2000/svg';
            const connectionEls = document.querySelectorAll('#drawflow .connection');

            connectionEls.forEach((connectionEl, index) => {
                const mainPath = connectionEl.querySelector('path.main-path');
                if (!mainPath) return;

                let markerId = connectionEl.dataset.arrowMarkerId;
                if (!markerId) {
                    markerId = `flow-arrowhead-${Date.now()}-${index}`;
                    connectionEl.dataset.arrowMarkerId = markerId;
                }

                let defsEl = connectionEl.querySelector('defs');
                if (!defsEl) {
                    defsEl = document.createElementNS(svgNs, 'defs');
                    connectionEl.insertBefore(defsEl, connectionEl.firstChild);
                }

                let markerEl = defsEl.querySelector(`#${markerId}`);
                if (!markerEl) {
                    markerEl = document.createElementNS(svgNs, 'marker');
                    markerEl.setAttribute('id', markerId);
                    markerEl.setAttribute('viewBox', '0 0 18 18');
                    markerEl.setAttribute('refX', '17');
                    markerEl.setAttribute('refY', '9');
                    markerEl.setAttribute('markerWidth', '14');
                    markerEl.setAttribute('markerHeight', '14');
                    markerEl.setAttribute('markerUnits', 'userSpaceOnUse');
                    markerEl.setAttribute('orient', 'auto');

                    const arrowPath = document.createElementNS(svgNs, 'path');
                    arrowPath.setAttribute('d', 'M 0 0 L 18 9 L 0 18 z');
                    arrowPath.setAttribute('fill', '#2f7fbe');
                    arrowPath.setAttribute('stroke', '#2f7fbe');
                    arrowPath.setAttribute('stroke-width', '1');
                    markerEl.appendChild(arrowPath);
                    defsEl.appendChild(markerEl);
                }

                const arrowPath = markerEl.querySelector('path');
                if (arrowPath) {
                    const strokeColor = window.getComputedStyle(mainPath).stroke || '#2f7fbe';
                    arrowPath.setAttribute('fill', strokeColor);
                    arrowPath.setAttribute('stroke', strokeColor);
                }

                mainPath.setAttribute('marker-end', `url(#${markerId})`);
            });
        }

        function clearSelectedConnection() {
            if (selectedConnection?.element) {
                selectedConnection.element.classList.remove('selected');
            }
            selectedConnection = null;
            ensureConnectionArrows();
        }

        function selectConnectionElement(connectionEl) {
            const info = getConnectionInfoFromElement(connectionEl);
            if (!info) {
                clearSelectedConnection();
                return;
            }

            if (selectedConnection?.element === info.element) return;

            clearSelectedConnection();
            info.element.classList.add('selected');
            selectedConnection = info;
            ensureConnectionArrows();
        }

        async function handleDeleteSelectedConnection() {
            if (!selectedConnection) return false;

            if (!confirm('æ˜¯å¦ç¢ºå®šè¦åˆªé™¤é¸ä¸­çš„é€£ç·šï¼Ÿ')) {
                return true;
            }

            const info = selectedConnection;
            clearSelectedConnection();

            try {
                editor.removeSingleConnection(info.output_id, info.input_id, info.output_class, info.input_class);
                markConnectedPorts();
                renderTransitionLabels();
                ensureConnectionArrows();
            } catch (error) {
                console.error('åˆªé™¤é€£ç·šå¤±æ•—:', error, info);
                alert('åˆªé™¤é€£ç·šå¤±æ•—: ' + error.message);
            }

            return true;
        }

        function seedSelectedNodePositions() {
            lastMovedNodePositions = {};
            multiSelectedNodeIds.forEach(nodeId => {
                const pos = getNodePosition(nodeId);
                if (pos) lastMovedNodePositions[nodeId] = pos;
            });
        }

        function getSelectedNodeIds() {
            const flowData = editor.export();
            const moduleData = flowData.drawflow?.Home?.data || {};

            // ä»¥æˆ‘å€‘è‡ªå·±çš„å¤šé¸é›†åˆç‚ºä¸»ï¼Œé¿å…è¢« Drawflow å–®é¸æ¨£å¼è¦†è“‹
            const idsFromSet = Array.from(multiSelectedNodeIds)
                .map(id => String(id))
                .filter(id => !!moduleData[id]);
            if (idsFromSet.length > 0) {
                return idsFromSet;
            }

            // å¾Œå‚™ï¼šè‹¥é›†åˆç‚ºç©ºï¼Œä»å¯è®€å–ç•«é¢ä¸Š selected é¡åˆ¥
            const idsFromDom = [];
            for (const nodeId in moduleData) {
                const nodeEl = document.getElementById('node-' + nodeId);
                if (nodeEl && nodeEl.classList.contains('selected')) {
                    idsFromDom.push(String(nodeId));
                }
            }
            return idsFromDom;
        }

        // è™•ç†åˆªé™¤é¸ä¸­çš„ç‰©ä»¶ï¼ˆå„ªå…ˆåˆªé™¤é€£ç·šï¼Œå…¶æ¬¡åˆªé™¤ç¯€é»ï¼‰
        async function handleDeleteSelectedNodes() {
            if (isReadOnly) {
                alert('å·²å•Ÿç”¨çš„æµç¨‹ç„¡æ³•ä¿®æ”¹');
                return;
            }

            if (!currentPrcId) {
                return;
            }

            if (await handleDeleteSelectedConnection()) {
                return;
            }

            // å–å¾—æ‰€æœ‰é¸ä¸­çš„ç¯€é»
            const flowData = editor.export();
            const moduleData = flowData.drawflow?.Home?.data || {};
            const selectedNodeIds = getSelectedNodeIds();

            if (selectedNodeIds.length === 0) {
                return;
            }

            // æª¢æŸ¥æ˜¯å¦åŒ…å«ä¸å¯åˆªé™¤çš„ç¯€é»ï¼ˆFlowStart, FlowEndï¼‰
            for (const nodeId of selectedNodeIds) {
                const nodeData = moduleData[nodeId];
                const actId = nodeData?.data?.actid;
                const actIdLower = (actId || '').toLowerCase();

                if (actIdLower === 'flowstart') {
                    alert('[æµç¨‹é–‹å§‹] é€™å€‹ç‰©ä»¶ä¸å¯åˆªé™¤ï¼');
                    return;
                }
                if (actIdLower === 'flowend') {
                    alert('[æµç¨‹çµæŸ] é€™å€‹ç‰©ä»¶ä¸å¯åˆªé™¤ï¼');
                    return;
                }
            }

            // é¡¯ç¤ºç¢ºèªå°è©±æ¡†
            if (!confirm('æ˜¯å¦ç¢ºå®šè¦åˆªé™¤é¸ä¸­çš„ç‰©ä»¶ï¼Ÿ')) {
                return;
            }

            // åŸ·è¡Œåˆªé™¤
            for (const nodeId of selectedNodeIds) {
                const nodeData = moduleData[nodeId];
                const actId = nodeData?.data?.actid;

                if (!actId) continue;

                try {
                    // 1. åˆªé™¤è³‡æ–™åº«ä¸­çš„æ´»å‹•è¨˜éŒ„ï¼ˆAPI æœƒè‡ªå‹•åˆªé™¤ç›¸é—œçš„è½‰æ›ï¼‰
                    const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}/activities/${encodeURIComponent(actId)}`, {
                        method: 'DELETE'
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        console.error('åˆªé™¤æ´»å‹•å¤±æ•—:', actId, error);
                        alert(`åˆªé™¤æ´»å‹•å¤±æ•—: ${error.error || error.message}`);
                        continue;
                    }

                    // 2. å¾å‰ç«¯åˆªé™¤ç¯€é»ï¼ˆæœƒè‡ªå‹•åˆªé™¤ç›¸é—œé€£ç·šï¼‰
                    editor.removeNodeId('node-' + nodeId);

                    // 3. å¾æ˜ å°„ä¸­ç§»é™¤
                    delete currentActIdToNodeIdMap[actId];

                    // console.log('å·²åˆªé™¤æ´»å‹•:', actId);
                } catch (error) {
                    console.error('åˆªé™¤æ´»å‹•æ™‚ç™¼ç”ŸéŒ¯èª¤:', actId, error);
                    alert(`åˆªé™¤æ´»å‹•æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
                }
            }

            // æ¸…é™¤å¤šé¸ç‹€æ…‹
            multiSelectedNodeIds.clear();
            applyMultiSelectionClasses();
        }

        // è™•ç†é€£ç·šåˆªé™¤ï¼ˆåŒæ­¥åˆªé™¤è³‡æ–™åº«çš„ XFLdTRAï¼‰
        async function handleConnectionRemoved(info) {
            if (!currentPrcId) return;

            if (selectedConnection &&
                Number(selectedConnection.output_id) === Number(info.output_id) &&
                Number(selectedConnection.input_id) === Number(info.input_id) &&
                selectedConnection.output_class === info.output_class &&
                selectedConnection.input_class === info.input_class) {
                clearSelectedConnection();
            }

            try {
                // å¾é€£ç·šè³‡è¨Šä¸­æ‰¾å‡ºå°æ‡‰çš„ TRAID
                // info åŒ…å«: output_id (source node id), input_id (target node id),
                //            output_class (e.g. "output_1"), input_class (e.g. "input_1")

                const srcNodeId = info.output_id;
                const dstNodeId = info.input_id;

                // å¾ currentTransitions ä¸­æ‰¾å‡ºå°æ‡‰çš„è½‰æ›
                const srcNodeData = editor.getNodeFromId(srcNodeId);
                const dstNodeData = editor.getNodeFromId(dstNodeId);

                const srcActId = srcNodeData?.data?.actid;
                const dstActId = dstNodeData?.data?.actid;

                if (!srcActId || !dstActId) return;

                // æ‰¾å‡ºå°æ‡‰çš„ TRAID
                const transition = currentTransitions.find(t =>
                    (t.srcact || t.SRCACT) === srcActId &&
                    (t.dstact || t.DSTACT) === dstActId
                );

                if (!transition) {
                    console.warn('æ‰¾ä¸åˆ°å°æ‡‰çš„è½‰æ›è¨˜éŒ„:', srcActId, '->', dstActId);
                    return;
                }

                const traId = transition.traid || transition.TRAID;
                if (!traId) return;

                // å‘¼å« API åˆªé™¤è³‡æ–™åº«è¨˜éŒ„
                const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}/transitions/${encodeURIComponent(traId)}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const error = await response.json();
                    console.error('åˆªé™¤è½‰æ›å¤±æ•—:', traId, error);
                } else {
                    // console.log('å·²åˆªé™¤è½‰æ›:', traId);
                    // å¾ currentTransitions ä¸­ç§»é™¤
                    const index = currentTransitions.indexOf(transition);
                    if (index > -1) {
                        currentTransitions.splice(index, 1);
                    }
                }
            } catch (error) {
                console.error('åˆªé™¤è½‰æ›æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
            }
        }

        function applyMultiSelectionClasses() {
            // ç§»é™¤æ‰€æœ‰ç¯€é»çš„å¤šé¸æ¨£å¼
            document.querySelectorAll('.drawflow-node.multi-selected')
                .forEach(el => el.classList.remove('multi-selected'));

            // ç§»é™¤æ‰€æœ‰ç¯€é»çš„ selected é¡åˆ¥
            document.querySelectorAll('.drawflow-node.selected')
                .forEach(el => el.classList.remove('selected'));

            // ç‚ºæ‰€æœ‰åœ¨å¤šé¸é›†åˆä¸­çš„ç¯€é»åŠ ä¸Šæ¨£å¼
            multiSelectedNodeIds.forEach(nodeId => {
                const nodeEl = document.getElementById('node-' + nodeId);
                if (nodeEl) {
                    nodeEl.classList.add('multi-selected');
                    nodeEl.classList.add('selected');  // åŒæ™‚åŠ ä¸Š selected é¡åˆ¥
                }
            });
        }

        function setNodePosition(nodeId, x, y) {
            const moduleName = editor?.module || 'Home';
            const moduleData = editor?.drawflow?.drawflow?.[moduleName]?.data;
            const dataNode = moduleData?.[nodeId];
            if (!dataNode) return;

            dataNode.pos_x = x;
            dataNode.pos_y = y;

            const nodeEl = document.getElementById('node-' + nodeId);
            if (nodeEl) {
                if (nodeEl.style.transform && nodeEl.style.transform !== 'none') {
                    nodeEl.style.transform = `translate(${x}px, ${y}px)`;
                } else {
                    nodeEl.style.left = `${x}px`;
                    nodeEl.style.top = `${y}px`;
                }
            }

            if (typeof editor.updateConnectionNodes === 'function') {
                editor.updateConnectionNodes('node-' + nodeId);
            }
        }

        function moveSelectedNodesByDelta(leaderNodeId, dx, dy) {
            if (multiSelectedNodeIds.size < 2) return;
            if (!multiSelectedNodeIds.has(String(leaderNodeId))) return;
            if (!dx && !dy) return;

            isSyncingGroupMove = true;
            try {
                multiSelectedNodeIds.forEach(nodeId => {
                    if (nodeId === String(leaderNodeId)) return;
                    const pos = getNodePosition(nodeId);
                    if (!pos) return;
                    setNodePosition(nodeId, pos.x + dx, pos.y + dy);
                });
            } finally {
                isSyncingGroupMove = false;
            }
        }

        function handleShiftMultiSelect(event) {
            const nodeEl = event.target.closest('.drawflow-node');
            if (nodeEl) {
                clearSelectedConnection();
                const nodeId = getNodeIdFromElement(nodeEl);
                if (!nodeId) return;

                if (event.shiftKey) {
                    // æŒ‰ä½ Shift é»æ“Šï¼šåˆ‡æ›ç¯€é»çš„é¸ä¸­ç‹€æ…‹ï¼ˆåŠ å…¥æˆ–ç§»é™¤å¤šé¸ï¼‰
                    if (multiSelectedNodeIds.has(nodeId)) {
                        multiSelectedNodeIds.delete(nodeId);
                    } else {
                        multiSelectedNodeIds.add(nodeId);
                    }
                    seedSelectedNodePositions();
                    applyMultiSelectionClasses();
                } else {
                    // ä¸æŒ‰ Shift é»æ“Šï¼šæ¸…é™¤ä¹‹å‰çš„å¤šé¸ï¼Œåªé¸ä¸­ç•¶å‰ç¯€é»
                    multiSelectedNodeIds.clear();
                    multiSelectedNodeIds.add(nodeId);
                    seedSelectedNodePositions();
                    applyMultiSelectionClasses();
                }
                return;
            }

            const connectionEl = event.target.closest('.connection');
            if (connectionEl) {
                multiSelectedNodeIds.clear();
                applyMultiSelectionClasses();
                selectConnectionElement(connectionEl);
                return;
            }

            // é»æ“Šç©ºç™½è™•ï¼šæ¸…é™¤æ‰€æœ‰é¸æ“‡
            if (!nodeEl) {
                if (multiSelectedNodeIds.size > 0) {
                    multiSelectedNodeIds.clear();
                    applyMultiSelectionClasses();
                }
                clearSelectedConnection();
                return;
            }
        }

        // åˆå§‹åŒ– Drawflow
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.getElementById('drawflow');
            editor = new Drawflow(container);
            // Drawflow é è¨­æ˜¯æ›²ç·šé€£ç·šï¼Œå°‡æ›²ç‡é™ç‚º 0 è®“ç·šæ¢ç›¡é‡ç›´é€£
            editor.curvature = 0;
            editor.reroute_curvature = 0;
            editor.reroute_curvature_start_end = 0;
            editor.reroute_fix_curvature = true;

            editor.start();
            container.addEventListener('mousedown', handleShiftMultiSelect, true);

            // è¦†å¯« Drawflow çš„åˆªé™¤éµè¡Œç‚ºï¼ˆå®Œå…¨æ¨¡ä»¿ DELPHI é‚è¼¯ï¼‰
            container.addEventListener('keydown', async function(e) {
                if (e.key === 'Delete') {
                    e.preventDefault();
                    e.stopPropagation();
                    await handleDeleteSelectedNodes();
                }
            }, true);

            // å¦‚æœæœ‰æµç¨‹è³‡æ–™ï¼Œè¼‰å…¥æµç¨‹åœ–
            if (currentPrcId) {
                loadFlowChart(currentPrcId);
            }

            // ä¿æŒ edit æ¨¡å¼è®“ä½¿ç”¨è€…èƒ½è‡ªç”±æª¢è¦–/æ‹–å‹•ç¯€é»
            // ä¸ä½¿ç”¨ Drawflow çš„ view æ¨¡å¼ï¼Œå› ç‚ºå®ƒæœƒå®Œå…¨é–å®šç¯€é»æ‹–å‹•
            // å•Ÿç”¨æµç¨‹æ™‚ï¼Œé€éäº‹ä»¶æ””æˆªé˜²æ­¢çµæ§‹ä¿®æ”¹ï¼ˆæ–°å¢é€£ç·šã€åˆªé™¤ç¯€é»ï¼‰
            if (isReadOnly) {
                editor.on('connectionCreated', function(info) {
                    if (!isLoadingFlow) {
                        editor.removeSingleConnection(info.output_id, info.input_id, info.output_class, info.input_class);
                    }
                });
            }

            // é€£ç·šåˆªé™¤äº‹ä»¶ï¼ˆåŒæ­¥åˆªé™¤è³‡æ–™åº«çš„ XFLdTRAï¼‰
            editor.on('connectionRemoved', async function(info) {
                if (isLoadingFlow || isReadOnly) return;
                await handleConnectionRemoved(info);
                markConnectedPorts();
                renderTransitionLabels();
            });

            editor.on('connectionCreated', function() {
                setTimeout(() => {
                    markConnectedPorts();
                    renderTransitionLabels();
                    ensureConnectionArrows();
                }, 0);
            });

            editor.on('nodeMoved', function(nodeId) {
                const movedNodeId = String(nodeId);
                const currentPos = getNodePosition(movedNodeId);
                const prevPos = lastMovedNodePositions[movedNodeId];

                if (!isSyncingGroupMove && currentPos && prevPos) {
                    const dx = currentPos.x - prevPos.x;
                    const dy = currentPos.y - prevPos.y;
                    moveSelectedNodesByDelta(movedNodeId, dx, dy);
                }

                if (currentPos) {
                    lastMovedNodePositions[movedNodeId] = currentPos;
                }

                renderTransitionLabels();
            });
            editor.on('zoom', renderTransitionLabels);
            editor.on('translate', renderTransitionLabels);
            window.addEventListener('resize', renderTransitionLabels);
        });

        // æ ¹æ“šç¯€é»å¯¦éš›ä½ç½®èˆ‡å°ºå¯¸ï¼Œé¸æ“‡æœ€æ¥è¿‘çš„ä¸€çµ„é€£æ¥åŸ 
        // é€£æ¥é»ç·¨è™Ÿ: 1=ä¸Š, 2=å³, 3=ä¸‹, 4=å·¦
        function getBestPorts(srcPos, dstPos) {
            if (!srcPos || !dstPos) {
                return { output: 'output_1', input: 'input_1' };
            }

            const source = {
                x: Number(srcPos.x) || 0,
                y: Number(srcPos.y) || 0,
                width: Number(srcPos.width) || 150,
                height: Number(srcPos.height) || 80
            };
            const target = {
                x: Number(dstPos.x) || 0,
                y: Number(dstPos.y) || 0,
                width: Number(dstPos.width) || 150,
                height: Number(dstPos.height) || 80
            };

            const oppositeInputIndex = { 1: 3, 2: 4, 3: 1, 4: 2 };

            function getPortPoint(node, index) {
                const halfW = node.width / 2;
                const halfH = node.height / 2;
                switch (index) {
                    case 1: return { x: node.x + halfW, y: node.y };                 // ä¸Š
                    case 2: return { x: node.x + node.width, y: node.y + halfH };   // å³
                    case 3: return { x: node.x + halfW, y: node.y + node.height };  // ä¸‹
                    case 4: return { x: node.x, y: node.y + halfH };                 // å·¦
                    default: return { x: node.x + halfW, y: node.y + halfH };
                }
            }

            let best = null;

            for (let outputIndex = 1; outputIndex <= 4; outputIndex++) {
                for (let inputIndex = 1; inputIndex <= 4; inputIndex++) {
                    const outPoint = getPortPoint(source, outputIndex);
                    const inPoint = getPortPoint(target, inputIndex);

                    const dx = inPoint.x - outPoint.x;
                    const dy = inPoint.y - outPoint.y;
                    const distance = Math.hypot(dx, dy);

                    // å„ªå…ˆé¸æ“‡é¢å°é¢çš„æ–¹å‘ï¼Œé¿å…æ–œå‘ç¹ç·š
                    const facingPenalty = inputIndex === oppositeInputIndex[outputIndex] ? 0 : 24;
                    const score = distance + facingPenalty;

                    if (!best || score < best.score) {
                        best = {
                            score,
                            output: `output_${outputIndex}`,
                            input: `input_${inputIndex}`
                        };
                    }
                }
            }

            return best || { output: 'output_1', input: 'input_1' };
        }

        // æ¨™è¨˜æœ‰é€£ç·šçš„é€£æ¥é»ï¼Œè®“å®ƒå€‘æ°¸é é¡¯ç¤º
        function markConnectedPorts() {
            // å…ˆæ¸…é™¤æ‰€æœ‰ connected class
            document.querySelectorAll('.drawflow-node .connected').forEach(el => el.classList.remove('connected'));

            // å¾ Drawflow åŒ¯å‡ºè³‡æ–™å–å¾—é€£ç·šè³‡è¨Š
            const flowData = editor.export();
            const moduleData = flowData.drawflow?.Home?.data || {};

            for (const nodeId in moduleData) {
                const node = moduleData[nodeId];
                const nodeEl = document.getElementById('node-' + nodeId);
                if (!nodeEl) continue;

                // æ¨™è¨˜æœ‰é€£ç·šçš„ output ç«¯å£
                if (node.outputs) {
                    for (const outName in node.outputs) {
                        if (node.outputs[outName].connections && node.outputs[outName].connections.length > 0) {
                            const portEl = nodeEl.querySelector('.' + outName);
                            if (portEl) portEl.classList.add('connected');
                        }
                    }
                }
                // æ¨™è¨˜æœ‰é€£ç·šçš„ input ç«¯å£
                if (node.inputs) {
                    for (const inName in node.inputs) {
                        if (node.inputs[inName].connections && node.inputs[inName].connections.length > 0) {
                            const portEl = nodeEl.querySelector('.' + inName);
                            if (portEl) portEl.classList.add('connected');
                        }
                    }
                }
            }
        }

        function getNodeCenterByActId(actId) {
            const nodeId = currentActIdToNodeIdMap[actId];
            if (!nodeId) return null;

            const nodeData = editor.getNodeFromId(Number(nodeId));
            if (!nodeData) return null;

            const nodeEl = document.getElementById('node-' + nodeId);
            const width = nodeEl?.offsetWidth || 0;
            const height = nodeEl?.offsetHeight || 0;

            return {
                x: (nodeData.pos_x || 0) + (width / 2),
                y: (nodeData.pos_y || 0) + (height / 2)
            };
        }

        function renderTransitionLabels() {
            const layer = document.getElementById('transitionLabelLayer');
            if (!layer || !editor) return;

            layer.innerHTML = '';
            const zoom = editor.zoom || 1;
            const canvasX = editor.canvas_x || 0;
            const canvasY = editor.canvas_y || 0;

            currentTransitions.forEach(tra => {
                const caption = (tra.caption || tra.CAPTION || '').trim();
                if (!caption) return;

                const srcAct = tra.srcact || tra.SRCACT;
                const dstAct = tra.dstact || tra.DSTACT;
                const srcCenter = getNodeCenterByActId(srcAct);
                const dstCenter = getNodeCenterByActId(dstAct);
                if (!srcCenter || !dstCenter) return;

                const midX = (srcCenter.x + dstCenter.x) / 2;
                const midY = (srcCenter.y + dstCenter.y) / 2;

                const label = document.createElement('div');
                label.className = 'transition-label';
                label.textContent = caption;
                label.style.left = `${(midX * zoom) + canvasX}px`;
                label.style.top = `${(midY * zoom) + canvasY - 8}px`;
                layer.appendChild(label);
            });
        }

        function getNodeVisualConfig(actId, actName, actType) {
            const normalizedActId = (actId || '').toLowerCase();
            const normalizedName = (actName || '').toLowerCase();

            if (normalizedActId === 'flowstart') {
                return {
                    nodeClass: 'node-flowstart',
                    html: `
                        <div class="flag-node">
                            <div class="flag-icon">âš‘</div>
                            <div class="flag-label">æµç¨‹é–‹å§‹</div>
                        </div>
                    `
                };
            }

            if (normalizedActId === 'flowend') {
                return {
                    nodeClass: 'node-flowend',
                    html: `
                        <div class="flag-node">
                            <div class="flag-icon">âš</div>
                            <div class="flag-label">æµç¨‹çµæŸ</div>
                        </div>
                    `
                };
            }

            const isNotify = normalizedName.includes('å‰¯æœ¬é€šçŸ¥')
                || normalizedName.includes('å‰¯æœ¬')
                || normalizedActId.includes('notify');

            if (isNotify) {
                return {
                    nodeClass: 'node-notify',
                    html: `
                        <div class="icon-node">
                            <div class="icon" title="${actName || 'å‰¯æœ¬é€šçŸ¥'}">âœ‰</div>
                            <div class="label">${actName || 'å‰¯æœ¬é€šçŸ¥'}</div>
                        </div>
                    `
                };
            }

            return {
                nodeClass: 'node-manager',
                html: `
                    <div class="icon-node">
                        <div class="icon" title="${actName || 'ç°½æ ¸ä¸»ç®¡'}">ğŸ‘¨â€ğŸ’¼</div>
                        <div class="label">${actName || 'ç°½æ ¸ä¸»ç®¡'}</div>
                    </div>
                `
            };
        }

        // è¼‰å…¥æµç¨‹åœ–
        async function loadFlowChart(prcId) {
            isLoadingFlow = true;
            try {
                const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(prcId)}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || errorData.message || 'è¼‰å…¥æµç¨‹åœ–å¤±æ•—');
                }

                const data = await response.json();
                currentFlowDetail = data;
                // console.log('è¼‰å…¥çš„æµç¨‹è³‡æ–™:', data);

                // æ¸…ç©ºç¾æœ‰çš„ç·¨è¼¯å™¨å…§å®¹
                editor.clear();
                clearSelectedConnection();
                multiSelectedNodeIds.clear();
                lastMovedNodePositions = {};
                applyMultiSelectionClasses();

                // å»ºç«‹ ACTID èˆ‡ Drawflow ç¯€é» ID çš„æ˜ å°„
                const actIdToNodeIdMap = {};
                currentActIdToNodeIdMap = {};
                currentTransitions = data.transitions || [];

                // è¼‰å…¥æ´»å‹•ç¯€é»
                if (data.activities && data.activities.length > 0) {
                    data.activities.forEach(act => {
                        // ä½¿ç”¨å¤§å¯«æ¬„ä½åç¨±ï¼ˆC# API å›å‚³çš„æ ¼å¼ï¼‰
                        const actId = act.actid || act.ACTID || '';
                        const actName = act.actname || act.ACTNAME || actId;
                        const actType = act.acttype || act.ACTTYPE || 0;
                        const x = act.x || act.X || 100;
                        const y = act.y || act.Y || 100;

                        const visual = getNodeVisualConfig(actId, actName, actType);

                        // æ–°å¢ç¯€é»åˆ°ç·¨è¼¯å™¨ (4 inputs: ä¸Š/å³/ä¸‹/å·¦, 4 outputs: ä¸Š/å³/ä¸‹/å·¦)
                        try {
                            const nodeId = editor.addNode(
                                actName,
                                4,  // è¼¸å…¥æ•¸é‡ (input_1=ä¸Š, input_2=å³, input_3=ä¸‹, input_4=å·¦)
                                4,  // è¼¸å‡ºæ•¸é‡ (output_1=ä¸Š, output_2=å³, output_3=ä¸‹, output_4=å·¦)
                                x,
                                y,
                                visual.nodeClass,
                                { actid: actId, acttype: actType },
                                visual.html
                            );
                            // å»ºç«‹æ˜ å°„ï¼šACTID -> Drawflow ç¯€é» ID
                            actIdToNodeIdMap[actId] = nodeId;
                            currentActIdToNodeIdMap[actId] = nodeId;
                            // console.log('å·²æ–°å¢ç¯€é»:', actId, actName, '-> Drawflow ID:', nodeId);
                        } catch (e) {
                            console.error('æ–°å¢ç¯€é»å¤±æ•—:', e, act);
                        }
                    });
                }

                // å»ºç«‹æ´»å‹•ä½ç½®æŸ¥è©¢è¡¨ (ç”¨æ–¼æ™ºæ…§é€£æ¥åŸ é¸æ“‡)
                const actPositions = {};
                if (data.activities) {
                    data.activities.forEach(act => {
                        const id = act.actid || act.ACTID || '';
                        actPositions[id] = {
                            x: act.x || act.X || 100,
                            y: act.y || act.Y || 100
                        };
                    });
                }

                // ç­‰å¾…ç¯€é»æ¸²æŸ“å®Œæˆå¾Œå†å»ºç«‹é€£ç·š
                setTimeout(() => {
                    if (data.transitions && data.transitions.length > 0) {
                        data.transitions.forEach(tra => {
                            try {
                                const srcAct = tra.srcact || tra.SRCACT;
                                const dstAct = tra.dstact || tra.DSTACT;

                                if (srcAct && dstAct) {
                                    const srcNodeId = actIdToNodeIdMap[srcAct];
                                    const dstNodeId = actIdToNodeIdMap[dstAct];

                                    if (srcNodeId && dstNodeId) {
                                        // æ ¹æ“šç¯€é»å¯¦éš›ä½ç½®èˆ‡å°ºå¯¸ï¼Œé¸æ“‡æœ€æ¥è¿‘çš„é€£æ¥åŸ 
                                        const srcContext = getNodePortContext(srcNodeId, actPositions[srcAct]);
                                        const dstContext = getNodePortContext(dstNodeId, actPositions[dstAct]);
                                        const ports = getBestPorts(srcContext, dstContext);
                                        editor.addConnection(
                                            srcNodeId,
                                            dstNodeId,
                                            ports.output,
                                            ports.input
                                        );
                                        // console.log('å·²å»ºç«‹é€£ç·š:', srcAct, '->', dstAct, `(${ports.output} â†’ ${ports.input})`);
                                    } else {
                                        console.warn('æ‰¾ä¸åˆ°ç¯€é» ID:', { srcAct, srcNodeId, dstAct, dstNodeId });
                                    }
                                }
                            } catch (e) {
                                console.warn('ç„¡æ³•å»ºç«‹é€£ç·š:', e, tra);
                            }
                        });
                    }

                    // console.log('æµç¨‹åœ–è¼‰å…¥å®Œæˆ');
                    markConnectedPorts();
                    renderTransitionLabels();
                    ensureConnectionArrows();
                    isLoadingFlow = false;
                }, 100);

            } catch (error) {
                isLoadingFlow = false;
                console.error('è¼‰å…¥æµç¨‹åœ–å¤±æ•—:', error);
                alert('è¼‰å…¥æµç¨‹åœ–å¤±æ•—: ' + error.message);
            }
        }

        async function showFlowContentDialog() {
            if (!currentPrcId) {
                alert('è«‹å…ˆé–‹å•ŸFLOWæµç¨‹æª”');
                return;
            }

            try {
                let detail = currentFlowDetail;
                if (!detail || !detail.flow) {
                    const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}`);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || errorData.message || 'è¼‰å…¥æµç¨‹å…§å®¹å¤±æ•—');
                    }
                    detail = await response.json();
                    currentFlowDetail = detail;
                }

                const flow = detail.flow || {};
                const events = detail.events || [];

                document.getElementById('flowContentPrcId').value = flow.prcid || flow.PRCID || currentPrcId;
                document.getElementById('flowContentPrcName').value = flow.prcname || flow.PRCNAME || '';
                document.getElementById('flowContentDescrip').value = flow.descrip || flow.DESCRIP || '';

                const evtList = document.getElementById('flowContentEvtList');
                evtList.innerHTML = '';
                // åªé¡¯ç¤ºæµç¨‹äº‹ä»¶ï¼ˆEVTTYPE=0 æˆ– RELATEID=""ï¼‰ï¼Œä¸é¡¯ç¤ºæ´»å‹•äº‹ä»¶ï¼ˆEVTTYPE=1ï¼‰
                const flowEvents = events.filter(evt => {
                    const evtType = evt.evttype ?? evt.EVTTYPE ?? 0;
                    const relateId = (evt.relateid ?? evt.RELATEID ?? '').trim();
                    return evtType === 0 || relateId === '';
                });
                flowEvents.forEach(evt => {
                    const evtName = evt.evtname || evt.EVTNAME || '';
                    const option = document.createElement('option');
                    option.value = evtName;
                    option.textContent = evtName;
                    option.dataset.onexec = evt.onexec || evt.ONEXEC || '';
                    evtList.appendChild(option);
                });

                if (evtList.options.length > 0) {
                    evtList.selectedIndex = 0;
                    onFlowContentEventChanged();
                } else {
                    document.getElementById('flowContentOnExec').value = '';
                }

                applyFlowContentReadOnlyState();

                document.getElementById('flowContentDialog').style.display = 'block';
                document.getElementById('dialogOverlay').style.display = 'block';
            } catch (error) {
                console.error('é–‹å•Ÿæµç¨‹å…§å®¹å¤±æ•—:', error);
                alert('é–‹å•Ÿæµç¨‹å…§å®¹å¤±æ•—: ' + error.message);
            }
        }

        function onFlowContentEventChanged() {
            const evtList = document.getElementById('flowContentEvtList');
            const selected = evtList.options[evtList.selectedIndex];
            document.getElementById('flowContentOnExec').value = selected ? (selected.dataset.onexec || '') : '';
        }

        function applyFlowContentReadOnlyState() {
            const flow = currentFlowDetail?.flow || {};
            const finished = (flow.finished ?? flow.Finished ?? 0) === 1;

            document.getElementById('flowContentPrcId').readOnly = true;
            document.getElementById('flowContentPrcName').readOnly = finished;
            document.getElementById('flowContentDescrip').readOnly = finished;
            document.getElementById('flowContentOnExec').readOnly = finished;

            document.getElementById('flowContentBtnDelete').disabled = finished;
            document.getElementById('flowContentBtnInsertVar').disabled = finished;
            document.getElementById('flowContentBtnInsertFunc').disabled = finished;
            document.getElementById('flowContentBtnOk').disabled = finished;
        }

        function closeFlowContentDialog() {
            document.getElementById('flowContentDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        // æ’å…¥åƒæ•¸ç›¸é—œå‡½æ•¸
        async function showInsertParamDialog() {
            const evtList = document.getElementById('flowContentEvtList');
            const selectedOption = evtList.options[evtList.selectedIndex];
            if (!selectedOption) {
                alert('è«‹å…ˆé¸æ“‡æµç¨‹äº‹ä»¶');
                return;
            }

            const evtName = selectedOption.value;

            try {
                // å‘¼å« API å–å¾—åƒæ•¸åˆ—è¡¨
                const response = await fetch(`/api/FlowDesigner/params/${encodeURIComponent(evtName)}`);
                if (!response.ok) {
                    throw new Error('å–å¾—åƒæ•¸åˆ—è¡¨å¤±æ•—');
                }

                const params = await response.json();

                // å¡«å……åƒæ•¸åˆ—è¡¨
                const tbody = document.getElementById('paramListBody');
                tbody.innerHTML = '';

                if (params.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td style="padding:5px 6px; text-align:center; color:#999; font-size:12px;">ç„¡å¯ç”¨åƒæ•¸</td>';
                    tbody.appendChild(row);
                } else {
                    params.forEach((param, index) => {
                        const paramName = param.paramname || param.PARAMNAME || '';
                        const row = document.createElement('tr');
                        row.style.cursor = 'pointer';
                        row.style.borderBottom = '1px solid #eee';
                        row.dataset.paramName = paramName;
                        row.innerHTML = `<td style="padding:5px 6px; font-size:12px;">${paramName}</td>`;

                        // é»æ“Šé¸ä¸­
                        row.addEventListener('click', function() {
                            // ç§»é™¤å…¶ä»–è¡Œçš„é¸ä¸­ç‹€æ…‹
                            tbody.querySelectorAll('tr').forEach(r => r.style.backgroundColor = '');
                            // é¸ä¸­ç•¶å‰è¡Œ
                            this.style.backgroundColor = '#e3f2fd';
                        });

                        // é›™æ“Šç›´æ¥æ’å…¥
                        row.addEventListener('dblclick', function() {
                            insertParamByName(paramName);
                            closeInsertParamDialog();
                        });

                        tbody.appendChild(row);
                    });
                }

                // é¡¯ç¤ºå°è©±æ¡†
                document.getElementById('insertParamDialog').style.display = 'flex';
                document.getElementById('dialogOverlay').style.display = 'block';
            } catch (error) {
                console.error('è¼‰å…¥åƒæ•¸åˆ—è¡¨å¤±æ•—:', error);
                alert('è¼‰å…¥åƒæ•¸åˆ—è¡¨å¤±æ•—: ' + error.message);
            }
        }

        function closeInsertParamDialog() {
            document.getElementById('insertParamDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        function insertSelectedParam() {
            const tbody = document.getElementById('paramListBody');
            const selectedRow = tbody.querySelector('tr[style*="background-color: rgb(227, 242, 253)"]');

            if (!selectedRow) {
                alert('è«‹é¸æ“‡ä¸€å€‹åƒæ•¸');
                return;
            }

            const paramName = selectedRow.dataset.paramName;
            const isActivityContext = selectedRow.dataset.isActivityContext === 'true';

            // æ ¹æ“šä¸Šä¸‹æ–‡é¸æ“‡æ’å…¥å‡½æ•¸
            if (isActivityContext) {
                insertParamByNameToActivity(paramName);
            } else {
                insertParamByName(paramName);
            }

            closeInsertParamDialog();
        }

        function insertParamByName(paramName) {
            const textarea = document.getElementById('flowContentOnExec');
            const startPos = textarea.selectionStart;
            const endPos = textarea.selectionEnd;
            const text = textarea.value;

            // åœ¨æ¸¸æ¨™ä½ç½®æ’å…¥åƒæ•¸åç¨±
            const newText = text.substring(0, startPos) + paramName + text.substring(endPos);
            textarea.value = newText;

            // è¨­å®šæ¸¸æ¨™ä½ç½®ï¼ˆåœ¨æ’å…¥çš„æ–‡å­—ä¹‹å¾Œï¼Œä¸¦é¸ä¸­æ’å…¥çš„æ–‡å­—ï¼‰
            textarea.focus();
            textarea.setSelectionRange(startPos, startPos + paramName.length);
        }

        // æ’å…¥åƒæ•¸åˆ°æ´»å‹•å…§å®¹å°è©±æ¡†
        function insertParamByNameToActivity(paramName) {
            const textarea = document.getElementById('activityContentOnExec');
            const startPos = textarea.selectionStart;
            const endPos = textarea.selectionEnd;
            const text = textarea.value;

            // åœ¨æ¸¸æ¨™ä½ç½®æ’å…¥åƒæ•¸åç¨±
            const newText = text.substring(0, startPos) + paramName + text.substring(endPos);
            textarea.value = newText;

            // è¨­å®šæ¸¸æ¨™ä½ç½®ï¼ˆåœ¨æ’å…¥çš„æ–‡å­—ä¹‹å¾Œï¼Œä¸¦é¸ä¸­æ’å…¥çš„æ–‡å­—ï¼‰
            textarea.focus();
            textarea.setSelectionRange(startPos, startPos + paramName.length);
        }

        // ç‚ºæ´»å‹•å…§å®¹å°è©±æ¡†é¡¯ç¤ºæ’å…¥åƒæ•¸å°è©±æ¡†
        async function showInsertParamDialogForActivity() {
            const evtList = document.getElementById('activityContentEvtList');
            const selectedOption = evtList.options[evtList.selectedIndex];
            if (!selectedOption) {
                alert('è«‹å…ˆé¸æ“‡æµç¨‹äº‹ä»¶');
                return;
            }

            const evtName = selectedOption.value;

            try {
                // å‘¼å« API å–å¾—åƒæ•¸åˆ—è¡¨
                const response = await fetch(`/api/FlowDesigner/params/${encodeURIComponent(evtName)}`);
                if (!response.ok) {
                    throw new Error('å–å¾—åƒæ•¸åˆ—è¡¨å¤±æ•—');
                }

                const params = await response.json();

                // å¡«å……åƒæ•¸åˆ—è¡¨
                const tbody = document.getElementById('paramListBody');
                tbody.innerHTML = '';

                if (params.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td style="padding:5px 6px; text-align:center; color:#999; font-size:12px;">ç„¡å¯ç”¨åƒæ•¸</td>';
                    tbody.appendChild(row);
                } else {
                    params.forEach((param, index) => {
                        const paramName = param.paramname || param.PARAMNAME || '';
                        const row = document.createElement('tr');
                        row.style.cursor = 'pointer';
                        row.style.borderBottom = '1px solid #eee';
                        row.dataset.paramName = paramName;
                        row.dataset.isActivityContext = 'true';
                        row.innerHTML = `<td style="padding:5px 6px; font-size:12px;">${paramName}</td>`;

                        // é»æ“Šé¸ä¸­
                        row.addEventListener('click', function() {
                            // ç§»é™¤å…¶ä»–è¡Œçš„é¸ä¸­ç‹€æ…‹
                            tbody.querySelectorAll('tr').forEach(r => r.style.backgroundColor = '');
                            // é¸ä¸­ç•¶å‰è¡Œ
                            this.style.backgroundColor = '#e3f2fd';
                        });

                        // é›™æ“Šç›´æ¥æ’å…¥
                        row.addEventListener('dblclick', function() {
                            insertParamByNameToActivity(paramName);
                            closeInsertParamDialog();
                        });

                        tbody.appendChild(row);
                    });
                }

                // æ¨™è¨˜ç•¶å‰ä¸Šä¸‹æ–‡ç‚ºæ´»å‹•å…§å®¹å°è©±æ¡†
                document.getElementById('insertParamDialog').dataset.context = 'activity';

                // é¡¯ç¤ºå°è©±æ¡†
                document.getElementById('insertParamDialog').style.display = 'flex';
                document.getElementById('dialogOverlay').style.display = 'block';
            } catch (error) {
                alert('è¼‰å…¥åƒæ•¸åˆ—è¡¨å¤±æ•—: ' + error.message);
            }
        }

        // æ’å…¥å‡½å¼ç›¸é—œå‡½æ•¸
        async function showInsertFuncDialog() {
            try {
                // å‘¼å« API å–å¾—å‡½å¼åˆ—è¡¨
                const response = await fetch('/api/FlowDesigner/functions');
                if (!response.ok) {
                    throw new Error('å–å¾—å‡½å¼åˆ—è¡¨å¤±æ•—');
                }

                const functions = await response.json();

                // å¡«å……å‡½å¼åˆ—è¡¨
                const tbody = document.getElementById('funcListBody');
                tbody.innerHTML = '';

                if (functions.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td colspan="2" style="padding:5px 6px; text-align:center; color:#999; font-size:12px;">ç„¡å¯ç”¨å‡½å¼</td>';
                    tbody.appendChild(row);
                } else {
                    functions.forEach((func, index) => {
                        const funcName = func.funcname || func.FUNCNAME || '';
                        const funcDesc = func.funcdesc || func.FUNCDESC || '';
                        const row = document.createElement('tr');
                        row.style.cursor = 'pointer';
                        row.style.borderBottom = '1px solid #eee';
                        row.dataset.funcName = funcName;
                        row.innerHTML = `
                            <td style="padding:5px 6px; border-right:1px solid #ddd; font-size:12px;">${funcName}</td>
                            <td style="padding:5px 6px; font-size:12px;">${funcDesc}</td>
                        `;

                        // é»æ“Šé¸ä¸­
                        row.addEventListener('click', function() {
                            // ç§»é™¤å…¶ä»–è¡Œçš„é¸ä¸­ç‹€æ…‹
                            tbody.querySelectorAll('tr').forEach(r => r.style.backgroundColor = '');
                            // é¸ä¸­ç•¶å‰è¡Œ
                            this.style.backgroundColor = '#e3f2fd';
                        });

                        // é›™æ“Šç›´æ¥æ’å…¥
                        row.addEventListener('dblclick', function() {
                            insertFuncByName(funcName);
                            closeInsertFuncDialog();
                        });

                        tbody.appendChild(row);
                    });
                }

                // é¡¯ç¤ºå°è©±æ¡†
                document.getElementById('insertFuncDialog').style.display = 'flex';
                document.getElementById('dialogOverlay').style.display = 'block';
            } catch (error) {
                console.error('è¼‰å…¥å‡½å¼åˆ—è¡¨å¤±æ•—:', error);
                alert('è¼‰å…¥å‡½å¼åˆ—è¡¨å¤±æ•—: ' + error.message);
            }
        }

        function closeInsertFuncDialog() {
            document.getElementById('insertFuncDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        function insertSelectedFunc() {
            const tbody = document.getElementById('funcListBody');
            const selectedRow = tbody.querySelector('tr[style*="background-color: rgb(227, 242, 253)"]');

            if (!selectedRow) {
                alert('è«‹é¸æ“‡ä¸€å€‹å‡½å¼');
                return;
            }

            const funcName = selectedRow.dataset.funcName;
            const isActivityContext = selectedRow.dataset.isActivityContext === 'true';

            // æ ¹æ“šä¸Šä¸‹æ–‡é¸æ“‡æ’å…¥å‡½æ•¸
            if (isActivityContext) {
                insertFuncByNameToActivity(funcName);
            } else {
                insertFuncByName(funcName);
            }

            closeInsertFuncDialog();
        }

        function insertFuncByName(funcName) {
            const textarea = document.getElementById('flowContentOnExec');
            const startPos = textarea.selectionStart;
            const endPos = textarea.selectionEnd;
            const text = textarea.value;

            // åœ¨æ¸¸æ¨™ä½ç½®æ’å…¥å‡½å¼åç¨±
            const newText = text.substring(0, startPos) + funcName + text.substring(endPos);
            textarea.value = newText;

            // è¨­å®šæ¸¸æ¨™ä½ç½®ï¼ˆåœ¨æ’å…¥çš„æ–‡å­—ä¹‹å¾Œï¼Œä¸¦é¸ä¸­æ’å…¥çš„æ–‡å­—ï¼‰
            textarea.focus();
            textarea.setSelectionRange(startPos, startPos + funcName.length);
        }

        // æ’å…¥å‡½å¼åˆ°æ´»å‹•å…§å®¹å°è©±æ¡†
        function insertFuncByNameToActivity(funcName) {
            const textarea = document.getElementById('activityContentOnExec');
            const startPos = textarea.selectionStart;
            const endPos = textarea.selectionEnd;
            const text = textarea.value;

            // åœ¨æ¸¸æ¨™ä½ç½®æ’å…¥å‡½å¼åç¨±
            const newText = text.substring(0, startPos) + funcName + text.substring(endPos);
            textarea.value = newText;

            // è¨­å®šæ¸¸æ¨™ä½ç½®ï¼ˆåœ¨æ’å…¥çš„æ–‡å­—ä¹‹å¾Œï¼Œä¸¦é¸ä¸­æ’å…¥çš„æ–‡å­—ï¼‰
            textarea.focus();
            textarea.setSelectionRange(startPos, startPos + funcName.length);
        }

        // ç‚ºæ´»å‹•å…§å®¹å°è©±æ¡†é¡¯ç¤ºæ’å…¥å‡½å¼å°è©±æ¡†
        async function showInsertFuncDialogForActivity() {
            try {
                // å‘¼å« API å–å¾—å‡½å¼åˆ—è¡¨
                const response = await fetch('/api/FlowDesigner/functions');
                if (!response.ok) {
                    throw new Error('å–å¾—å‡½å¼åˆ—è¡¨å¤±æ•—');
                }

                const functions = await response.json();

                // å¡«å……å‡½å¼åˆ—è¡¨
                const tbody = document.getElementById('funcListBody');
                tbody.innerHTML = '';

                if (functions.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td colspan="2" style="padding:5px 6px; text-align:center; color:#999; font-size:12px;">ç„¡å¯ç”¨å‡½å¼</td>';
                    tbody.appendChild(row);
                } else {
                    functions.forEach((func, index) => {
                        const funcName = func.funcname || func.FUNCNAME || '';
                        const funcDesc = func.funcdesc || func.FUNCDESC || '';
                        const row = document.createElement('tr');
                        row.style.cursor = 'pointer';
                        row.style.borderBottom = '1px solid #eee';
                        row.dataset.funcName = funcName;
                        row.dataset.isActivityContext = 'true';
                        row.innerHTML = `
                            <td style="padding:5px 6px; border-right:1px solid #ddd; font-size:12px;">${funcName}</td>
                            <td style="padding:5px 6px; font-size:12px;">${funcDesc}</td>
                        `;

                        // é»æ“Šé¸ä¸­
                        row.addEventListener('click', function() {
                            // ç§»é™¤å…¶ä»–è¡Œçš„é¸ä¸­ç‹€æ…‹
                            tbody.querySelectorAll('tr').forEach(r => r.style.backgroundColor = '');
                            // é¸ä¸­ç•¶å‰è¡Œ
                            this.style.backgroundColor = '#e3f2fd';
                        });

                        // é›™æ“Šç›´æ¥æ’å…¥
                        row.addEventListener('dblclick', function() {
                            insertFuncByNameToActivity(funcName);
                            closeInsertFuncDialog();
                        });

                        tbody.appendChild(row);
                    });
                }

                // æ¨™è¨˜ç•¶å‰ä¸Šä¸‹æ–‡ç‚ºæ´»å‹•å…§å®¹å°è©±æ¡†
                document.getElementById('insertFuncDialog').dataset.context = 'activity';

                // é¡¯ç¤ºå°è©±æ¡†
                document.getElementById('insertFuncDialog').style.display = 'flex';
                document.getElementById('dialogOverlay').style.display = 'block';
            } catch (error) {
                alert('è¼‰å…¥å‡½å¼åˆ—è¡¨å¤±æ•—: ' + error.message);
            }
        }

        // å¾ Drawflow åŒ¯å‡ºè³‡æ–™ä¸­æå–ç¯€é»ä½ç½®
        function extractNodePositions() {
            const flowData = editor.export();
            const positions = [];
            const moduleData = flowData.drawflow?.Home?.data || {};

            for (const nodeId in moduleData) {
                const node = moduleData[nodeId];
                const actId = node.data?.actid;
                if (actId) {
                    positions.push({
                        actId: actId,
                        x: Math.round(node.pos_x),
                        y: Math.round(node.pos_y)
                    });
                }
            }
            return positions;
        }

        // å„²å­˜æµç¨‹
        async function saveFlow() {
            if (!currentPrcId) {
                alert('è«‹å…ˆé–‹å•Ÿæˆ–å»ºç«‹æµç¨‹');
                return;
            }

            try {
                // å„²å­˜ç¯€é»ä½ç½®åˆ° XFLdActï¼ˆå•Ÿç”¨çš„æµç¨‹ä¹Ÿå¯ä»¥å­˜ä½ç½®ï¼‰
                const positions = extractNodePositions();
                const posResponse = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}/positions`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(positions)
                });

                if (!posResponse.ok) {
                    const err = await posResponse.json();
                    throw new Error(err.error || 'å„²å­˜ä½ç½®å¤±æ•—');
                }

                if (isReadOnly) {
                    alert('ç¯€é»ä½ç½®å·²å„²å­˜');
                    return;
                }

                // éå”¯è®€æ™‚ï¼Œä¹Ÿå„²å­˜å®Œæ•´çš„æµç¨‹åœ–è³‡æ–™
                const flowData = editor.export();
                const flowChart = JSON.stringify(flowData);

                const form = document.createElement('form');
                form.method = 'post';
                form.action = '?handler=Save';

                const prcIdInput = document.createElement('input');
                prcIdInput.type = 'hidden';
                prcIdInput.name = 'prcId';
                prcIdInput.value = currentPrcId;
                form.appendChild(prcIdInput);

                const flowChartInput = document.createElement('input');
                flowChartInput.type = 'hidden';
                flowChartInput.name = 'flowChart';
                flowChartInput.value = flowChart;
                form.appendChild(flowChartInput);

                appendAntiForgeryToken(form);
                document.body.appendChild(form);
                form.submit();

            } catch (error) {
                console.error('å„²å­˜å¤±æ•—:', error);
                alert('å„²å­˜å¤±æ•—: ' + error.message);
            }
        }

        // åˆªé™¤æµç¨‹
        function deleteFlow() {
            if (!currentPrcId) return;
            if (!confirm('ç¢ºå®šè¦åˆªé™¤æ­¤æµç¨‹å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚')) return;

            const form = document.createElement('form');
            form.method = 'post';
            form.action = '?handler=Delete';

            const prcIdInput = document.createElement('input');
            prcIdInput.type = 'hidden';
            prcIdInput.name = 'prcId';
            prcIdInput.value = currentPrcId;
            form.appendChild(prcIdInput);

            appendAntiForgeryToken(form);
            document.body.appendChild(form);
            form.submit();
        }

        // åˆ‡æ›å•Ÿç”¨ç‹€æ…‹
        function toggleFlowStatus() {
            if (!currentPrcId) return;

            const form = document.createElement('form');
            form.method = 'post';
            form.action = '?handler=ToggleStatus';

            const prcIdInput = document.createElement('input');
            prcIdInput.type = 'hidden';
            prcIdInput.name = 'prcId';
            prcIdInput.value = currentPrcId;
            form.appendChild(prcIdInput);

            appendAntiForgeryToken(form);
            document.body.appendChild(form);
            form.submit();
        }

        // é¡¯ç¤ºæµç¨‹äº‹ä»¶
        function showFlowEvents() {
            alert('æµç¨‹äº‹ä»¶åŠŸèƒ½å¾…å¯¦ä½œ');
        }

        // é‡æ–°è¼‰å…¥æµç¨‹
        function reloadFlow() {
            if (!currentPrcId) return;

            if (confirm('ç¢ºå®šè¦é‡æ–°è¼‰å…¥æµç¨‹ï¼Ÿæœªå„²å­˜çš„è®Šæ›´å°‡æœƒéºå¤±ã€‚')) {
                window.location.reload();
            }
        }

        // è‡ªå‹•æ’åˆ—æµç¨‹ä½ˆå±€
        // å–å¾—ç¯€é»é¡å‹ï¼ˆ1=FlowStart, 2=FlowEnd, 3=Normalï¼‰
        function getNodeKind(nodeData) {
            const actId = (nodeData?.data?.actid || '').toLowerCase();
            if (actId === 'flowstart') return 1;
            if (actId === 'flowend') return 2;
            return 3; // Normal or others
        }

        // å–å¾—é è¨­é€£ç·šæ¨™é¡Œï¼ˆæ¨¡ä»¿ DELPHI funGetDefCaptionï¼‰
        function getDefCaption(iKind1, iKind2) {
            let iType = 0;

            if (iKind1 === 3 && iKind2 === 3) iType = 1;
            else if (iKind1 === 3 && iKind2 === 2) iType = 2;

            switch (iType) {
                case 0: return 'åŒæ„';
                case 1: return 'ERPæ±ºç­–(ä¸­é–“)';
                case 2: return 'ERPæ±ºç­–(æœ€å¾Œ)';
                default: return 'åŒæ„';
            }
        }

        // å–å¾—é è¨­ SQLï¼ˆæ¨¡ä»¿ DELPHI funGetDefSQLï¼‰
        function getDefSQL(iKind1, iKind2) {
            let iType = 0;

            if (iKind1 === 3 && iKind2 === 3) iType = 1;
            else if (iKind1 === 3 && iKind2 === 2) iType = 2;

            switch (iType) {
                case 0:
                    return "IF @@å¯©æ ¸çµæœ='åŒæ„' SET @@æµç¨‹çµæœ='ç¶“é'";
                case 1:
                    return "IF @@å¯©æ ¸çµæœ='åŒæ„' SET @@æµç¨‹çµæœ='ç¶“é' ELSE EXEC CURdOCXFlowBackToPaper @@å–®æ“šé¡å‹,@@å–®æ“šç·¨è™Ÿ,32,@@ç”³è«‹äºº,@@å¯„ä»¶äºº,@@æµç¨‹ç·¨è™Ÿ,@@ä»£ç†äºº";
                case 2:
                    return "IF @@å¯©æ ¸çµæœ='åŒæ„' EXEC CURdOCXFlowBackToPaper @@å–®æ“šé¡å‹,@@å–®æ“šç·¨è™Ÿ,1,@@ç”³è«‹äºº,@@å¯„ä»¶äºº,@@æµç¨‹ç·¨è™Ÿ,@@ä»£ç†äºº ELSE EXEC CURdOCXFlowBackToPaper @@å–®æ“šé¡å‹,@@å–®æ“šç·¨è™Ÿ,32,@@ç”³è«‹äºº,@@å¯„ä»¶äºº,@@æµç¨‹ç·¨è™Ÿ,@@ä»£ç†äºº SET @@æµç¨‹çµæœ='ç¶“é'";
                default:
                    return "IF @@å¯©æ ¸çµæœ='åŒæ„' SET @@æµç¨‹çµæœ='ç¶“é'";
            }
        }

        // æµç¨‹æ–¹å‘ï¼šåœ¨å…©å€‹é¸ä¸­çš„ç¯€é»ä¹‹é–“å‰µå»ºé€£ç·šï¼ˆæ¨¡ä»¿ DELPHI btnTraClick + DoLinkï¼‰
        async function autoArrangeFlow() {
            if (!currentPrcId) {
                alert('è«‹å…ˆé–‹å•Ÿæˆ–å»ºç«‹æµç¨‹');
                return;
            }

            if (isReadOnly) {
                alert('å·²å•Ÿç”¨çš„æµç¨‹ç„¡æ³•ä¿®æ”¹');
                return;
            }

            // å–å¾—æ‰€æœ‰é¸ä¸­çš„ç¯€é»
            const flowData = editor.export();
            const moduleData = flowData.drawflow?.Home?.data || {};
            const selectedNodeIds = getSelectedNodeIds();

            // console.log('é¸ä¸­çš„ç¯€é»æ•¸é‡:', selectedNodeIds.length, 'ç¯€é»ID:', selectedNodeIds);

            // å¿…é ˆæ°å¥½é¸ä¸­ 2 å€‹ç¯€é»
            if (selectedNodeIds.length !== 2) {
                alert('è«‹ä½¿ç”¨ Shift é¸æ“‡æ°å¥½ 2 å€‹ç¯€é»');
                return;
            }

            const node1Data = moduleData[selectedNodeIds[0]];
            const node2Data = moduleData[selectedNodeIds[1]];

            const srcActId = node1Data?.data?.actid;
            const dstActId = node2Data?.data?.actid;
            const srcActName = node1Data?.name || srcActId;
            const dstActName = node2Data?.name || dstActId;

            // console.log('é€£ç·šæ–¹å‘:', srcActName, 'â†’', dstActName);

            if (!srcActId || !dstActId) {
                alert('ç¯€é»è³‡æ–™ä¸å®Œæ•´');
                return;
            }

            // åˆ¤æ–·ç¯€é»é¡å‹
            const iKind1 = getNodeKind(node1Data);
            const iKind2 = getNodeKind(node2Data);

            // å–å¾—é è¨­ Caption å’Œ SQL
            const caption = getDefCaption(iKind1, iKind2);
            const onexec = getDefSQL(iKind1, iKind2);
            const traType = 0; // å›ºå®šç‚º 0ï¼ˆåŒæ„ï¼‰

            // console.log('é€£ç·šæ¨™é¡Œ:', caption, 'ç¯€é»é¡å‹:', iKind1, 'â†’', iKind2);

            // æ ¹æ“šç¯€é»å¯¦éš›ä½ç½®èˆ‡å°ºå¯¸è¨ˆç®—æœ€ä½³é€£æ¥é»
            const pos1 = getNodePortContext(selectedNodeIds[0], { x: node1Data.pos_x, y: node1Data.pos_y });
            const pos2 = getNodePortContext(selectedNodeIds[1], { x: node2Data.pos_x, y: node2Data.pos_y });
            const ports = getBestPorts(pos1, pos2);
            const outputClass = ports.output;
            const inputClass = ports.input;

            // console.log('é€£æ¥é»:', outputClass, 'â†’', inputClass, 'ç¯€é»ä½ç½®:', { source: pos1, target: pos2 });

            // ç”Ÿæˆå”¯ä¸€çš„ TRAID
            const traId = 'TRA' + Date.now() + '_' + Math.floor(Math.random() * 1000);

            try {
                // å‘¼å« API æ–°å¢è½‰æ›å’Œäº‹ä»¶
                const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}/transitions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        TRAID: traId,
                        SRCACT: srcActId,
                        DSTACT: dstActId,
                        CAPTION: caption,
                        TRATYPE: traType,
                        ONEXEC: onexec
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'æ–°å¢è½‰æ›å¤±æ•—');
                }

                // åœ¨å‰ç«¯å‰µå»ºé€£ç·šï¼Œä½¿ç”¨è¨ˆç®—å‡ºçš„æœ€ä½³é€£æ¥é»
                editor.addConnection(selectedNodeIds[0], selectedNodeIds[1], outputClass, inputClass);

                // å°‡è½‰æ›è³‡æ–™åŠ å…¥ currentTransitions
                currentTransitions.push({
                    traid: traId,
                    srcact: srcActId,
                    dstact: dstActId,
                    caption: caption,
                    tratype: traType
                });
                markConnectedPorts();
                ensureConnectionArrows();

                // console.log('æˆåŠŸå‰µå»ºè½‰æ›:', traId, caption);

                // æ¸…é™¤é¸æ“‡ç‹€æ…‹
                multiSelectedNodeIds.clear();
                applyMultiSelectionClasses();
            } catch (error) {
                console.error('å‰µå»ºè½‰æ›å¤±æ•—:', error);
                alert('å‰µå»ºè½‰æ›å¤±æ•—: ' + error.message);
            }
        }

        function getActivityTypeText(actType) {
            const type = Number(actType ?? 0);
            if (type === 1) return 'ç¨‹åºæ´»å‹•';
            if (type === 2) return 'å‰¯æœ¬é€šçŸ¥';
            return 'ä¸€èˆ¬æ´»å‹•';
        }

        function onActivityContentEventChanged() {
            const evtList = document.getElementById('activityContentEvtList');
            const selected = evtList.options[evtList.selectedIndex];
            document.getElementById('activityContentOnExec').value = selected ? (selected.dataset.onexec || '') : '';
        }

        async function saveActivityContent() {
            try {
                const prcId = currentPrcId;
                const actId = document.getElementById('activityContentActId').value;
                const actName = document.getElementById('activityContentActName').value;
                const descrip = document.getElementById('activityContentDescrip').value;
                const allowAdd = document.getElementById('activityContentAllowAdd').checked;
                const allowReturn = document.getElementById('activityContentAllowReject').checked;
                const allowMail = document.getElementById('activityContentIsEmail').checked;
                const recType = document.getElementById('activityContentRecType').value;
                const recParam = document.getElementById('activityContentRecParam').value;

                // æ”¶é›†æ‰€æœ‰äº‹ä»¶çš„ ONEXEC å…§å®¹
                const events = [];
                const evtList = document.getElementById('activityContentEvtList');
                const currentOnExec = document.getElementById('activityContentOnExec').value;
                const selectedIndex = evtList.selectedIndex;

                for (let i = 0; i < evtList.options.length; i++) {
                    const option = evtList.options[i];
                    const evtName = option.value;
                    // å¦‚æœæ˜¯ç•¶å‰é¸ä¸­çš„äº‹ä»¶ï¼Œå¾ textarea è®€å–æœ€æ–°å…§å®¹
                    const onExec = (i === selectedIndex) ? currentOnExec : (option.dataset.onexec || '');
                    events.push({
                        evtName: evtName,
                        onExec: onExec
                    });
                }

                const response = await fetch('/CUR/FlowDesigner?handler=SaveActivityContent', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': '@antiForgeryToken'
                    },
                    body: JSON.stringify({
                        prcId: prcId,
                        actId: actId,
                        actName: actName,
                        descrip: descrip,
                        allowAdd: allowAdd,
                        allowReturn: allowReturn,
                        allowMail: allowMail,
                        recType: recType,
                        recParam: recParam,
                        events: events
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // æ›´æ–° Drawflow ä¸­çš„ç¯€é»è³‡æ–™
                    await loadFlowChart(prcId);
                    closeActivityContentDialog();
                } else {
                    alert(result.message);
                }
            } catch (error) {
                alert('å„²å­˜æ´»å‹•å…§å®¹å¤±æ•—ï¼š' + error.message);
            }
        }

        function closeActivityContentDialog() {
            document.getElementById('activityContentDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        // ===== æ”¶ä»¶é¡å‹ç›¸é—œå‡½æ•¸ =====
        let recTypeList = []; // æ”¶ä»¶é¡å‹åˆ—è¡¨
        let currentRecTypeDefstat = ''; // ç•¶å‰æ”¶ä»¶é¡å‹çš„é è¨­è…³æœ¬

        // è¼‰å…¥æ”¶ä»¶é¡å‹åˆ—è¡¨
        async function loadRecTypes() {
            try {
                console.log('é–‹å§‹è¼‰å…¥æ”¶ä»¶é¡å‹...');
                const response = await fetch('/CUR/FlowDesigner?handler=RecTypes');
                console.log('API å›æ‡‰ç‹€æ…‹:', response.status);
                const result = await response.json();
                console.log('API å›æ‡‰çµæœ:', result);

                if (result.success) {
                    recTypeList = result.data;
                    console.log('æ”¶ä»¶é¡å‹æ•¸é‡:', recTypeList.length);
                    const recTypeSelect = document.getElementById('activityContentRecType');
                    recTypeSelect.innerHTML = '<option value="">-- è«‹é¸æ“‡ --</option>';

                    recTypeList.forEach(recType => {
                        const option = document.createElement('option');
                        option.value = recType.ACTRECTYPE || recType.actrectype;
                        option.textContent = recType.ACTRECTYPE || recType.actrectype;
                        option.dataset.defstat = recType.DEFSTAT || recType.defstat || '';
                        option.dataset.lookupsql = recType.LOOKUPSQL || recType.lookupsql || '';
                        recTypeSelect.appendChild(option);
                        console.log('å·²åŠ å…¥æ”¶ä»¶é¡å‹:', option.textContent);
                    });
                    console.log('æ”¶ä»¶é¡å‹è¼‰å…¥å®Œæˆ');
                } else {
                    console.error('API è¿”å›å¤±æ•—:', result.message);
                }
            } catch (error) {
                console.error('è¼‰å…¥æ”¶ä»¶é¡å‹å¤±æ•—:', error);
            }
        }

        // ç•¶æ”¶ä»¶é¡å‹æ”¹è®Šæ™‚
        async function onActivityRecTypeChange() {
            const recTypeSelect = document.getElementById('activityContentRecType');
            const selectedOption = recTypeSelect.options[recTypeSelect.selectedIndex];
            const recType = selectedOption.value;
            const recParamLabel = document.getElementById('activityContentRecParamLabel');
            const recParamSelect = document.getElementById('activityContentRecParam');

            if (!recType) {
                recParamLabel.style.display = 'none';
                recParamSelect.style.display = 'none';
                recParamSelect.innerHTML = '<option value="">-- è«‹é¸æ“‡ --</option>';
                return;
            }

            currentRecTypeDefstat = selectedOption.dataset.defstat || '';

            try {
                const response = await fetch(`/CUR/FlowDesigner?handler=RecTypeParams&recType=${encodeURIComponent(recType)}`);
                const result = await response.json();

                if (result.success && result.hasParams && result.data.length > 0) {
                    // æœ‰åƒæ•¸ï¼Œé¡¯ç¤ºåƒæ•¸ä¸‹æ‹‰é¸å–®
                    recParamLabel.style.display = 'inline';
                    recParamSelect.style.display = 'inline';
                    recParamSelect.innerHTML = '<option value="">-- è«‹é¸æ“‡ --</option>';

                    result.data.forEach(param => {
                        const option = document.createElement('option');
                        // åƒæ•¸çš„ç¬¬ä¸€å€‹æ¬„ä½ä½œç‚º valueï¼Œç¬¬äºŒå€‹æ¬„ä½ä½œç‚ºé¡¯ç¤ºæ–‡å­—
                        const keys = Object.keys(param);
                        option.value = param[keys[0]];
                        option.textContent = keys.length > 1 ? `${param[keys[0]]} - ${param[keys[1]]}` : param[keys[0]];
                        option.dataset.paramname = keys.length > 1 ? param[keys[1]] : param[keys[0]];
                        recParamSelect.appendChild(option);
                    });
                } else {
                    // æ²’æœ‰åƒæ•¸ï¼Œéš±è—åƒæ•¸ä¸‹æ‹‰é¸å–®ï¼Œç›´æ¥æ›´æ–°æ”¶ä»¶å‰è¡Œç‚º
                    recParamLabel.style.display = 'none';
                    recParamSelect.style.display = 'none';
                    recParamSelect.innerHTML = '<option value="">-- è«‹é¸æ“‡ --</option>';
                    updateOnExecWithRecType('', '');
                }
            } catch (error) {
                console.error('è¼‰å…¥æ”¶ä»¶åƒæ•¸å¤±æ•—:', error);
            }
        }

        // ç•¶é¸æ“‡æ”¶ä»¶åƒæ•¸æ™‚
        function onActivityRecParamChange() {
            const recParamSelect = document.getElementById('activityContentRecParam');
            const selectedOption = recParamSelect.options[recParamSelect.selectedIndex];
            const paramValue = selectedOption.value;
            const paramName = selectedOption.dataset.paramname || paramValue;

            updateOnExecWithRecType(paramValue, paramName);
        }

        // æ›´æ–°æ”¶ä»¶å‰è¡Œç‚ºçš„ ONEXEC
        function updateOnExecWithRecType(paramValue, paramName) {
            const evtList = document.getElementById('activityContentEvtList');

            // æ‰¾åˆ°ã€Œæ”¶ä»¶å‰è¡Œç‚ºã€äº‹ä»¶
            for (let i = 0; i < evtList.options.length; i++) {
                const option = evtList.options[i];
                if (option.value === 'æ”¶ä»¶å‰è¡Œç‚º') {
                    // æ›¿æ› $(PARAM) å’Œ $(PARAMNAME)
                    let onexec = currentRecTypeDefstat || '';
                    onexec = onexec.replace(/\$\(PARAM\)/g, paramValue);
                    onexec = onexec.replace(/\$\(PARAMNAME\)/g, paramName);

                    // æ›´æ–°åˆ° option çš„ dataset
                    option.dataset.onexec = onexec;

                    // å¦‚æœç•¶å‰é¸ä¸­çš„æ˜¯é€™å€‹äº‹ä»¶ï¼Œä¹Ÿæ›´æ–° textarea
                    if (evtList.selectedIndex === i) {
                        document.getElementById('activityContentOnExec').value = onexec;
                    }

                    break;
                }
            }
        }

        // ===== æœƒç°½ç›¸é—œå‡½æ•¸ =====
        let multiSignUserList = []; // æœƒç°½äººå“¡æ¸…å–®
        let currentMultiSignActId = ''; // ç•¶å‰è¨­å®šæœƒç°½çš„æ´»å‹•ä»£ç¢¼

        // é–‹å•Ÿæœƒç°½è¨­å®šå°è©±æ¡†
        async function openMultiSignDialog(actId, isReadOnly = false) {
            if (!currentPrcId || !actId) {
                alert('è«‹å…ˆé¸æ“‡ä¸€å€‹æ´»å‹•');
                return;
            }

            currentMultiSignActId = actId;

            try {
                // è¼‰å…¥æ‰€æœ‰å•Ÿç”¨çš„å“¡å·¥ï¼ˆç”¨æ–¼ä¸‹æ‹‰é¸å–®ï¼‰
                const usersResponse = await fetch('/CUR/FlowDesigner?handler=ActiveUsers');
                const usersResult = await usersResponse.json();

                if (usersResult.success) {
                    const userSelect = document.getElementById('multiSignUserSelect');
                    userSelect.innerHTML = '<option value="">-- è«‹é¸æ“‡å“¡å·¥ --</option>';
                    usersResult.data.forEach(user => {
                        const option = document.createElement('option');
                        // C# API è¿”å›çš„æ˜¯å¤§å¯«é–‹é ­ UserId, UserName
                        option.value = user.UserId || user.userId;
                        option.textContent = `${user.UserId || user.userId} - ${user.UserName || user.userName}`;
                        userSelect.appendChild(option);
                    });
                }

                // è¼‰å…¥æœƒç°½äººå“¡æ¸…å–®
                await loadMultiSignUsers(currentPrcId, actId);

                // å¾ API è¼‰å…¥æ´»å‹•è³‡æ–™ä»¥å–å¾—æ ¸å‡†çš„åŒæ„äººæ•¸
                const activityResponse = await fetch(`/api/FlowDesigner/${currentPrcId}`);
                const activityResult = await activityResponse.json();

                let multiSignAllowCount = 1; // é è¨­å€¼
                if (activityResult && activityResult.activities) {
                    const activity = activityResult.activities.find(a => a.actid === actId || a.ACTID === actId);
                    if (activity) {
                        multiSignAllowCount = Number(activity.imultisignallow || activity.iMultiSignAllow || activity.IMULTISIGNALLOW || 1);
                    }
                }
                document.getElementById('multiSignAllowCount').value = multiSignAllowCount;

                // è¨­å®šå”¯è®€æ¨¡å¼
                if (isReadOnly) {
                    document.getElementById('multiSignAllowCount').disabled = true;
                    document.getElementById('multiSignBtnAdd').disabled = true;
                    document.getElementById('multiSignBtnDelete').disabled = true;
                    document.getElementById('multiSignUserSelect').disabled = true;
                }

                document.getElementById('multiSignDialog').style.display = 'flex';
                document.getElementById('dialogOverlay').style.display = 'block';
            } catch (error) {
                alert('è¼‰å…¥æœƒç°½è¨­å®šå¤±æ•—ï¼š' + error.message);
            }
        }

        // é—œé–‰æœƒç°½è¨­å®šå°è©±æ¡†
        function closeMultiSignDialog() {
            document.getElementById('multiSignDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        // è¼‰å…¥æœƒç°½äººå“¡æ¸…å–®
        async function loadMultiSignUsers(prcId, actId) {
            try {
                const response = await fetch(`/CUR/FlowDesigner?handler=MultiSignUsers&prcId=${encodeURIComponent(prcId)}&actId=${encodeURIComponent(actId)}`);
                const result = await response.json();

                if (result.success) {
                    multiSignUserList = result.data;
                    renderMultiSignUserTable();
                } else {
                    throw new Error(result.message);
                }
            } catch (error) {
                alert('è¼‰å…¥æœƒç°½äººå“¡å¤±æ•—ï¼š' + error.message);
            }
        }

        // æ¸²æŸ“æœƒç°½äººå“¡è¡¨æ ¼
        function renderMultiSignUserTable() {
            const tbody = document.getElementById('multiSignUserTableBody');
            tbody.innerHTML = '';

            if (multiSignUserList.length === 0) {
                const tr = document.createElement('tr');
                tr.innerHTML = '<td colspan="2" style="padding:10px; text-align:center; color:#999;">å°šæœªæ–°å¢æœƒç°½äººå“¡</td>';
                tbody.appendChild(tr);
                return;
            }

            multiSignUserList.forEach((user, index) => {
                const tr = document.createElement('tr');
                tr.style.cursor = 'pointer';
                tr.dataset.index = index;
                tr.onclick = function () {
                    // ç§»é™¤å…¶ä»–è¡Œçš„é¸å–ç‹€æ…‹
                    tbody.querySelectorAll('tr').forEach(row => row.style.backgroundColor = '');
                    // è¨­å®šç•¶å‰è¡Œçš„é¸å–ç‹€æ…‹
                    this.style.backgroundColor = '#e7f3ff';
                };
                tr.innerHTML = `
                    <td style="padding:6px; border-bottom:1px solid #eee;">${user.UserId || user.userId}</td>
                    <td style="padding:6px; border-bottom:1px solid #eee;">${user.UserName || user.userName || ''}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        // æ–°å¢æœƒç°½äººå“¡
        async function addMultiSignUser() {
            const userSelect = document.getElementById('multiSignUserSelect');
            const userId = userSelect.value;

            if (!userId) {
                alert('è«‹é¸æ“‡å“¡å·¥');
                return;
            }

            try {
                const response = await fetch('/CUR/FlowDesigner?handler=AddMultiSignUser', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': '@antiForgeryToken'
                    },
                    body: JSON.stringify({
                        prcId: currentPrcId,
                        actId: currentMultiSignActId,
                        userId: userId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    await loadMultiSignUsers(currentPrcId, currentMultiSignActId);
                    userSelect.value = ''; // æ¸…ç©ºé¸æ“‡

                    // å¦‚æœæ˜¯ç¬¬ä¸€å€‹æœƒç°½äººå“¡ï¼Œè‡ªå‹•æ›´æ–° UI ç‹€æ…‹
                    if (result.isFirstUser) {
                        // æ›´æ–°ã€Œæ˜¯æœƒç°½ã€checkbox
                        const isMultiSignCheckbox = document.getElementById('activityContentIsMultiSign');
                        if (isMultiSignCheckbox) {
                            isMultiSignCheckbox.checked = true;
                        }

                        // å•Ÿç”¨æª¢è¦–æœƒç°½æŒ‰éˆ•
                        const viewBtn = document.getElementById('activityContentBtnMultiSignView');
                        if (viewBtn) {
                            viewBtn.disabled = false;
                            viewBtn.style.backgroundColor = '#17a2b8';
                            viewBtn.style.cursor = 'pointer';
                        }
                    }
                } else {
                    alert(result.message);
                }
            } catch (error) {
                alert('æ–°å¢æœƒç°½äººå“¡å¤±æ•—ï¼š' + error.message);
            }
        }

        // åˆªé™¤æœƒç°½äººå“¡
        async function deleteMultiSignUser() {
            const tbody = document.getElementById('multiSignUserTableBody');
            const selectedRow = tbody.querySelector('tr[style*="background-color"]');

            if (!selectedRow) {
                alert('è«‹å…ˆé¸æ“‡è¦åˆªé™¤çš„æœƒç°½äººå“¡');
                return;
            }

            const index = parseInt(selectedRow.dataset.index);
            const user = multiSignUserList[index];

            if (!confirm(`ç¢ºå®šè¦åˆªé™¤æœƒç°½äººå“¡ã€Œ${user.UserId || user.userId} - ${user.UserName || user.userName}ã€å—ï¼Ÿ`)) {
                return;
            }

            try {
                const response = await fetch('/CUR/FlowDesigner?handler=DeleteMultiSignUser', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': '@antiForgeryToken'
                    },
                    body: JSON.stringify({
                        prcId: currentPrcId,
                        actId: currentMultiSignActId,
                        userId: user.userId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    await loadMultiSignUsers(currentPrcId, currentMultiSignActId);
                } else {
                    alert(result.message);
                }
            } catch (error) {
                alert('åˆªé™¤æœƒç°½äººå“¡å¤±æ•—ï¼š' + error.message);
            }
        }

        // å„²å­˜æœƒç°½è¨­å®š
        async function saveMultiSignSetting() {
            const multiSignAllowCount = parseInt(document.getElementById('multiSignAllowCount').value);

            // é©—è­‰æ ¸å‡†çš„åŒæ„äººæ•¸
            if (!multiSignAllowCount || multiSignAllowCount < 1) {
                alert('æ ¸å‡†çš„åŒæ„äººæ•¸è‡³å°‘ç‚º 1');
                return;
            }

            // é©—è­‰æ˜¯å¦æœ‰æœƒç°½äººå“¡
            if (multiSignUserList.length === 0) {
                alert('è«‹è‡³å°‘æ–°å¢ä¸€ä½æœƒç°½äººå“¡');
                return;
            }

            try {
                const response = await fetch('/CUR/FlowDesigner?handler=SaveMultiSignSetting', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': '@antiForgeryToken'
                    },
                    body: JSON.stringify({
                        prcId: currentPrcId,
                        actId: currentMultiSignActId,
                        multiSignAllowCount: multiSignAllowCount
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // å•Ÿç”¨æª¢è¦–æœƒç°½æŒ‰éˆ•
                    document.getElementById('activityContentBtnMultiSignView').disabled = false;
                    document.getElementById('activityContentBtnMultiSignView').style.backgroundColor = '#17a2b8';
                    document.getElementById('activityContentBtnMultiSignView').style.cursor = 'pointer';

                    // æ›´æ–°ã€Œæ˜¯æœƒç°½ã€checkbox
                    document.getElementById('activityContentIsMultiSign').checked = true;

                    closeMultiSignDialog();
                } else {
                    alert(result.message);
                }
            } catch (error) {
                alert('å„²å­˜æœƒç°½è¨­å®šå¤±æ•—ï¼š' + error.message);
            }
        }

        // å–æ¶ˆæœƒç°½è¨­å®š
        async function cancelMultiSign() {
            // å¾æ´»å‹•å…§å®¹å°è©±æ¡†ä¸­å–å¾— actId
            const actId = document.getElementById('activityContentActId')?.value;

            if (!actId) {
                alert('ç„¡æ³•å–å¾—æ´»å‹•ä»£ç¢¼');
                return;
            }

            if (!confirm('ç¢ºå®šè¦å–æ¶ˆæœƒç°½è¨­å®šå—ï¼Ÿé€™å°‡åˆªé™¤æ‰€æœ‰æœƒç°½äººå“¡ã€‚')) {
                return;
            }

            try {
                const response = await fetch('/CUR/FlowDesigner?handler=CancelMultiSign', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': '@antiForgeryToken'
                    },
                    body: JSON.stringify({
                        prcId: currentPrcId,
                        actId: actId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // å–æ¶ˆå‹¾é¸ã€Œæ˜¯æœƒç°½ã€
                    document.getElementById('activityContentIsMultiSign').checked = false;

                    // åœç”¨æª¢è¦–æœƒç°½æŒ‰éˆ•
                    document.getElementById('activityContentBtnMultiSignView').disabled = true;
                    document.getElementById('activityContentBtnMultiSignView').style.backgroundColor = '#e9ecef';
                    document.getElementById('activityContentBtnMultiSignView').style.cursor = 'not-allowed';

                    // æ¢å¾©ã€Œå…è¨±åŠ ç°½ã€å’Œã€Œå…è¨±é€€å›ã€ç‚ºé è¨­å€¼ï¼ˆå‹¾é¸ï¼‰
                    document.getElementById('activityContentAllowAdd').checked = true;
                    document.getElementById('activityContentAllowReject').checked = true;
                } else {
                    alert(result.message);
                }
            } catch (error) {
                alert('å–æ¶ˆæœƒç°½è¨­å®šå¤±æ•—ï¼š' + error.message);
            }
        }
        // ===== æœƒç°½ç›¸é—œå‡½æ•¸çµæŸ =====

        // é¡¯ç¤ºæ´»å‹•å…§å®¹ï¼ˆå…ˆå®Œæˆé–‹å•Ÿèˆ‡è³‡æ–™é¡¯ç¤ºï¼›ç·¨è¼¯æŒ‰éˆ•å¾ŒçºŒå¯¦ä½œï¼‰
        async function showActivityProperties() {
            if (!currentPrcId) return;

            if (selectedConnection) {
                alert('ç›®å‰åƒ…æ”¯æ´æ´»å‹•å…§å®¹ï¼Œè«‹å…ˆé¸æ“‡ä¸€å€‹æ´»å‹•ç¯€é»');
                return;
            }

            const selectedNodeIds = getSelectedNodeIds();
            if (selectedNodeIds.length !== 1) {
                alert('è«‹å…ˆé¸æ“‡æ°å¥½ 1 å€‹æ´»å‹•ç¯€é»');
                return;
            }

            const selectedNodeId = selectedNodeIds[0];
            const selectedNode = editor.getNodeFromId(Number(selectedNodeId));
            const selectedActId = (selectedNode?.data?.actid || '').trim();
            if (!selectedActId) {
                alert('æ‰¾ä¸åˆ°é¸ä¸­æ´»å‹•è³‡æ–™');
                return;
            }

            try {
                let detail = currentFlowDetail;
                if (!detail || !detail.flow) {
                    const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}`);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || errorData.message || 'è¼‰å…¥æ´»å‹•å…§å®¹å¤±æ•—');
                    }
                    detail = await response.json();
                    currentFlowDetail = detail;
                }

                const activities = detail.activities || [];
                const events = detail.events || [];
                const activity = activities.find(a => {
                    const actId = (a.actid || a.ACTID || '').trim();
                    return actId.toLowerCase() === selectedActId.toLowerCase();
                }) || {};

                const actName = activity.actname || activity.ACTNAME || selectedNode?.name || selectedActId;
                const actType = activity.acttype ?? activity.ACTTYPE ?? selectedNode?.data?.acttype ?? 0;
                const descrip = activity.descrip || activity.DESCRIP || '';
                const recType = activity.rectype || activity.RECTYPE || '';
                const recParam = activity.recparam || activity.RECPARAM || '';
                const allowAdd = Number(activity.allowadd ?? activity.ALLOWADD ?? 0) === 1;
                const allowReject = Number(activity.allowreturn ?? activity.ALLOWRETURN ?? 0) === 1;
                const isMultiSign = Number(activity.iMultiSign ?? activity.imultisign ?? activity.IMULTISIGN ?? 0) === 1;
                const isEmail = Number(activity.allowmail ?? activity.ALLOWMAIL ?? 0) === 1;

                document.getElementById('activityContentActId').value = selectedActId;
                document.getElementById('activityContentActName').value = actName;
                document.getElementById('activityContentDescrip').value = descrip;
                document.getElementById('activityContentAllowAdd').checked = allowAdd;
                document.getElementById('activityContentAllowReject').checked = allowReject;
                document.getElementById('activityContentIsMultiSign').checked = isMultiSign;
                document.getElementById('activityContentIsEmail').checked = isEmail;

                const evtList = document.getElementById('activityContentEvtList');
                evtList.innerHTML = '';
                const actEvents = events.filter(evt => {
                    const relateId = (evt.relateid ?? evt.RELATEID ?? '').trim();
                    return relateId.toLowerCase() === selectedActId.toLowerCase();
                });

                actEvents.forEach(evt => {
                    const evtName = evt.evtname || evt.EVTNAME || '';
                    const option = document.createElement('option');
                    option.value = evtName;
                    option.textContent = evtName;
                    option.dataset.onexec = evt.onexec || evt.ONEXEC || '';
                    evtList.appendChild(option);
                });

                if (evtList.options.length > 0) {
                    evtList.selectedIndex = 0;
                    onActivityContentEventChanged();
                } else {
                    document.getElementById('activityContentOnExec').value = '';
                }

                // æœƒç°½æŒ‰éˆ•æ§åˆ¶
                const isFlowEnabled = @isReadOnly.ToLower();
                const isMultiSignEnabled = isMultiSign;

                // æ ¹æ“šæµç¨‹æ˜¯å¦å·²å•Ÿç”¨ä¾†æ±ºå®šæ˜¯å¦å¯ç·¨è¼¯
                document.getElementById('activityContentActName').readOnly = isFlowEnabled;
                document.getElementById('activityContentDescrip').readOnly = isFlowEnabled;
                document.getElementById('activityContentOnExec').readOnly = isFlowEnabled;
                document.getElementById('activityContentAllowAdd').disabled = isFlowEnabled;
                document.getElementById('activityContentAllowReject').disabled = isFlowEnabled;
                document.getElementById('activityContentIsMultiSign').disabled = isFlowEnabled;
                document.getElementById('activityContentIsEmail').disabled = isFlowEnabled;

                // æ ¹æ“šæµç¨‹ç‹€æ…‹æ§åˆ¶ç¢ºå®šæŒ‰éˆ•
                document.getElementById('activityContentBtnSave').disabled = isFlowEnabled;
                document.getElementById('activityContentBtnSave').style.backgroundColor = isFlowEnabled ? '#e9ecef' : '#28a745';
                document.getElementById('activityContentBtnSave').style.cursor = isFlowEnabled ? 'not-allowed' : 'pointer';

                // æ ¹æ“šæµç¨‹ç‹€æ…‹æ§åˆ¶æ’å…¥åƒæ•¸æŒ‰éˆ•
                document.getElementById('activityContentBtnInsertVar').disabled = isFlowEnabled;
                document.getElementById('activityContentBtnInsertVar').style.backgroundColor = isFlowEnabled ? '#e9ecef' : '#17a2b8';
                document.getElementById('activityContentBtnInsertVar').style.cursor = isFlowEnabled ? 'not-allowed' : 'pointer';

                // æ ¹æ“šæµç¨‹ç‹€æ…‹æ§åˆ¶æ’å…¥å‡½å¼æŒ‰éˆ•
                document.getElementById('activityContentBtnInsertFunc').disabled = isFlowEnabled;
                document.getElementById('activityContentBtnInsertFunc').style.backgroundColor = isFlowEnabled ? '#e9ecef' : '#17a2b8';
                document.getElementById('activityContentBtnInsertFunc').style.cursor = isFlowEnabled ? 'not-allowed' : 'pointer';

                if (isFlowEnabled) {
                    // æµç¨‹å·²å•Ÿç”¨ï¼šåƒ…é–‹æ”¾ã€Œæª¢è¦–æœƒç°½ã€
                    document.getElementById('activityContentBtnMultiSign').disabled = true;
                    document.getElementById('activityContentBtnMultiSignCancel').disabled = true;

                    if (isMultiSignEnabled) {
                        // å·²è¨­å®šæœƒç°½ï¼šå•Ÿç”¨ã€Œæª¢è¦–æœƒç°½ã€
                        document.getElementById('activityContentBtnMultiSignView').disabled = false;
                        document.getElementById('activityContentBtnMultiSignView').style.backgroundColor = '#17a2b8';
                        document.getElementById('activityContentBtnMultiSignView').style.cursor = 'pointer';
                    } else {
                        // æœªè¨­å®šæœƒç°½ï¼šåœç”¨ã€Œæª¢è¦–æœƒç°½ã€
                        document.getElementById('activityContentBtnMultiSignView').disabled = true;
                        document.getElementById('activityContentBtnMultiSignView').style.backgroundColor = '#e9ecef';
                        document.getElementById('activityContentBtnMultiSignView').style.cursor = 'not-allowed';
                    }
                } else {
                    // æµç¨‹æœªå•Ÿç”¨ï¼šé–‹æ”¾ã€Œè¨­å®šæœƒç°½ã€ã€Œå–æ¶ˆæœƒç°½ã€ï¼Œæ¢ä»¶æ€§é–‹æ”¾ã€Œæª¢è¦–æœƒç°½ã€
                    document.getElementById('activityContentBtnMultiSign').disabled = false;
                    document.getElementById('activityContentBtnMultiSign').style.backgroundColor = '#28a745';
                    document.getElementById('activityContentBtnMultiSign').style.cursor = 'pointer';

                    document.getElementById('activityContentBtnMultiSignCancel').disabled = false;
                    document.getElementById('activityContentBtnMultiSignCancel').style.backgroundColor = '#dc3545';
                    document.getElementById('activityContentBtnMultiSignCancel').style.cursor = 'pointer';

                    if (isMultiSignEnabled) {
                        // å·²è¨­å®šæœƒç°½ï¼šå•Ÿç”¨ã€Œæª¢è¦–æœƒç°½ã€
                        document.getElementById('activityContentBtnMultiSignView').disabled = false;
                        document.getElementById('activityContentBtnMultiSignView').style.backgroundColor = '#17a2b8';
                        document.getElementById('activityContentBtnMultiSignView').style.cursor = 'pointer';
                    } else {
                        // æœªè¨­å®šæœƒç°½ï¼šåœç”¨ã€Œæª¢è¦–æœƒç°½ã€
                        document.getElementById('activityContentBtnMultiSignView').disabled = true;
                        document.getElementById('activityContentBtnMultiSignView').style.backgroundColor = '#e9ecef';
                        document.getElementById('activityContentBtnMultiSignView').style.cursor = 'not-allowed';
                    }
                }

                // è¼‰å…¥æ”¶ä»¶é¡å‹åˆ—è¡¨ä¸¦è¨­å®šé è¨­å€¼
                await loadRecTypes();
                if (recType) {
                    document.getElementById('activityContentRecType').value = recType;
                    await onActivityRecTypeChange();
                    if (recParam) {
                        document.getElementById('activityContentRecParam').value = recParam;
                    }
                }

                document.getElementById('activityContentDialog').style.display = 'block';
                document.getElementById('dialogOverlay').style.display = 'block';
            } catch (error) {
                console.error('é–‹å•Ÿæ´»å‹•å…§å®¹å¤±æ•—:', error);
                alert('é–‹å•Ÿæ´»å‹•å…§å®¹å¤±æ•—: ' + error.message);
            }
        }

        // æ‹–æ”¾åŠŸèƒ½
        function dragNode(event, nodeType) {
            event.dataTransfer.setData('nodeType', nodeType);
        }

        function allowDrop(event) {
            event.preventDefault();
        }

        async function dropNode(event) {
            event.preventDefault();
            if (isReadOnly) {
                alert('å·²å•Ÿç”¨çš„æµç¨‹ç„¡æ³•ä¿®æ”¹');
                return;
            }

            if (!currentPrcId) {
                alert('è«‹å…ˆé–‹å•Ÿæˆ–å»ºç«‹æµç¨‹');
                return;
            }

            const nodeType = event.dataTransfer.getData('nodeType');
            const container = document.getElementById('drawflow');
            const rect = container.getBoundingClientRect();

            // è¨ˆç®—ç›¸å°æ–¼ç•«å¸ƒçš„åº§æ¨™ï¼ˆè€ƒæ…®ç¸®æ”¾å’Œå¹³ç§»ï¼‰
            const zoom = editor.zoom || 1;
            const canvasX = editor.canvas_x || 0;
            const canvasY = editor.canvas_y || 0;
            const x = Math.round((event.clientX - rect.left - canvasX) / zoom);
            const y = Math.round((event.clientY - rect.top - canvasY) / zoom);

            // æ ¹æ“šç¯€é»é¡å‹ç”¢ç”Ÿé è¨­åç¨±å’Œé¡å‹
            let nodeBaseName = '';
            let actType = 0;
            switch (nodeType) {
                case 'activity':
                    nodeBaseName = 'ä¸€èˆ¬æ´»å‹•';
                    actType = 0;
                    break;
                case 'notify':
                    nodeBaseName = 'å‰¯æœ¬é€šçŸ¥';
                    actType = 2;
                    break;
                case 'proc':
                    nodeBaseName = 'ç¨‹åºæ´»å‹•';
                    actType = 1;
                    break;
            }

            // è¨ˆç®—è‡ªå‹•åºè™Ÿï¼ˆå¾ç¾æœ‰ç¯€é»ä¸­æ‰¾å‡ºæœ€å¤§åºè™Ÿï¼‰
            let maxNum = 0;
            const flowData = editor.export();
            const moduleData = flowData.drawflow?.Home?.data || {};
            for (const nodeId in moduleData) {
                const node = moduleData[nodeId];
                const name = node.name || '';
                // æª¢æŸ¥æ˜¯å¦ç¬¦åˆã€Œç¯€é»åç¨±+æ•¸å­—ã€æ ¼å¼
                const match = name.match(new RegExp(`^${nodeBaseName}(\\d+)$`));
                if (match) {
                    const num = parseInt(match[1]);
                    if (num > maxNum) maxNum = num;
                }
            }
            const nodeName = `${nodeBaseName}${maxNum + 1}`;

            // ç”Ÿæˆå”¯ä¸€çš„ ACTIDï¼ˆä½¿ç”¨æ™‚é–“æˆ³ + éš¨æ©Ÿæ•¸ï¼‰
            const actId = 'ACT' + Date.now() + '_' + Math.floor(Math.random() * 1000);

            try {
                // å…ˆåœ¨è³‡æ–™åº«ä¸­å»ºç«‹æ´»å‹•è¨˜éŒ„
                const response = await fetch(`/api/FlowDesigner/${encodeURIComponent(currentPrcId)}/activities`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ACTID: actId,
                        PRCID: currentPrcId,
                        ACTNAME: nodeName,
                        X: x,
                        Y: y,
                        ACTTYPE: actType
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'æ–°å¢æ´»å‹•å¤±æ•—');
                }

                // è³‡æ–™åº«å„²å­˜æˆåŠŸå¾Œï¼Œåœ¨å‰ç«¯æ–°å¢ç¯€é»
                const visual = getNodeVisualConfig(actId, nodeName, actType);
                const nodeId = editor.addNode(
                    nodeName,
                    4,  // è¼¸å…¥æ•¸é‡ (input_1=ä¸Š, input_2=å³, input_3=ä¸‹, input_4=å·¦)
                    4,  // è¼¸å‡ºæ•¸é‡ (output_1=ä¸Š, output_2=å³, output_3=ä¸‹, output_4=å·¦)
                    x,
                    y,
                    visual.nodeClass,
                    { type: nodeType, actid: actId, acttype: actType },
                    visual.html
                );

                // æ›´æ–°æ˜ å°„
                currentActIdToNodeIdMap[actId] = nodeId;

                // console.log('æˆåŠŸæ–°å¢æ´»å‹•:', actId, nodeName);
            } catch (error) {
                console.error('æ–°å¢æ´»å‹•å¤±æ•—:', error);
                alert('æ–°å¢æ´»å‹•å¤±æ•—: ' + error.message);
            }
        }

        // å°è©±æ¡†æ§åˆ¶
        function showNewFlowDialog() {
            document.getElementById('newFlowDialog').style.display = 'block';
            document.getElementById('dialogOverlay').style.display = 'block';
        }

        function closeNewFlowDialog() {
            document.getElementById('newFlowDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        let selectedFlowRow = null;
        let selectedPrcId = null;

        async function showOpenFlowDialog() {
            document.getElementById('openFlowDialog').style.display = 'flex';
            document.getElementById('dialogOverlay').style.display = 'block';

            // è¼‰å…¥æµç¨‹åˆ—è¡¨
            await loadFlowList();
        }

        async function loadFlowList() {
            try {
                const response = await fetch('/api/FlowDesigner');
                if (!response.ok) throw new Error('è¼‰å…¥æµç¨‹åˆ—è¡¨å¤±æ•—');

                const flows = await response.json();
                const tbody = document.getElementById('flowListBody');
                tbody.innerHTML = '';

                flows.forEach(flow => {
                    const tr = document.createElement('tr');
                    tr.style.cursor = 'pointer';
                    tr.style.borderBottom = '1px solid #eee';

                    // ç¢ºä¿æ­£ç¢ºå–å¾—æµç¨‹ ID
                    const prcId = flow.PRCID || flow.prcid || '';
                    tr.dataset.prcid = prcId;

                    // é»æ“Šè¡Œé¸æ“‡æµç¨‹
                    tr.onclick = function() {
                        if (selectedFlowRow) {
                            selectedFlowRow.style.backgroundColor = '';
                        }
                        tr.style.backgroundColor = '#e7f1fd';
                        selectedFlowRow = tr;
                        selectedPrcId = prcId;  // ç›´æ¥ä½¿ç”¨è®Šæ•¸è€Œä¸æ˜¯ dataset
                    };

                    // é›™æ“Šç›´æ¥é–‹å•Ÿ
                    tr.ondblclick = function() {
                        window.location.href = `?prcId=${encodeURIComponent(prcId)}`;
                    };

                    // Hover æ•ˆæœ
                    tr.onmouseenter = function() {
                        if (tr !== selectedFlowRow) {
                            tr.style.backgroundColor = '#f8f9fa';
                        }
                    };
                    tr.onmouseleave = function() {
                        if (tr !== selectedFlowRow) {
                            tr.style.backgroundColor = '';
                        }
                    };

                    const finished = flow.Finished === 1 || flow.finished === 1;
                    const cdate = flow.CDATE || flow.cdate;
                    const formattedDate = cdate ? new Date(cdate).toLocaleString('zh-TW', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    }) : '';

                    // ä½¿ç”¨ textContent é¿å… HTML å¯¦é«”ç·¨ç¢¼å•é¡Œ
                    const td1 = document.createElement('td');
                    td1.style.cssText = 'padding:8px; border-right:1px solid #eee; text-align:center;';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = finished;
                    checkbox.disabled = true;
                    checkbox.style.pointerEvents = 'none';
                    td1.appendChild(checkbox);

                    const td2 = document.createElement('td');
                    td2.style.cssText = 'padding:8px; border-right:1px solid #eee; font-family:Consolas,monospace; font-weight:500;';
                    td2.textContent = prcId;

                    const td3 = document.createElement('td');
                    td3.style.cssText = 'padding:8px; border-right:1px solid #eee;';
                    td3.textContent = flow.PRCNAME || flow.prcname || '';

                    const td4 = document.createElement('td');
                    td4.style.cssText = 'padding:8px; border-right:1px solid #eee;';
                    td4.textContent = flow.CREATOR || flow.creator || '';

                    const td5 = document.createElement('td');
                    td5.style.cssText = 'padding:8px; border-right:1px solid #eee;';
                    td5.textContent = flow.MODIFICATOR || flow.modificator || '';

                    const td6 = document.createElement('td');
                    td6.style.cssText = 'padding:8px; border-right:1px solid #eee;';
                    td6.textContent = formattedDate;

                    const td7 = document.createElement('td');
                    td7.style.cssText = 'padding:8px;';
                    td7.textContent = flow.DESCRIP || flow.descrip || '';

                    tr.appendChild(td1);
                    tr.appendChild(td2);
                    tr.appendChild(td3);
                    tr.appendChild(td4);
                    tr.appendChild(td5);
                    tr.appendChild(td6);
                    tr.appendChild(td7);

                    tbody.appendChild(tr);
                });

            } catch (error) {
                console.error('è¼‰å…¥æµç¨‹åˆ—è¡¨å¤±æ•—:', error);
                alert('è¼‰å…¥æµç¨‹åˆ—è¡¨å¤±æ•—: ' + error.message);
            }
        }

        function closeOpenFlowDialog() {
            document.getElementById('openFlowDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
            selectedFlowRow = null;
            selectedPrcId = null;
        }

        async function showCopyFlowDialog() {
            try {
                // è¼‰å…¥æµç¨‹åˆ—è¡¨åˆ°ä¸‹æ‹‰é¸å–®
                const response = await fetch('/CUR/FlowDesigner?handler=FlowList');
                const result = await response.json();

                if (result.success) {
                    const select = document.getElementById('copySourcePrcId');
                    select.innerHTML = '<option value="">-- è«‹é¸æ“‡ä¾†æºæµç¨‹ --</option>';

                    result.data.forEach(flow => {
                        const option = document.createElement('option');
                        option.value = flow.prcid || flow.PRCID;
                        option.textContent = `${flow.prcid || flow.PRCID} - ${flow.prcname || flow.PRCNAME}`;
                        option.dataset.prcname = flow.prcname || flow.PRCNAME;
                        option.dataset.descrip = flow.descrip || flow.DESCRIP || '';
                        select.appendChild(option);
                    });

                    // æ¸…ç©ºè¼¸å…¥æ¬„ä½
                    document.getElementById('copyTargetPrcId').value = '';
                    document.getElementById('copyTargetPrcName').value = '';
                    document.getElementById('copyTargetDescrip').value = '';

                    // é¡¯ç¤ºå°è©±æ¡†
                    document.getElementById('copyFlowDialog').style.display = 'block';
                    document.getElementById('dialogOverlay').style.display = 'block';
                }
            } catch (error) {
                console.error('è¼‰å…¥æµç¨‹åˆ—è¡¨å¤±æ•—:', error);
                alert('è¼‰å…¥æµç¨‹åˆ—è¡¨å¤±æ•—: ' + error.message);
            }
        }

        function closeCopyFlowDialog() {
            document.getElementById('copyFlowDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }

        async function executeCopyFlow() {
            const sourcePrcId = document.getElementById('copySourcePrcId').value;
            const targetPrcId = document.getElementById('copyTargetPrcId').value.trim();
            const targetPrcName = document.getElementById('copyTargetPrcName').value.trim();
            const targetDescrip = document.getElementById('copyTargetDescrip').value.trim();

            // é©—è­‰è¼¸å…¥
            if (!sourcePrcId) {
                alert('è«‹é¸æ“‡ä¾†æºæµç¨‹');
                return;
            }
            if (!targetPrcId) {
                alert('è«‹è¼¸å…¥ç›®çš„æµç¨‹ä»£ç¢¼');
                return;
            }
            if (!targetPrcName) {
                alert('è«‹è¼¸å…¥ç›®çš„æµç¨‹åç¨±');
                return;
            }

            try {
                const response = await fetch('/CUR/FlowDesigner?handler=CopyFlow', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': antiForgeryToken
                    },
                    body: JSON.stringify({
                        sourcePrcId: sourcePrcId,
                        targetPrcId: targetPrcId,
                        targetPrcName: targetPrcName,
                        targetDescrip: targetDescrip
                    })
                });

                const result = await response.json();

                if (result.success) {
                    alert('å·²å®Œæˆè¤‡è£½');
                    closeCopyFlowDialog();
                    // é‡æ–°å°å‘åˆ°æ–°è¤‡è£½çš„æµç¨‹
                    window.location.href = `?prcId=${encodeURIComponent(targetPrcId)}`;
                } else {
                    alert('è¤‡è£½å¤±æ•—: ' + result.message);
                }
            } catch (error) {
                console.error('è¤‡è£½æµç¨‹å¤±æ•—:', error);
                alert('è¤‡è£½æµç¨‹å¤±æ•—: ' + error.message);
            }
        }

        function openSelectedFlowFromTable() {
            if (!selectedPrcId) {
                alert('è«‹é¸æ“‡æµç¨‹');
                return;
            }
            window.location.href = `?prcId=${encodeURIComponent(selectedPrcId)}`;
        }

        function closeAllDialogs() {
            document.getElementById('newFlowDialog').style.display = 'none';
            document.getElementById('openFlowDialog').style.display = 'none';
            document.getElementById('copyFlowDialog').style.display = 'none';
            document.getElementById('flowContentDialog').style.display = 'none';
            document.getElementById('activityContentDialog').style.display = 'none';
            document.getElementById('insertParamDialog').style.display = 'none';
            document.getElementById('insertFuncDialog').style.display = 'none';
            document.getElementById('dialogOverlay').style.display = 'none';
        }
    </script>
}
