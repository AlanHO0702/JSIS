@model dynamic
@using PcbErpApi.Helpers
@using System.Text.Json
@using System.Globalization
@{
    // å–®é ­æ¬„ä½
    var headerFields = Model.HeaderTableFields; // å¯è¦–æ¬„ä½
    var headerData = Model.HeaderData; // å–®é ­è³‡æ–™ (Dictionary<string, object> æˆ–ä½ çš„å–®é ­Model)
    var headerFieldsList = ((IEnumerable<TableFieldViewModel>)Model.HeaderTableFields).ToList();
    var addApiUrl = ViewData["AddApiUrl"]?.ToString() ?? "";
    var detailRouteTemplate = ViewData["SubRouteTemplate"]?.ToString() ?? "";
    var tableName = ViewData["DictTableName"]?.ToString() ?? "";
    var keyFieldName = ViewData["KeyFieldName"]?.ToString() ?? "PaperNum";
    var queryRedirectUrl = ViewData["QueryRedirectUrl"]?.ToString() ?? "";
    var DeleteApiUrl = ViewData["DeleteApiUrl"]?.ToString() ?? "";
    var headerPaperNum = "";
    if (TryGetHeaderValue(headerData, "PaperNum", out var pn))
    {
        headerPaperNum = pn?.ToString() ?? "";
    }
    static int NormalizeShowWhere(int? v)
    {
        // æœ‰äº›å–®æ“šå­—å…¸çš„ iShowWhere æœƒæ˜¯ 0ï¼ˆä»£è¡¨ç¬¬ä¸€é ï¼‰ï¼Œè‹¥éæ¿¾æœƒå°è‡´å–®é ­æ•´æ®µæ¶ˆå¤±
        return (v.HasValue && v.Value > 0) ? v.Value : 1;
    }
    static bool IsNumberType(string? dt)
    {
        var t = (dt ?? "").Trim().ToLowerInvariant();
        if (string.IsNullOrEmpty(t)) return false;
        return t == "number"
            || t == "int" || t == "smallint" || t == "tinyint" || t == "bigint"
            || t.StartsWith("decimal") || t.StartsWith("numeric")
            || t.StartsWith("money") || t.StartsWith("smallmoney")
            || t.StartsWith("float") || t.StartsWith("real");
    }
    static bool TryGetHeaderValue(object? data, string? fieldName, out object? value)
    {
        value = null;
        if (data == null || string.IsNullOrWhiteSpace(fieldName)) return false;
        if (data is IDictionary<string, object> dict)
            return dict.TryGetValue(fieldName, out value);
        var prop = data.GetType().GetProperty(fieldName);
        if (prop == null) return false;
        value = prop.GetValue(data);
        return true;
    }
    static string NormalizeEditColor(string? raw)
    {
        if (string.IsNullOrWhiteSpace(raw)) return "";
        var s = raw.Trim();
        if (s.StartsWith("cl", StringComparison.OrdinalIgnoreCase))
            s = s.Substring(2);
        return s;
    }

    var groupedTabs = headerFieldsList
        .GroupBy(f => NormalizeShowWhere(f.iShowWhere))
        .OrderBy(g => g.Key)
        .ToDictionary(g => g.Key, g => g.ToList());

    var firstTabKey = groupedTabs.Keys.FirstOrDefault();
    if (firstTabKey <= 0) firstTabKey = 1;
    var lookupMap = ViewData["LookupDisplayMap"] as Dictionary<string, Dictionary<string, string>>;

    var PaperNum = headerData.ContainsKey("PaperNum") ? headerData["PaperNum"]?.ToString() ?? "" : "";

    var headerLookupMap = ViewData["HeaderLookupMap"] as Dictionary<string, string>;
    var headerLookupTypeMap = ViewData["HeaderLookupResultTypes"] as Dictionary<string, string>;
    var headerTabBaseLabel = ViewData["HeaderTableDisplayLabel"]?.ToString() ?? "åˆ†é ";

    string actionPartial = (ViewData["ActionRailPartial"] as string)
                           ?? "~/Pages/Shared/_ActionRail.Empty.cshtml";

    string? actionLogicPartial = (ViewData["ActionRailLogicPartial"] as string);
    var customButtonMeta = ViewData["CustomButtonMeta"] ?? Array.Empty<object>();

    // âœ… å–å¾—å–®é ­è¡¨åç¨±å’Œ Finished ç‹€æ…‹ï¼ˆé‡å° FmedIssueMainï¼‰
    string headerTableName = Model.HeaderTableName ?? "";
    int? finishedValue = null;
    if (headerTableName == "FMEdIssueMain" && TryGetHeaderValue(headerData, "Finished", out var finishedObj))
    {
        int finishedTemp;
        if (int.TryParse(finishedObj?.ToString(), out finishedTemp))
            finishedValue = finishedTemp;
    }
}

<script>
    // âœ… å°‡ Finished ç‹€æ…‹æš´éœ²çµ¦å‰ç«¯ JavaScript
    window._headerTableName = '@headerTableName';
    window._headerRealTableName = '@(ViewData["HeaderRealTableName"] ?? Model.HeaderTableName ?? "")';
    window._finishedStatus = @(finishedValue?.ToString() ?? "null");
    window._paperNum = '@PaperNum';
    window._customButtons = @Html.Raw(JsonSerializer.Serialize(customButtonMeta));
</script>

<div id="topToolbar" class="top-toolbar" data-dict-table="@headerTableName">
    <div class="toolbar-icon-row" role="group" aria-label="row-nav-and-sub-detail">
        <button type="button" class="btn toolbar-btn toolbar-btn-icon" id="btnFirst" title="ç¬¬ä¸€ç­†" aria-label="ç¬¬ä¸€ç­†"><i class="bi bi-chevron-bar-left"></i></button>
        <button type="button" class="btn toolbar-btn toolbar-btn-icon" id="btnPrev" title="ä¸Šä¸€ç­†" aria-label="ä¸Šä¸€ç­†"><i class="bi bi-chevron-left"></i></button>
        <button type="button" class="btn toolbar-btn toolbar-btn-icon" id="btnNext" title="ä¸‹ä¸€ç­†" aria-label="ä¸‹ä¸€ç­†"><i class="bi bi-chevron-right"></i></button>
        <button type="button" class="btn toolbar-btn toolbar-btn-icon" id="btnLast" title="æœ€å¾Œä¸€ç­†" aria-label="æœ€å¾Œä¸€ç­†"><i class="bi bi-chevron-bar-right"></i></button>
        <button type="button" class="btn toolbar-btn toolbar-btn-icon toolbar-btn-add" id="btnSubDetailAdd" title="æ–°å¢ç¬¬äºŒ/ç¬¬ä¸‰éšé …æ¬¡" aria-label="æ–°å¢ç¬¬äºŒæˆ–ç¬¬ä¸‰éšé …æ¬¡" disabled><span class="toolbar-icon">+</span></button>
        <button type="button" class="btn toolbar-btn toolbar-btn-icon toolbar-btn-del" id="btnSubDetailDelete" title="åˆªæ¸›ç¬¬äºŒ/ç¬¬ä¸‰éšé …æ¬¡" aria-label="åˆªæ¸›ç¬¬äºŒæˆ–ç¬¬ä¸‰éšé …æ¬¡" disabled><span class="toolbar-icon">-</span></button>
        <button type="submit" class="btn toolbar-btn toolbar-btn-icon toolbar-btn-add toolbar-btn-check" id="btnSaveHeader" form="orderHeaderForm" title="å„²å­˜" aria-label="å„²å­˜" disabled><span class="toolbar-icon">âœ“</span></button>
        <button type="button" class="btn toolbar-btn toolbar-btn-icon toolbar-btn-cancel toolbar-btn-check" id="btnCancelChanges" title="å–æ¶ˆè®Šæ›´" aria-label="å–æ¶ˆè®Šæ›´" disabled><span class="toolbar-icon">&times;</span></button>
    </div>
    <div class="toolbar-main">
    <div>
        @await Html.PartialAsync("_TableToolbar", new TableToolbarModel {
            SearchBtnId = "btnSubSearch",
            AddBtnId = "btnSubAddNew",
            DeleteBtnId = "btnSubBatchDelete",
            QueryFields = ViewData["QueryFields"] as List<QueryFieldViewModel> ?? new List<QueryFieldViewModel>(),
            ModalId = "searchModal",
            ReportSpName = ViewData["ReportSpName"]?.ToString() ?? ""   // ğŸ‘ˆ å¾å¤–å±¤å†å‚³é€²ä¾†
        })
    </div>
    <div class="toolbar-right">
        <div class="btn-group">
            <button id="btnToolbarActions" type="button" class="btn toolbar-btn secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                <i class="bi bi-grid-3x3-gap"></i>åŠŸèƒ½
            </button>
            <ul class="dropdown-menu">
                <li><button id="btnEditNotes" class="dropdown-item" type="button">æ”¹å‚™è¨»</button></li>
                <li><button id="btnEditMoney" class="dropdown-item" type="button">æ”¹é‡‘æµ</button></li>
            </ul>
        </div>
    </div>
    </div>
</div>

<div class="modal fade" id="editNotesMoneyModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editNotesMoneyTitle">ä¿®æ”¹</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="edit-notesmoney-actions d-none" id="editNotesMoneyActions"></div>
                <div class="edit-notesmoney-body" id="editNotesMoneyBody"></div>
                <div class="text-muted small mt-2" id="editNotesMoneyHint"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">å–æ¶ˆ</button>
                <button type="button" class="btn btn-primary" id="btnEditNotesMoneySave">å„²å­˜</button>
            </div>
        </div>
    </div>
</div>

<div class="action-rail">
    @await Html.PartialAsync(actionPartial, (object)Model)
</div>

@if (!string.IsNullOrWhiteSpace(actionLogicPartial))
{
    @await Html.PartialAsync(actionLogicPartial, (object)Model)
}

<script>
(() => {
  const withJwtHeaders = (init = {}) => {
    const jwt = localStorage.getItem('jwtId');
    const headers = Object.assign({}, init.headers || {});
    if (jwt) headers['X-JWTID'] = jwt;
    return { ...init, headers };
  };

  const escapeHtml = (v) => String(v ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\"/g, '&quot;')
    .replace(/'/g, '&#39;');

  const findHeaderFieldControl = (fieldName) => {
    const target = (fieldName || '').toLowerCase();
    if (!target) return null;
    const fields = document.querySelectorAll('form.erp-header-form input[name], form.erp-header-form textarea[name], form.erp-header-form select[name]');
    for (const el of fields) {
      const name = (el.getAttribute('name') || '').toLowerCase();
      if (name === target) return el;
    }
    const nodes = document.querySelectorAll('form.erp-header-form .draggable-field[data-field]');
    for (const node of nodes) {
      const key = (node.getAttribute('data-field') || '').toLowerCase();
      if (key !== target) continue;
      const el = node.querySelector('input, textarea, select');
      if (el) return el;
    }
    return null;
  };

  if (typeof window.safeMapLookupKey !== 'function') {
    window.safeMapLookupKey = (raw, labelToKey) => {
      if (typeof mapLookupKey === 'function') return mapLookupKey(raw, labelToKey);
      return raw ?? '';
    };
  }
  if (typeof window.getLookupLabel !== 'function') {
    window.getLookupLabel = (key, keyToLabel) => {
      if (!key || !keyToLabel) return '';
      if (keyToLabel[key] != null) return keyToLabel[key];
      const lower = (key ?? '').toString().trim().toLowerCase();
      return lower && keyToLabel[lower] != null ? keyToLabel[lower] : '';
    };
  }

  const readHeaderFieldInfo = (fieldName) => {
    const el = findHeaderFieldControl(fieldName);
    if (!el) return { value: '', isCheckbox: false };
    if (el.type === 'checkbox') return { value: el.checked ? '1' : '0', isCheckbox: true };
    if (el.classList?.contains('lookup-dropdown')) {
      const hidden = el.closest('li')?.querySelector('input.lookup-key[name]');
      if (hidden) return { value: (hidden.value ?? '').toString().trim(), isCheckbox: false };
      const raw = (el.value ?? '').toString().trim();
      const map = el._lookupLabelToKey || {};
      const mapped = window.safeMapLookupKey(raw, map);
      const fallback = raw.split(' - ')[0] || raw;
      const key = mapped && mapped !== raw ? mapped : fallback;
      return { value: (key ?? '').toString().trim(), isCheckbox: false };
    }
    return { value: (el.value ?? '').toString().trim(), isCheckbox: false };
  };

  const readHeaderValue = (fieldName) => {
    return readHeaderFieldInfo(fieldName).value;
  };
  if (!window.readHeaderValue) window.readHeaderValue = readHeaderValue;

  async function fetchHeaderRow(dictTable, paperNum) {
    const tn = cleanTableName(dictTable);
    if (!tn || !paperNum) return null;
    try {
      const url = `/api/OrderHeaderApi/GetHeaderRow?table=${encodeURIComponent(tn)}&paperNum=${encodeURIComponent(paperNum)}`;
      const res = await fetch(url, withJwtHeaders());
      if (res.ok) return await res.json();
    } catch {
      // ignore and fallback
    }
    try {
      const url = `/api/DynamicTable/ByPaperNum?table=${encodeURIComponent(tn)}&paperNum=${encodeURIComponent(paperNum)}&top=1`;
      const res = await fetch(url, withJwtHeaders());
      if (!res.ok) return null;
      const rows = await res.json();
      return (rows && rows.length) ? rows[0] : null;
    } catch {
      return null;
    }
  }

  function getRowValueCI(row, fieldName) {
    if (!row || !fieldName) return undefined;
    const key = String(fieldName).toLowerCase();
    const hit = Object.keys(row).find(k => k.toLowerCase() === key);
    return hit ? row[hit] : undefined;
  }

  function normalizeBoolValue(raw) {
    const s = (raw ?? '').toString().trim().toLowerCase();
    return s === '1' || s === 'true' || s === 'y' || s === 'yes';
  }

  function getHeaderFieldMeta(fieldName) {
    const list = (Array.isArray(PAGE?.headerFields)) ? PAGE.headerFields : [];
    const key = (fieldName || '').toString().toLowerCase();
    return list.find(f => (f?.FieldName || '').toString().toLowerCase() === key) || null;
  }

  function isDateMask(fmt) {
    const f = (fmt || '').toString().toLowerCase();
    return f.includes('yyyy') && f.includes('mm') && f.includes('dd');
  }

  function isNumberMask(fmt) {
    const f = (fmt || '').toString().toLowerCase();
    if (!f) return false;
    if (isDateMask(f)) return false;
    return /[0#]/.test(f);
  }

  function parseDecimalsFromFormat(fmt) {
    const s = (fmt || '').toString();
    const dot = s.lastIndexOf('.');
    if (dot < 0) return null;
    const tail = s.slice(dot + 1);
    const min = (tail.match(/0/g) || []).length;
    const max = min + (tail.match(/#/g) || []).length;
    if (max === 0) return null;
    return { min, max };
  }

  function isNumberDataType(dt) {
    const t = (dt || '').toString().trim().toLowerCase();
    if (!t) return false;
    return t === 'number'
      || t === 'int' || t === 'smallint' || t === 'tinyint' || t === 'bigint'
      || t.startsWith('decimal') || t.startsWith('numeric')
      || t.startsWith('money') || t.startsWith('smallmoney')
      || t.startsWith('float') || t.startsWith('real');
  }

  function formatNumberByMask(value, mask) {
    const n = Number(String(value ?? '').replace(/,/g, ''));
    if (!Number.isFinite(n)) return value == null ? '' : String(value);
    const decimals = parseDecimalsFromFormat(mask);
    if (decimals) {
      return n.toLocaleString(undefined, {
        minimumFractionDigits: decimals.min,
        maximumFractionDigits: decimals.max
      });
    }
    return n.toLocaleString();
  }

  function formatHeaderValue(raw, meta) {
    if (raw == null) return '';
    const text = String(raw);
    const dt = (meta?.DataType || '').toString().toLowerCase();
    const fmt = (meta?.FormatStr || '').toString();
    if (dt.includes('date') || isDateMask(fmt)) return formatDateByMask(text, fmt);
    if (isNumberDataType(dt) || isNumberMask(fmt)) return formatNumberByMask(text, fmt);
    return text;
  }

  function applyHeaderRow(row) {
    if (!row) return false;

    // Update inputs with name attribute (skip hidden checkbox defaults)
    document.querySelectorAll('.erp-header-form input[name], .erp-header-form textarea[name], .erp-header-form select[name]')
      .forEach(el => {
        if (el.closest('.modal')) return;
        if (el instanceof HTMLInputElement && el.type === 'hidden' && !el.classList.contains('lookup-key')) return;
        if (el.classList?.contains('lookup-dropdown')) return;
        const fieldName = el.name;
        if (!fieldName) return;
        const raw = getRowValueCI(row, fieldName);
        if (raw === undefined) return;
        const meta = getHeaderFieldMeta(fieldName);
        if (el instanceof HTMLSelectElement) {
          const v = raw == null ? '' : String(raw);
          el.value = v;
          el.dataset.init = v;
          syncLookupLabel(el);
          return;
        }
        if (el.type === 'checkbox') {
          const checked = normalizeBoolValue(raw);
          el.checked = checked;
          el.dataset.init = checked ? '1' : '0';
          return;
        }
        const value = formatHeaderValue(raw, meta);
        el.value = value ?? '';
        el.dataset.init = value ?? '';
        if (el.matches('.lookup-dropdown')) syncLookupLabel(el);
      });

    // Update lookup inputs (text + hidden key)
    document.querySelectorAll('.erp-header-form .lookup-dropdown[data-field]').forEach(input => {
      if (input.closest('.modal')) return;
      const field = input.dataset.field || '';
      if (!field) return;
      const raw = getRowValueCI(row, field);
      if (raw === undefined) return;
      const value = raw == null ? '' : String(raw);
      input.value = value;
      input.dataset.selected = value;
      const hidden = input.closest('li')?.querySelector('input.lookup-key[name]');
      if (hidden) {
        hidden.value = value;
        hidden.dataset.init = value;
      }
      // Reload lookup options so display shows "code - name" after refresh.
      const keyToLabel = input._lookupKeyToLabel || {};
      const label = getLookupLabel(value, keyToLabel);
      if (label) {
        input.value = formatLookupDisplay(value, label);
        syncLookupLabel(input);
      } else {
        delete input.dataset.lookupLoaded;
        delete input.dataset.lookupCondKey;
        if (typeof loadLookupOptions === 'function') loadLookupOptions(input);
      }
    });

    // Update date picker inputs
    document.querySelectorAll('.erp-header-form .date-dropdown').forEach(textInput => {
      if (textInput.closest('.modal')) return;
      const name = textInput.getAttribute('name') || '';
      if (!name) return;
      const raw = getRowValueCI(row, name);
      if (raw === undefined) return;
      const meta = getHeaderFieldMeta(name);
      const display = formatHeaderValue(raw, meta);
      textInput.value = display ?? '';
      textInput.dataset.init = display ?? '';
      const dateInput = textInput.parentElement?.querySelector('.date-picker-input');
      if (dateInput instanceof HTMLInputElement) {
        const dt = parseDateValue(raw);
        dateInput.value = dt ? `${dt.getFullYear()}-${String(dt.getMonth() + 1).padStart(2, '0')}-${String(dt.getDate()).padStart(2, '0')}` : '';
      }
    });

    const newPaperNum = getRowValueCI(row, 'PaperNum');
    if (newPaperNum != null) {
      window._paperNum = String(newPaperNum);
      window.selectedPaperNum = String(newPaperNum);
    }
    window.__unsavedChanges = false;
    captureHeaderInitValues();
    if (typeof window.updateSaveCheckButtons === 'function') window.updateSaveCheckButtons();
    return true;
  }

  async function refreshHeaderData() {
    const headerTable = (window._headerTableName || '').toString().trim();
    const paperNum = readPaperNum();
    if (!headerTable || !paperNum) return false;
    const row = await fetchHeaderRow(headerTable, paperNum);
    return applyHeaderRow(row);
  }

  window.__refreshHeaderData = refreshHeaderData;

  const readPaperNum = () => {
    const v = (window._paperNum || '').toString().trim();
    if (v) return v;
    return readHeaderValue('PaperNum');
  };

  const readFinishedStatus = () => {
    const raw = readHeaderValue('Finished');
    if (raw) {
      const n = parseInt(raw, 10);
      return Number.isFinite(n) ? n : null;
    }
    const fallback = window._finishedStatus;
    if (fallback == null) return null;
    const n = parseInt(String(fallback), 10);
    return Number.isFinite(n) ? n : null;
  };

  const pickFieldCI = (row, keys) => {
    if (!row) return '';
    const rowKeys = Object.keys(row);
    for (const k of keys) {
      const found = rowKeys.find(rk => rk.toLowerCase() === String(k).toLowerCase());
      if (found) {
        const v = row[found];
        if (v != null) return String(v).trim();
      }
    }
    return '';
  };

  const hasFieldCI = (row, field) => {
    if (!row || !field) return false;
    const key = String(field).toLowerCase();
    return Object.keys(row).some(k => k.toLowerCase() === key);
  };

  const readSelectedDetailRow = () => {
    const activeTable = document.querySelector('.multi-tab-detail .tab-pane.show.active .erp-table');
    const table = activeTable || document.querySelector('.erp-table');
    if (!table) return null;
    let row = table.querySelector('tbody tr.row-selected');
    if (!row) {
      row = table.querySelector('tbody tr');
      if (row) {
        table.querySelectorAll('tbody tr.row-selected').forEach(tr => tr.classList.remove('row-selected'));
        row.classList.add('row-selected');
      }
    }
    if (!row) return null;
    const obj = {};
    row.querySelectorAll('input.cell-edit[data-field]').forEach(inp => {
      const f = inp.dataset.field || '';
      if (!f) return;
      obj[f] = inp.type === 'checkbox' ? (inp.checked ? '1' : '0') : (inp.value ?? '');
    });
    if (row.dataset.paperNum && obj.PaperNum === undefined) obj.PaperNum = row.dataset.paperNum;
    if (row.dataset.item && obj.Item === undefined) obj.Item = row.dataset.item;
    return obj;
  };

  const getActiveDetailDictTable = () => {
    const activeContainer = document.querySelector('.multi-tab-detail .tab-pane.show.active .table-container');
    const dict = activeContainer?.dataset?.dictTable;
    if (dict) return dict;
    const wrapper = document.querySelector('.erp-table-wrapper');
    return wrapper?.dataset?.dictTable || '';
  };

  const fetchDetailRowFull = async (paperNum, item) => {
    const table = getActiveDetailDictTable();
    if (!table || !paperNum || item == null) return null;
    const qs = new URLSearchParams({
      table,
      paperNum: String(paperNum)
    });
    const resp = await fetch(`/api/DynamicTable/ByPaperNum?${qs.toString()}`, withJwtHeaders());
    if (!resp.ok) return null;
    const rows = await resp.json();
    if (!Array.isArray(rows)) return null;
    const targetItem = String(item).trim();
    return rows.find(r => String(pickFieldCI(r, ['Item']) ?? '').trim() === targetItem) || null;
  };

  const linkTraceState = {
    modalEl: null,
    fromTable: null,
    toTable: null,
    fromDict: null,
    toDict: null,
    baseParams: null,
    fromRows: [],
    toRows: [],
    selectedFromIdx: -1,
    selectedToIdx: -1
  };

  const updateLogState = {
    modalEl: null,
    masterTable: null,
    historyTable: null,
    diffEl: null,
    masterDict: null,
    historyDict: null,
    masterRows: [],
    historyRows: [],
    selectedMasterIdx: -1
  };

  const ensureLinkTraceModal = () => {
    if (linkTraceState.modalEl) return linkTraceState.modalEl;
    let modalEl = document.getElementById('linkTraceModal');
    if (!modalEl) {
      modalEl = document.createElement('div');
      modalEl.className = 'modal fade';
      modalEl.id = 'linkTraceModal';
      modalEl.tabIndex = -1;
      modalEl.setAttribute('aria-hidden', 'true');
      modalEl.innerHTML = `
        <div class="modal-dialog modal-xl link-trace-dialog">
          <div class="modal-content link-trace-modal">
            <div class="modal-header">
              <h5 class="modal-title">å–®æ“šè¿½è¹¤</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <div class="d-flex align-items-center gap-2 mb-2">
                <button type="button" class="btn btn-sm btn-outline-secondary lt-refresh">é‡å–</button>
                <button type="button" class="btn btn-sm btn-outline-primary lt-open">é–‹å•Ÿ</button>
              </div>
              <div class="lt-grid">
                <div class="lt-pane">
                  <div class="lt-title">
                    <span>ä¾†æºå–®æ“š</span>
                    <button type="button" class="btn btn-sm btn-outline-secondary lt-dict" data-dict-table="CURdOCXLinkPaperGetByDtl">æ¬„ä½èªªæ˜</button>
                  </div>
                  <div class="table-responsive lt-scroll">
                    <table class="table table-sm table-bordered mb-0 lt-from">
                      <thead></thead>
                      <tbody></tbody>
                    </table>
                  </div>
                </div>
                <div class="lt-pane">
                  <div class="lt-title">
                    <span>å»å‘å–®æ“š</span>
                    <button type="button" class="btn btn-sm btn-outline-secondary lt-dict" data-dict-table="CURdOCXLinkPaperGetFromTo">æ¬„ä½èªªæ˜</button>
                  </div>
                  <div class="table-responsive lt-scroll">
                    <table class="table table-sm table-bordered mb-0 lt-to">
                      <thead></thead>
                      <tbody></tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <style>
          #linkTraceModal .link-trace-dialog { --bs-modal-width: 1200px; max-width: 1200px; width: 1200px; }
          #linkTraceModal .link-trace-modal { max-width: 1200px; width: 1200px; }
          #linkTraceModal .link-trace-modal { height: calc(86vh); display: flex; flex-direction: column; }
          #linkTraceModal .modal-body { flex: 1 1 auto; min-height: 0; overflow: hidden; display: flex; flex-direction: column; }
          #linkTraceModal .lt-grid { display: flex; flex-direction: column; gap: 10px; flex: 1 1 auto; min-height: 0; }
          #linkTraceModal .lt-pane { display: flex; flex-direction: column; min-height: 0; flex: 1 1 0; }
          #linkTraceModal .lt-title { font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 4px; display: flex; align-items: center; justify-content: space-between; gap: 8px; }
          #linkTraceModal .lt-scroll { flex: 1 1 auto; min-height: 0; border: 1px solid #dee2e6; border-radius: 6px; overflow: auto; }
          #linkTraceModal table { font-size: var(--field-value-size); }
          #linkTraceModal tbody tr.lt-row-selected td { background: #fff3cd !important; }
        </style>`;
      document.body.appendChild(modalEl);
    }

    linkTraceState.modalEl = modalEl;
    linkTraceState.fromTable = modalEl.querySelector('.lt-from');
    linkTraceState.toTable = modalEl.querySelector('.lt-to');

    const refreshBtn = modalEl.querySelector('.lt-refresh');
    if (refreshBtn && !refreshBtn.__ltBound) {
      refreshBtn.__ltBound = true;
      refreshBtn.addEventListener('click', async () => {
        if (!linkTraceState.baseParams) return;
        await loadLinkFrom(linkTraceState.baseParams);
      });
    }

    const openBtn = modalEl.querySelector('.lt-open');
    if (openBtn && !openBtn.__ltBound) {
      openBtn.__ltBound = true;
      openBtn.addEventListener('click', () => {
        const row = linkTraceState.toRows[linkTraceState.selectedToIdx] || null;
        if (!row) {
          Swal.fire({ icon: 'info', title: 'è«‹å…ˆé¸å–å»å‘å–®æ“š' });
          return;
        }
        openLinkedPaper(row);
      });
    }

    const dictButtons = modalEl.querySelectorAll('.lt-dict');
    if (dictButtons.length && !modalEl.__ltDictBound) {
      modalEl.__ltDictBound = true;
      dictButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const tableName = btn.dataset.dictTable || '';
          openFieldDictModal(tableName);
        });
      });
    }

    return modalEl;
  };

  const openFieldDictModal = (tableName) => {
    const modalEl = document.getElementById('fieldDictModal');
    if (!modalEl || !tableName) return;
    const nameEl = modalEl.querySelector('#dictTableNameDisplay');
    if (nameEl) nameEl.textContent = tableName ? `- ${tableName}` : '';
    if (typeof window.initFieldDictModal === 'function') {
      window.initFieldDictModal(tableName, 'fieldDictModal');
    } else if (typeof window.loadFieldDict === 'function') {
      window.loadFieldDict(tableName);
    }
    if (window.bootstrap) {
      const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
      modal.show();
      modalEl.style.zIndex = '2000';
      const backdrops = document.querySelectorAll('.modal-backdrop');
      backdrops.forEach(b => { b.style.zIndex = '1990'; });
      const linkTraceEl = document.getElementById('linkTraceModal');
      if (linkTraceEl) linkTraceEl.style.zIndex = '1050';
    }
  };

  const ensureUpdateLogModal = () => {
    if (updateLogState.modalEl) return updateLogState.modalEl;
    let modalEl = document.getElementById('updateLogModal');
    if (!modalEl) {
      modalEl = document.createElement('div');
      modalEl.className = 'modal fade';
      modalEl.id = 'updateLogModal';
      modalEl.tabIndex = -1;
      modalEl.setAttribute('aria-hidden', 'true');
      modalEl.innerHTML = `
        <div class="modal-dialog modal-xl update-log-dialog">
          <div class="modal-content update-log-modal">
            <div class="modal-header">
              <h5 class="modal-title">ä¿®æ”¹ç´€éŒ„</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <div class="d-flex align-items-center gap-2 mb-2">
                <button type="button" class="btn btn-sm btn-outline-secondary ul-refresh">é‡å–</button>
              </div>
              <div class="ul-grid">
                <div class="ul-pane">
                  <div class="ul-title">
                    <span>æ­·å²</span>
                    <button type="button" class="btn btn-sm btn-outline-secondary ul-dict" data-dict-table="CURdTableUpdateLogHis">æ¬„ä½èªªæ˜</button>
                  </div>
                  <div class="table-responsive ul-scroll">
                    <table class="table table-sm table-bordered mb-0 ul-history">
                      <thead></thead>
                      <tbody></tbody>
                    </table>
                  </div>
                </div>
                <div class="ul-pane">
                  <div class="ul-title">
                    <span>æ˜ç´°</span>
                    <button type="button" class="btn btn-sm btn-outline-secondary ul-dict" data-dict-table="CURdTableUpdateLog">æ¬„ä½èªªæ˜</button>
                  </div>
                  <div class="table-responsive ul-scroll ul-master-wrap">
                    <table class="table table-sm table-bordered mb-0 ul-master">
                      <thead></thead>
                      <tbody></tbody>
                    </table>
                  </div>
                  <textarea class="form-control ul-diff" rows="6" readonly></textarea>
                </div>
              </div>
            </div>
          </div>
        </div>
        <style>
          #updateLogModal .update-log-dialog { --bs-modal-width: 1200px; max-width: 1200px; width: 1200px; }
          #updateLogModal .update-log-modal { max-width: 1200px; width: 1200px; }
          #updateLogModal .update-log-modal { height: calc(86vh); display: flex; flex-direction: column; }
          #updateLogModal .modal-body { flex: 1 1 auto; min-height: 0; overflow: hidden; display: flex; flex-direction: column; }
          #updateLogModal .ul-grid { display: grid; grid-template-rows: 1fr 1fr; gap: 10px; flex: 1 1 auto; min-height: 0; }
          #updateLogModal .ul-pane { display: flex; flex-direction: column; min-height: 0; }
          #updateLogModal .ul-title { font-size: 0.95rem; font-weight: 600; color: #374151; margin-bottom: 4px; display: flex; align-items: center; justify-content: space-between; gap: 8px; }
          #updateLogModal .ul-scroll { flex: 1 1 auto; min-height: 0; border: 1px solid #dee2e6; border-radius: 6px; overflow: auto; }
          #updateLogModal .ul-master-wrap { margin-bottom: 8px; }
          #updateLogModal table { font-size: var(--field-value-size); }
          #updateLogModal tbody tr.ul-row-selected td { background: #fff3cd !important; }
          #updateLogModal .ul-diff { font-size: var(--field-value-size); }
        </style>`;
      document.body.appendChild(modalEl);
    }

    updateLogState.modalEl = modalEl;
    updateLogState.masterTable = modalEl.querySelector('.ul-master');
    updateLogState.historyTable = modalEl.querySelector('.ul-history');
    updateLogState.diffEl = modalEl.querySelector('.ul-diff');

    const refreshBtn = modalEl.querySelector('.ul-refresh');
    if (refreshBtn && !refreshBtn.__ulBound) {
      refreshBtn.__ulBound = true;
      refreshBtn.addEventListener('click', async () => {
        try {
          await loadUpdateLog();
        } catch (err) {
          Swal.fire({ icon: 'error', title: 'è¼‰å…¥å¤±æ•—', text: err?.message || String(err) });
        }
      });
    }

    const dictButtons = modalEl.querySelectorAll('.ul-dict');
    if (dictButtons.length && !modalEl.__ulDictBound) {
      modalEl.__ulDictBound = true;
      dictButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const tableName = btn.dataset.dictTable || '';
          openFieldDictModal(tableName);
        });
      });
    }

    return modalEl;
  };

  const buildLogTable = (tableEl, rows, dict, onRowClick) => {
    const thead = tableEl.querySelector('thead');
    const tbody = tableEl.querySelector('tbody');
    thead.innerHTML = '';
    tbody.innerHTML = '';
    const list = Array.isArray(rows) ? rows : [];
    if (!list.length) {
      tbody.innerHTML = '<tr><td class="text-muted small">ï¼ˆç„¡è³‡æ–™ï¼‰</td></tr>';
      return;
    }
    const fallbackCols = Object.keys(list[0] || {});
    const cols = (Array.isArray(dict) && dict.length)
      ? dict
      : fallbackCols.map(k => ({ FieldName: k, DisplayLabel: k, DataType: '', FormatStr: '' }));
    thead.innerHTML = `<tr>${cols.map(c => `<th class="text-nowrap">${escapeHtml(c.DisplayLabel ?? c.FieldName)}</th>`).join('')}</tr>`;
    list.forEach((row, idx) => {
      const tr = document.createElement('tr');
      tr.dataset.idx = String(idx);
      cols.forEach(c => {
        const field = c.FieldName || '';
        const td = document.createElement('td');
        td.className = 'text-nowrap';
        td.textContent = formatLinkCellValue(row[field], c);
        tr.appendChild(td);
      });
      if (onRowClick) tr.addEventListener('click', () => onRowClick(idx, tr));
      tbody.appendChild(tr);
    });
  };

  const selectLogRow = (tableEl, idx) => {
    const tbody = tableEl.querySelector('tbody');
    if (!tbody) return;
    tbody.querySelectorAll('tr').forEach(tr => tr.classList.remove('ul-row-selected'));
    const tr = tbody.querySelector(`tr[data-idx="${idx}"]`);
    if (tr) tr.classList.add('ul-row-selected');
  };

  const updateDiffView = (row) => {
    const diff = pickFieldCI(row, ['Difference']);
    if (updateLogState.diffEl) updateLogState.diffEl.value = diff || '';
  };

  const loadUpdateLog = async () => {
    const paperNum = readPaperNum();
    if (!paperNum) {
      Swal.fire({ icon: 'error', title: 'æ²’æœ‰ä¸»æª”è³‡æ–™' });
      return;
    }
    const itemId = (window._itemId || window._singleItemId || '').toString().trim();
    const headerTable = (window._headerTableName || window._tableName || '').toString().trim();
    if (!itemId && !headerTable) {
      Swal.fire({ icon: 'error', title: 'æ‰¾ä¸åˆ°å–®æ“šé¡åˆ¥' });
      return;
    }
    const paperId = itemId || headerTable;
    const buildQs = (paperId) => new URLSearchParams({
      paperId,
      paperNum,
      userId: ''
    }).toString();

    if (!updateLogState.masterDict) {
      updateLogState.masterDict = await loadLinkDict('CURdTableUpdateLog');
    }
    if (!updateLogState.historyDict) {
      updateLogState.historyDict = await loadLinkDict('CURdTableUpdateLogHis');
    }

    const [masterResp, historyResp] = await Promise.all([
      fetch(`/api/UpdateLog/Master?${buildQs(paperId)}`, withJwtHeaders()),
      fetch(`/api/UpdateLog/History?${buildQs(paperId)}`, withJwtHeaders())
    ]);

    if (!masterResp.ok || !historyResp.ok) {
      const msg = !masterResp.ok
        ? `HTTP ${masterResp.status}`
        : `HTTP ${historyResp.status}`;
      throw new Error(msg);
    }

    const masterData = await masterResp.json();
    const historyData = await historyResp.json();

    if (masterData?.ok === false || historyData?.ok === false) {
      const msg = masterData?.error || historyData?.error || 'è¼‰å…¥å¤±æ•—';
      throw new Error(msg);
    }
    updateLogState.masterRows = Array.isArray(masterData?.rows) ? masterData.rows : [];
    updateLogState.historyRows = Array.isArray(historyData?.rows) ? historyData.rows : [];


    buildLogTable(updateLogState.historyTable, updateLogState.historyRows, updateLogState.historyDict);
    buildLogTable(updateLogState.masterTable, updateLogState.masterRows, updateLogState.masterDict, (idx) => {
      updateLogState.selectedMasterIdx = idx;
      selectLogRow(updateLogState.masterTable, idx);
      updateDiffView(updateLogState.masterRows[idx] || null);
    });

    if (updateLogState.masterRows.length) {
      updateLogState.selectedMasterIdx = 0;
      selectLogRow(updateLogState.masterTable, 0);
      updateDiffView(updateLogState.masterRows[0]);
    } else {
      updateLogState.selectedMasterIdx = -1;
      updateDiffView(null);
    }
  };

  const openUpdateLog = async () => {
    const modalEl = ensureUpdateLogModal();
    try {
      await loadUpdateLog();
    } catch (err) {
      Swal.fire({ icon: 'error', title: 'è¼‰å…¥å¤±æ•—', text: err?.message || String(err) });
      return;
    }

    if (window.bootstrap) {
      const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
      modal.show();
    }
  };

  const parseDateValue = (value) => {
    if (!value) return null;
    if (value instanceof Date && !isNaN(value)) return value;
    const s = String(value).trim();
    if (!s) return null;
    const m = s.match(/(\d{4})[/-](\d{1,2})[/-](\d{1,2})(?:[ T](\d{1,2}):(\d{1,2})(?::(\d{1,2}))?)?/);
    if (m) {
      const y = Number(m[1]);
      const mo = Number(m[2]) - 1;
      const d = Number(m[3]);
      const hh = Number(m[4] || 0);
      const nn = Number(m[5] || 0);
      const ss = Number(m[6] || 0);
      return new Date(y, mo, d, hh, nn, ss);
    }
    const dt = new Date(s);
    return isNaN(dt) ? null : dt;
  };

  const formatDateByMask = (value, mask) => {
    const dt = parseDateValue(value);
    if (!dt) return value == null ? '' : String(value);
    const fmt = (mask || '').toLowerCase();
    const y = String(dt.getFullYear());
    const m = String(dt.getMonth() + 1).padStart(2, '0');
    const d = String(dt.getDate()).padStart(2, '0');
    const hh = String(dt.getHours()).padStart(2, '0');
    const nn = String(dt.getMinutes()).padStart(2, '0');
    const ss = String(dt.getSeconds()).padStart(2, '0');
    if (!fmt) return `${y}/${m}/${d}`;
    return fmt
      .replace(/yyyy/g, y)
      .replace(/mm/g, m)
      .replace(/dd/g, d)
      .replace(/hh/g, hh)
      .replace(/nn/g, nn)
      .replace(/ss/g, ss);
  };

  const formatLinkCellValue = (raw, col) => {
    if (raw == null) return '';
    const text = String(raw);
    if (!text) return '';
    const dt = (col?.DataType || '').toString().toLowerCase();
    const fmt = (col?.FormatStr || '').toString();
    if (dt.includes('date') || (col?.FieldName || '').toString().toLowerCase().includes('date')) {
      return formatDateByMask(text, fmt);
    }
    return text;
  };

  const buildLinkTable = (tableEl, rows, dict, onRowClick) => {
    const thead = tableEl.querySelector('thead');
    const tbody = tableEl.querySelector('tbody');
    thead.innerHTML = '';
    tbody.innerHTML = '';
    const list = Array.isArray(rows) ? rows : [];
    if (!list.length) {
      tbody.innerHTML = '<tr><td class="text-muted small">ï¼ˆç„¡è³‡æ–™ï¼‰</td></tr>';
      return;
    }
    const fallbackCols = Object.keys(list[0] || {});
    const cols = (Array.isArray(dict) && dict.length)
      ? dict
      : fallbackCols.map(k => ({ FieldName: k, DisplayLabel: k, DataType: '', FormatStr: '' }));
    thead.innerHTML = `<tr>${cols.map(c => `<th class="text-nowrap">${escapeHtml(c.DisplayLabel ?? c.FieldName)}</th>`).join('')}</tr>`;
    list.forEach((row, idx) => {
      const tr = document.createElement('tr');
      tr.dataset.idx = String(idx);
      cols.forEach(c => {
        const field = c.FieldName || '';
        const td = document.createElement('td');
        td.className = 'text-nowrap';
        td.textContent = formatLinkCellValue(row[field], c);
        tr.appendChild(td);
      });
      tr.addEventListener('click', () => onRowClick(idx, tr));
      tbody.appendChild(tr);
    });
  };

  const selectLinkRow = (tableEl, idx) => {
    const tbody = tableEl.querySelector('tbody');
    if (!tbody) return;
    tbody.querySelectorAll('tr').forEach(tr => tr.classList.remove('lt-row-selected'));
    const tr = tbody.querySelector(`tr[data-idx="${idx}"]`);
    if (tr) tr.classList.add('lt-row-selected');
  };

  const fetchLinkRows = async (url, params) => {
    const qs = new URLSearchParams();
    Object.entries(params || {}).forEach(([k, v]) => {
      if (v == null || v === '') return;
      qs.append(k, String(v));
    });
    const resp = await fetch(`${url}?${qs.toString()}`, withJwtHeaders());
    const data = await resp.json();
    if (!data.ok) throw new Error(data.error || 'è¼‰å…¥å¤±æ•—');
    return data.rows || [];
  };

  const loadLinkDict = async (tableName) => {
    if (!tableName) return [];
    try {
      const res = await fetch(`/api/TableFieldLayout/DictFields?table=${encodeURIComponent(tableName)}&lang=TW`, withJwtHeaders());
      if (!res.ok) return [];
      const rows = await res.json();
      if (!Array.isArray(rows)) return [];
      return rows
        .filter(x => (x.Visible ?? x.visible) === 1 || (x.Visible ?? x.visible) === true)
        .sort((a, b) => (a.SerialNum ?? a.serialNum ?? 9999) - (b.SerialNum ?? b.serialNum ?? 9999))
        .map(x => ({
          FieldName: x.FieldName ?? x.fieldName,
          DisplayLabel: x.DisplayLabel ?? x.displayLabel ?? x.FieldName ?? x.fieldName,
          DataType: x.DataType ?? x.dataType ?? '',
          FormatStr: x.FormatStr ?? x.formatStr ?? ''
        }))
        .filter(x => x.FieldName);
    } catch {
      return [];
    }
  };

  const loadLinkTo = async (fromRow) => {
    const nowPaperId = pickFieldCI(fromRow, ['PaperId']) || linkTraceState.baseParams?.nowPaperId || '';
    const nowPaperNum = pickFieldCI(fromRow, ['PaperNum']) || linkTraceState.baseParams?.nowPaperNum || '';
    const nowItem = pickFieldCI(fromRow, ['Item']) || linkTraceState.baseParams?.nowItem || '';
    const sourPaperId = pickFieldCI(fromRow, ['SourPaperId']) || linkTraceState.baseParams?.sourPaperId || '';
    const sourNum = pickFieldCI(fromRow, ['SourNum']) || linkTraceState.baseParams?.sourNum || '';
    const sourItem = pickFieldCI(fromRow, ['SourItem']) || '';

    linkTraceState.toRows = await fetchLinkRows('/api/LinkPaper/To', {
      nowPaperId,
      nowPaperNum,
      nowItem,
      sourPaperId,
      sourNum,
      sourItem
    });
    linkTraceState.selectedToIdx = -1;
    buildLinkTable(linkTraceState.toTable, linkTraceState.toRows, linkTraceState.toDict, (idx, tr) => {
      linkTraceState.selectedToIdx = idx;
      selectLinkRow(linkTraceState.toTable, idx);
    });
    if (linkTraceState.toRows.length > 0) {
      linkTraceState.selectedToIdx = 0;
      selectLinkRow(linkTraceState.toTable, 0);
    }
  };

  const loadLinkFrom = async (params) => {
    linkTraceState.fromRows = await fetchLinkRows('/api/LinkPaper/From', params);
    linkTraceState.selectedFromIdx = -1;
    buildLinkTable(linkTraceState.fromTable, linkTraceState.fromRows, linkTraceState.fromDict, async (idx, tr) => {
      linkTraceState.selectedFromIdx = idx;
      selectLinkRow(linkTraceState.fromTable, idx);
      try {
        await loadLinkTo(linkTraceState.fromRows[idx]);
      } catch (err) {
        Swal.fire({ icon: 'error', title: 'è¼‰å…¥å¤±æ•—', text: err?.message || String(err) });
      }
    });
    if (linkTraceState.fromRows.length > 0) {
      linkTraceState.selectedFromIdx = 0;
      selectLinkRow(linkTraceState.fromTable, 0);
      await loadLinkTo(linkTraceState.fromRows[0]);
    } else {
      linkTraceState.toRows = [];
      buildLinkTable(linkTraceState.toTable, [], linkTraceState.toDict, () => {});
    }
  };

  const openLinkedPaper = (row) => {
    const itemId = pickFieldCI(row, ['ItemId', 'ItemID']);
    const paperNum = pickFieldCI(row, ['PaperNum']);
    if (!itemId || !paperNum) {
      Swal.fire({ icon: 'error', title: 'ç„¡æ³•é–‹å•Ÿå–®æ“š', text: 'ç¼ºå°‘ ItemId æˆ– PaperNum' });
      return;
    }
    const url = `/DynamicTemplate/Paper/${encodeURIComponent(itemId)}/${encodeURIComponent(paperNum)}`;
    const win = window.open(url, '_blank');
    if (win) {
      try { win.opener = null; } catch {}
    } else {
      Swal.fire({ icon: 'warning', title: 'ç€è¦½å™¨é˜»æ“‹æ–°åˆ†é ', text: 'è«‹å…è¨±å½ˆå‡ºè¦–çª—å¾Œå†è©¦ä¸€æ¬¡ã€‚' });
    }
  };

  const linkPaperTrace = async () => {
    const paperNum = readPaperNum();
    if (!paperNum) return Swal.fire({ icon: 'info', title: 'æ²’æœ‰å–®è™Ÿ' });

    const finished = readFinishedStatus();
    if (finished === 2) return Swal.fire({ icon: 'warning', title: 'æ­¤å–®æ“šå·²ä½œå»¢,ä¸å¯è¿½è¹¤' });

    let row = readSelectedDetailRow();
    if (!row) return Swal.fire({ icon: 'info', title: 'è«‹å…ˆé¸å–ä¸€ç­†æ˜ç´°' });

    let sourPaperId = pickFieldCI(row, ['SourPaperId', 'SourcePaperId', 'SourPaperID', 'SourcePaperID']);
    let sourNum = pickFieldCI(row, ['SourNum', 'SourceNum', 'SourNUM', 'SourceNUM']);
    const nowItem = pickFieldCI(row, ['Item']);
    if (!nowItem) return Swal.fire({ icon: 'warning', title: 'æ‚¨é»é¸çš„æ˜ç´°æª”æ²’æœ‰ã€ŒItemã€æ¬„ä½' });

    const hasSourPaperId = hasFieldCI(row, 'SourPaperId') || hasFieldCI(row, 'SourcePaperId');
    const hasSourNum = hasFieldCI(row, 'SourNum') || hasFieldCI(row, 'SourceNum');
    if (!hasSourPaperId || !hasSourNum) {
      const fullRow = await fetchDetailRowFull(paperNum, nowItem);
      if (fullRow) {
        row = fullRow;
        sourPaperId = pickFieldCI(fullRow, ['SourPaperId', 'SourcePaperId', 'SourPaperID', 'SourcePaperID']);
        sourNum = pickFieldCI(fullRow, ['SourNum', 'SourceNum', 'SourNUM', 'SourceNUM']);
      }
    }

    const hasSourPaperIdAfter = hasFieldCI(row, 'SourPaperId') || hasFieldCI(row, 'SourcePaperId');
    const hasSourNumAfter = hasFieldCI(row, 'SourNum') || hasFieldCI(row, 'SourceNum');
    if (!hasSourPaperIdAfter) return Swal.fire({ icon: 'warning', title: 'æ‚¨é»é¸çš„æ˜ç´°æª”æ²’æœ‰ã€ŒSourPaperIdã€æ¬„ä½' });
    if (!hasSourNumAfter) return Swal.fire({ icon: 'warning', title: 'æ‚¨é»é¸çš„æ˜ç´°æª”æ²’æœ‰ã€ŒSourNumã€æ¬„ä½' });
    const nowPaperId = (window._headerTableName || '').toString().trim();
    if (!nowPaperId) return Swal.fire({ icon: 'warning', title: 'æ²’æœ‰å–®åˆ¥' });

    if (!sourPaperId || !String(sourPaperId).trim()) {
      sourPaperId = nowPaperId;
    }
    if (!sourNum || !String(sourNum).trim()) {
      sourNum = paperNum;
    }

    const modalEl = ensureLinkTraceModal();
    linkTraceState.baseParams = {
      nowPaperId,
      nowPaperNum: paperNum,
      nowItem,
      sourPaperId,
      sourNum
    };

    try {
      if (!linkTraceState.fromDict) {
        linkTraceState.fromDict = await loadLinkDict('CURdOCXLinkPaperGetByDtl');
      }
      if (!linkTraceState.toDict) {
        linkTraceState.toDict = await loadLinkDict('CURdOCXLinkPaperGetFromTo');
      }
      await loadLinkFrom(linkTraceState.baseParams);
    } catch (err) {
      Swal.fire({ icon: 'error', title: 'è¼‰å…¥å¤±æ•—', text: err?.message || String(err) });
      return;
    }

    if (window.bootstrap) {
      const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
      modal.show();
    }
  };

  const editFieldMetaCache = new Map();
  const HEADER_KEY_FIELD = 'PaperNum';

  function cleanTableName(t) {
    return (t || '').toString().replace(/^dbo\./i, '').trim().toLowerCase();
  }

  const columnTypesCache = new Map();
  const finishedCache = new Map();

  async function fetchColumnTypes(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Set();
    if (columnTypesCache.has(tn)) return columnTypesCache.get(tn);
    try {
      const res = await fetch(`/api/TableFieldLayout/ColumnTypes?table=${encodeURIComponent(tn)}`, withJwtHeaders());
      if (!res.ok) {
        const empty = new Set();
        columnTypesCache.set(tn, empty);
        return empty;
      }
      const data = await res.json();
      const cols = new Set();
      (data?.columns || []).forEach(c => {
        const name = (c?.ColumnName || c?.columnName || '').toString().trim().toLowerCase();
        if (name) cols.add(name);
      });
      columnTypesCache.set(tn, cols);
      return cols;
    } catch {
      const empty = new Set();
      columnTypesCache.set(tn, empty);
      return empty;
    }
  }

  async function fetchFinishedMap(dictTable, paperNum) {
    const tn = cleanTableName(dictTable);
    const key = `${tn}::${paperNum || ''}`;
    if (finishedCache.has(key)) return finishedCache.get(key);
    const map = new Map();
    if (!tn || !paperNum) {
      finishedCache.set(key, map);
      return map;
    }
    try {
      const url = `/api/DynamicTable/ByPaperNum?table=${encodeURIComponent(tn)}&paperNum=${encodeURIComponent(paperNum)}`;
      const res = await fetch(url, withJwtHeaders());
      if (!res.ok) {
        finishedCache.set(key, map);
        return map;
      }
      const rows = await res.json();
      (rows || []).forEach(r => {
        const item = (r.Item ?? r.item ?? '').toString();
        const fin = r.Finished ?? r.finished;
        map.set(item, fin);
      });
      finishedCache.set(key, map);
      return map;
    } catch {
      finishedCache.set(key, map);
      return map;
    }
  }

  function getUserId() {
    return (localStorage.getItem('erpLoginUserId') || window._userId || '').toString().trim();
  }

  function getItemId() {
    return (window._itemId || window._singleItemId || '').toString().trim();
  }

  function getHeaderValueByLabel(labelText) {
    const $label = $('.header-label-item').filter(function () {
      return $(this).text().trim() === labelText;
    }).first();
    if (!$label.length) return '';
    const fieldName = $label.data('field');
    if (!fieldName) return '';
    const $li = $(`.draggable-field[data-field="${fieldName}"]`).first();
    if (!$li.length) return '';
    const $ctrl = $li.find('select, input, textarea').first();
    if (!$ctrl.length) return '';
    if ($ctrl.is('select')) return $ctrl.find('option:selected').text().trim();
    return ($ctrl.val() || '').toString().trim();
  }

  function isConfirmedPaper() {
    const finished = readFinishedStatus();
    if (finished !== null) return finished === 1;
    const status = getHeaderValueByLabel('å–®æ“šç‹€æ…‹');
    if (!status) return false;
    return status === 'å·²ç¢ºèª';
  }

  async function fetchItemAccess() {
    const userId = getUserId();
    const itemId = getItemId();
    if (!userId || !itemId) return null;
    try {
      const url = `/api/Permission/ItemAccess?userId=${encodeURIComponent(userId)}&itemId=${encodeURIComponent(itemId)}`;
      const resp = await fetch(url, withJwtHeaders());
      if (!resp.ok) return null;
      return await resp.json();
    } catch {
      return null;
    }
  }

  async function fetchFieldMeta(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return [];
    if (editFieldMetaCache.has(tn)) return editFieldMetaCache.get(tn);
    try {
      const res = await fetch(`/api/TableFieldLayout/GetTableFieldsFull?table=${encodeURIComponent(tn)}&lang=TW`, withJwtHeaders());
      if (!res.ok) {
        editFieldMetaCache.set(tn, []);
        return [];
      }
      const rows = await res.json();
      editFieldMetaCache.set(tn, rows || []);
      return rows || [];
    } catch {
      editFieldMetaCache.set(tn, []);
      return [];
    }
  }

  function pickEditFields(metaRows, mode) {
    const flagName = mode === 'money' ? 'IsMoneyField' : 'IsNotesField';
    return (metaRows || []).filter(r => {
      const raw = r?.[flagName] ?? r?.[flagName?.toLowerCase?.()] ?? r?.[flagName?.toUpperCase?.()];
      return String(raw ?? '').trim() === '1';
    }).map(r => ({
      name: (r.FieldName || r.fieldName || '').toString(),
      label: (r.DisplayLabel || r.displayLabel || r.FieldName || r.fieldName || '').toString(),
      readOnly: String(r.ReadOnly ?? r.readOnly ?? '0') === '1',
      comboStyle: Number(r.ComboStyle ?? r.comboStyle ?? 0)
    })).filter(r => r.name);
  }

  function isCheckedValue(val) {
    const s = (val ?? '').toString().trim().toLowerCase();
    return s === '1' || s === 'true' || s === 'y' || s === 'yes' || s === 'on';
  }

  function renderEditInput(tableName, rowInfo, field, value) {
    const baseAttrs = `data-table="${escapeHtml(tableName)}" data-paper-num="${escapeHtml(rowInfo.paperNum || '')}"` +
      (rowInfo.item != null ? ` data-item="${escapeHtml(rowInfo.item)}"` : '') +
      ` data-field="${escapeHtml(field.name)}"`;
    const useCheckbox = field.comboStyle === 1 || field.forceCheckbox === true;
    if (useCheckbox) {
      const checked = isCheckedValue(value) ? 'checked' : '';
      const initVal = isCheckedValue(value) ? '1' : '0';
      const disabled = field.readOnly ? 'disabled' : '';
      return `<input type="checkbox" class="form-check-input edit-notesmoney-input edit-notesmoney-checkbox"
        ${baseAttrs} data-init="${initVal}" ${checked} ${disabled}>`;
    }
    const val = value ?? '';
    const ro = field.readOnly ? 'readonly' : '';
    return `<input type="text" class="form-control form-control-sm edit-notesmoney-input"
        ${baseAttrs} data-init="${escapeHtml(val)}" value="${escapeHtml(val)}" ${ro}>`;
  }

  function collectDictTables() {
    const tables = new Map();
    const headerTable = (window._headerTableName || '').toString().trim();
    if (headerTable) tables.set(cleanTableName(headerTable), { name: headerTable, kind: 'header' });

    document.querySelectorAll('.multi-tab-detail .table-container[data-dict-table]').forEach(el => {
      const t = el.dataset.dictTable || '';
      if (!t) return;
      const key = cleanTableName(t);
      if (!tables.has(key)) tables.set(key, { name: t, kind: 'detail' });
    });

    const sub = document.getElementById('paper3l-subdetail-container');
    if (sub && sub.dataset?.dictTable) {
      const t = sub.dataset.dictTable;
      const key = cleanTableName(t);
      if (!tables.has(key)) tables.set(key, { name: t, kind: 'detail' });
    }

    return Array.from(tables.values());
  }

  function escapeSelector(s) {
    if (window.CSS && typeof window.CSS.escape === 'function') return window.CSS.escape(s);
    return (s || '').replace(/[^a-zA-Z0-9_-]/g, '\\$&');
  }

  function readDetailRows(tableName, fields) {
    const containers = Array.from(document.querySelectorAll('.multi-tab-detail .table-container[data-dict-table], #paper3l-subdetail-container'))
      .filter(el => cleanTableName(el.dataset?.dictTable) === cleanTableName(tableName));
    if (!containers.length) return [];
    const rows = [];
    containers.forEach(container => {
      const table = container.querySelector('table.erp-table');
      if (!table) return;
      table.querySelectorAll('tbody tr').forEach(tr => {
        const paperNum = tr.dataset.paperNum || readPaperNum();
        const item = tr.dataset.item || '';
        if (!paperNum || !item) return;
        const values = {};
        fields.forEach(f => {
          const sel = `.cell-edit[data-field="${escapeSelector(f.name)}"]`;
          const input = tr.querySelector(sel);
          if (!input) return;
          let val = '';
          if (input.type === 'checkbox') {
            val = input.checked ? '1' : '0';
          } else {
            val = (input.value ?? '').toString();
          }
          values[f.name] = val;
        });
        rows.push({ paperNum, item, values });
      });
    });
    return rows;
  }

  async function readHeaderFields(fields, tableName) {
    const paperNum = readPaperNum();
    const values = {};
    const checkboxMap = {};
    fields.forEach(f => {
      const info = readHeaderFieldInfo(f.name);
      values[f.name] = info.value;
      checkboxMap[f.name] = info.isCheckbox;
    });

    const row = await fetchHeaderRow(tableName, paperNum);
    if (row) {
      fields.forEach(f => {
        const rowKey = Object.keys(row || {}).find(k => k.toLowerCase() === String(f.name).toLowerCase());
        if (rowKey && row[rowKey] !== undefined && row[rowKey] !== null) {
          values[f.name] = String(row[rowKey]);
        }
      });
    }

    return { paperNum, values, checkboxMap };
  }

  async function buildHeaderBlock(tableName, fields) {
    const data = await readHeaderFields(fields, tableName);
    const rowsHtml = fields.map(f => {
      const val = data.values[f.name] ?? '';
      const fieldMeta = Object.assign({}, f, { forceCheckbox: data.checkboxMap[f.name] === true });
      return `<tr>
        <th>${escapeHtml(f.label || f.name)}</th>
        <td>
          ${renderEditInput(tableName, { paperNum: data.paperNum }, fieldMeta, val)}
        </td>
      </tr>`;
    }).join('');
    return `
<div class="edit-notesmoney-block" data-table="${escapeHtml(tableName)}" data-key-fields="${escapeHtml(HEADER_KEY_FIELD)}">
  <div class="edit-notesmoney-title">å–®é ­ï¼š${escapeHtml(tableName)}</div>
  <table class="edit-notesmoney-table">
    <thead><tr><th style="width:220px;">æ¬„ä½</th><th>å€¼</th></tr></thead>
    <tbody>${rowsHtml}</tbody>
  </table>
</div>`;
  }

  function buildDetailBlock(tableName, fields) {
    const rows = readDetailRows(tableName, fields);
    if (!rows.length) {
      return '';
    }
    const headCols = fields.map(f => `<th>${escapeHtml(f.label || f.name)}</th>`).join('');
    const bodyRows = rows.map((r, idx) => {
      const cols = fields.map(f => {
        const val = r.values[f.name] ?? '';
        return `<td>
          ${renderEditInput(tableName, { paperNum: r.paperNum, item: r.item }, f, val)}
        </td>`;
      }).join('');
      return `<tr data-paper-num="${escapeHtml(r.paperNum)}" data-item="${escapeHtml(r.item)}">
        <td>${escapeHtml(r.item || (idx + 1))}</td>${cols}
      </tr>`;
    }).join('');
    return `
<div class="edit-notesmoney-block" data-table="${escapeHtml(tableName)}" data-key-fields="PaperNum,Item">
  <div class="edit-notesmoney-title">å–®èº«ï¼š${escapeHtml(tableName)}</div>
  <table class="edit-notesmoney-table">
    <thead><tr><th style="width:80px;">é …æ¬¡</th>${headCols}</tr></thead>
    <tbody>${bodyRows}</tbody>
  </table>
</div>`;
  }

  const getUpdateMoneyButtons = () => {
    const raw = window._customButtons;
    if (!Array.isArray(raw)) return [];
    return raw.filter(b => Number(b?.IsUpdateMoney ?? b?.isUpdateMoney ?? 0) === 1);
  };

  const normalizeCustomButton = (b) => {
    const buttonName = (b?.ButtonName || b?.buttonName || '').toString().trim();
    const caption = (b?.Caption || b?.CustCaption || b?.caption || b?.custCaption || buttonName).toString().trim();
    const hint = (b?.Hint || b?.CustHint || b?.hint || b?.custHint || '').toString();
    return {
      buttonName,
      caption: caption || buttonName,
      hint,
      designType: b?.DesignType ?? b?.designType,
      searchTemplate: b?.SearchTemplate ?? b?.searchTemplate,
      spName: b?.SpName ?? b?.spName,
      execSpName: b?.ExecSpName ?? b?.execSpName,
      multiSelectDd: b?.MultiSelectDD ?? b?.multiSelectDD,
      replaceExists: b?.ReplaceExists ?? b?.replaceExists,
      dialogCaption: b?.DialogCaption ?? b?.dialogCaption,
      allowSelCount: b?.AllowSelCount ?? b?.allowSelCount
    };
  };

  const renderEditMoneyButtons = (mode) => {
    const actionsEl = document.getElementById('editNotesMoneyActions');
    if (!actionsEl) return;
    actionsEl.innerHTML = '';
    if (mode !== 'money') {
      actionsEl.classList.add('d-none');
      return;
    }

    const rows = getUpdateMoneyButtons().map(normalizeCustomButton).filter(b => b.buttonName);
    if (!rows.length) {
      actionsEl.classList.add('d-none');
      return;
    }

    actionsEl.classList.remove('d-none');
    const frag = document.createDocumentFragment();
    rows.forEach(meta => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn btn-outline-primary btn-sm edit-notesmoney-btn';
      btn.textContent = meta.caption;
      if (meta.hint) btn.title = meta.hint;
      btn.dataset.customBtn = '1';
      btn.dataset.buttonName = meta.buttonName;
      btn.dataset.designType = meta.designType ?? '';
      btn.dataset.searchTemplate = meta.searchTemplate ?? '';
      btn.dataset.spName = meta.spName ?? '';
      btn.dataset.execSpName = meta.execSpName ?? '';
      btn.dataset.multiSelectDd = meta.multiSelectDd ?? '';
      btn.dataset.replaceExists = meta.replaceExists ?? '';
      btn.dataset.dialogCaption = meta.dialogCaption ?? '';
      btn.dataset.allowSelCount = meta.allowSelCount ?? '';

      btn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (typeof window.ActionRailRunButton === 'function') {
          await window.ActionRailRunButton(btn);
          return;
        }

        const itemId = (window._itemId || window._singleItemId || '').toString();
        const ctx = {
          buttonName: meta.buttonName,
          itemId,
          paperNum: readPaperNum(),
          headerTable: (window._headerTableName || '').toString(),
          dictTableName: (window._dictTableName || '').toString(),
          caption: meta.caption
        };

        const map = window.ActionRailCustomHandlers || {};
        const handler = (map[itemId] && typeof map[itemId][meta.buttonName] === 'function')
          ? map[itemId][meta.buttonName]
          : (typeof map[meta.buttonName] === 'function' ? map[meta.buttonName] : null);
        if (handler) {
          try {
            await handler(ctx);
          } catch (err) {
            console.error("edit-money custom button handler error", err);
            alert(`åŸ·è¡Œå¤±æ•—: ${err?.message || err}`);
          }
          return;
        }

        try {
          const resp = await fetch('/api/StoredProc/execByButton', withJwtHeaders({
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              itemId: ctx.itemId,
              buttonName: ctx.buttonName,
              paperNum: ctx.paperNum
            })
          }));
          const raw = await resp.text();
          let data; try { data = JSON.parse(raw); } catch { data = { ok: false, error: raw }; }
          if (resp.ok && data.ok) {
            alert('åŸ·è¡Œå®Œæˆ');
            location.reload();
            return;
          }
          alert(`åŸ·è¡Œå¤±æ•—: ${data.error || `HTTP ${resp.status}`}`);
        } catch (err) {
          console.error("edit-money execByButton error", err);
          alert(`åŸ·è¡Œå¤±æ•—: ${err?.message || err}`);
        }
      });

      frag.appendChild(btn);
    });
    actionsEl.appendChild(frag);
  };

  async function openEditNotesMoney(mode) {
    const titleEl = document.getElementById('editNotesMoneyTitle');
    const bodyEl = document.getElementById('editNotesMoneyBody');
    const hintEl = document.getElementById('editNotesMoneyHint');
    if (!titleEl || !bodyEl || !hintEl) return;

    if (!isConfirmedPaper()) {
      Swal.fire({ icon: 'warning', title: 'åªæœ‰å·²ç¢ºèªçš„å–®æ“šæ‰å¯ä½¿ç”¨æ­¤åŠŸèƒ½' });
      return;
    }

    const perm = await fetchItemAccess();
    if (!perm) {
      Swal.fire({ icon: 'warning', title: 'ç„¡æ³•å–å¾—æ¬Šé™' });
      return;
    }

    if (mode === 'money' && Number(perm?.bUpdateMoney || 0) !== 1) {
      Swal.fire({ icon: 'warning', title: 'æ‚¨æ²’æœ‰ã€Œä¿®æ”¹é‡‘æµã€çš„æ¬Šé™' });
      return;
    }
    if (mode === 'notes' && Number(perm?.bUpdateNotes || 0) !== 1) {
      Swal.fire({ icon: 'warning', title: 'æ‚¨æ²’æœ‰ã€Œä¿®æ”¹å‚™è¨»ã€çš„æ¬Šé™' });
      return;
    }

    const tables = collectDictTables();
    const blocks = [];

    for (const t of tables) {
      const meta = await fetchFieldMeta(t.name);
      const fields = pickEditFields(meta, mode).map(f => {
        if (String(f.name).toLowerCase() === 'usetaxprice') {
          return Object.assign({}, f, { forceCheckbox: true });
        }
        return f;
      });
      if (!fields.length) continue;
      if (t.kind === 'header') {
        blocks.push(await buildHeaderBlock(t.name, fields));
      } else {
        blocks.push(buildDetailBlock(t.name, fields));
      }
    }

    if (!blocks.length) {
      Swal.fire({ icon: 'info', title: `æ­¤å–®æ“šæ²’æœ‰${mode === 'money' ? 'é‡‘æµ' : 'å‚™è¨»'}æ¬„ä½` });
      return;
    }

    titleEl.textContent = mode === 'money' ? 'ä¿®æ”¹é‡‘æµ' : 'ä¿®æ”¹å‚™è¨»';
    bodyEl.innerHTML = blocks.join('');
    renderEditMoneyButtons(mode);
    hintEl.textContent = 'åƒ…å…è¨±å·²ç¢ºèªå–®æ“šï¼Œå„²å­˜å¾Œå°‡ç›´æ¥å¯«å…¥ï¼Œä¸éœ€é€€å¯©ã€‚';

    if (window.bootstrap) {
      const modal = bootstrap.Modal.getOrCreateInstance(document.getElementById('editNotesMoneyModal'));
      modal.show();
    }
  }

  async function saveEditNotesMoney() {
    const bodyEl = document.getElementById('editNotesMoneyBody');
    if (!bodyEl) return;
    const inputs = Array.from(bodyEl.querySelectorAll('.edit-notesmoney-input'));
    const changesByTable = new Map();

    inputs.forEach(inp => {
      const table = inp.dataset.table || '';
      const field = inp.dataset.field || '';
      const paperNum = inp.dataset.paperNum || '';
      const item = inp.dataset.item || '';
      const init = inp.dataset.init ?? '';
      let val = '';
      if (inp.type === 'checkbox') {
        val = inp.checked ? '1' : '0';
      } else {
        val = (inp.value ?? '').toString();
      }
      if (!table || !field) return;
      if (val === init) return;

      if (!changesByTable.has(table)) {
        changesByTable.set(table, new Map());
      }
      const rowKey = `${paperNum}::${item}`;
      const rowMap = changesByTable.get(table);
      if (!rowMap.has(rowKey)) {
        const rowObj = {};
        if (paperNum) rowObj.PaperNum = paperNum;
        if (item) rowObj.Item = Number.isNaN(Number(item)) ? item : Number(item);
        rowMap.set(rowKey, rowObj);
      }
      const rowObj = rowMap.get(rowKey);
      rowObj[field] = val;
    });

    if (changesByTable.size === 0) {
      Swal.fire({ icon: 'info', title: 'æ²’æœ‰è³‡æ–™ç•°å‹•' });
      return;
    }

    const currentPaperNum = readPaperNum();
    const finishedTables = new Map();
    for (const table of changesByTable.keys()) {
      const cols = await fetchColumnTypes(table);
      if (cols.has('finished')) {
        const map = await fetchFinishedMap(table, currentPaperNum);
        finishedTables.set(table, map);
      }
    }

    for (const [table, rowMap] of changesByTable.entries()) {
      const finMap = finishedTables.get(table);
      if (!finMap) continue;
      const fallback = finMap.size ? Array.from(finMap.values())[0] : 0;
      for (const rowObj of rowMap.values()) {
        if (rowObj.Finished !== undefined) continue;
        const itemKey = rowObj.Item != null ? String(rowObj.Item) : '';
        const finVal = finMap.has(itemKey) ? finMap.get(itemKey) : (finMap.has('') ? finMap.get('') : fallback);
        rowObj.Finished = finVal ?? 0;
      }
    }

    const saveBtn = document.getElementById('btnEditNotesMoneySave');
    if (saveBtn) saveBtn.disabled = true;

    try {
      for (const [table, rowMap] of changesByTable.entries()) {
        const rows = Array.from(rowMap.values());
        const keyFields = rows.some(r => r.Item !== undefined) ? ['PaperNum', 'Item'] : [HEADER_KEY_FIELD];
        const payload = { TableName: table, Data: rows, KeyFields: keyFields };
        const resp = await fetch('/api/CommonTable/SaveTableChanges', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) {
          const msg = await resp.text();
          throw new Error(msg || 'å„²å­˜å¤±æ•—');
        }
      }
      if (window.bootstrap) {
        const modal = bootstrap.Modal.getOrCreateInstance(document.getElementById('editNotesMoneyModal'));
        modal.hide();
      }
      await Swal.fire({ icon: 'success', title: 'å„²å­˜æˆåŠŸ', timer: 1200, showConfirmButton: false });
      location.reload();
    } catch (err) {
      Swal.fire({ icon: 'error', title: err?.message || 'å„²å­˜å¤±æ•—' });
    } finally {
      if (saveBtn) saveBtn.disabled = false;
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('btnPaperTrace');
    if (btn) {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        linkPaperTrace();
      });
    }

    const logBtn = document.getElementById('btnPaperLog');
    if (logBtn) {
      logBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        openUpdateLog();
      });
    }

    const editNotesBtn = document.getElementById('btnEditNotes');
    if (editNotesBtn) {
      editNotesBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        openEditNotesMoney('notes');
      });
    }

    const editMoneyBtn = document.getElementById('btnEditMoney');
    if (editMoneyBtn) {
      editMoneyBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        openEditNotesMoney('money');
      });
    }

    const saveBtn = document.getElementById('btnEditNotesMoneySave');
    if (saveBtn) {
      saveBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        saveEditNotesMoney();
      });
    }
  });
})();
</script>
@{
    string? inheritedActionPartial = (ViewData["InheritedActionPartial"] as string);
}
@if (!string.IsNullOrWhiteSpace(inheritedActionPartial))
{
    @await Html.PartialAsync(inheritedActionPartial, (object)Model)
}

<!-- å–®é ­å¯ç·¨è¼¯è¡¨å–® -->
<form id="orderHeaderForm" class="erp-header-form" data-dict-table="@headerTableName">
    <div class="row">
        <!-- âœ… Tabs åˆ‡æ›åˆ— -->
        <ul class="nav nav-tabs" id="headerTabs" role="tablist">
            @foreach (var tab in groupedTabs.Keys)
            {
                <li class="nav-item" role="presentation">
                    <button class="nav-link @(tab == firstTabKey ? "active" : "")"
                            id="tab-@tab-tab"
                            data-bs-toggle="tab"
                            data-bs-target="#tab-@tab"
                            type="button" role="tab">
                        @(tab <= 1 ? headerTabBaseLabel : $"{headerTabBaseLabel}{tab}")
                    </button>
                </li>
            }
        </ul>

        <!-- âœ… Tabs å°æ‡‰å…§å®¹ -->
        <div class="tab-content" id="headerTabContent">
            @foreach (var tab in groupedTabs)
            {
                <div class="tab-pane fade @(tab.Key == firstTabKey ? "show active" : "")"
                    id="tab-@tab.Key" role="tabpanel">
                    <ul class="list-unstyled header-fields-tab"
                        data-tab-index="@tab.Key"
                        style="position: relative">
                        @foreach (var field in tab.Value)
                        {
                            object? rawValue = null;
                            if (TryGetHeaderValue(headerData, field.FieldName, out var raw))
                                rawValue = raw;
                            string displayText = "";

                            // 1. lookup å„ªå…ˆé¡¯ç¤º
                            if (headerLookupMap != null
                                && !string.IsNullOrWhiteSpace(field.FieldName)
                                && headerLookupMap.TryGetValue(field.FieldName, out var lookupVal))
                            {
                                displayText = FormatHelper.FormatValue(lookupVal, field.DataType, field.FormatStr);
                            }
                            else if (rawValue != null)
                            {
                                //è¼¸å‡ºæ ¼å¼ç”¨Helperè½‰å‹
                                displayText = FormatHelper.FormatValue(rawValue, field.DataType, field.FormatStr);

                                // âœ… é€™è£¡è£œï¼šæ•¸å€¼å‹è‹¥ç‚ºç©ºï¼Œé¡¯ç¤º 0
                                if (string.IsNullOrWhiteSpace(displayText) && field.DataType?.ToLower() == "number")
                                {
                                    displayText = "0";
                                }
                            }

                            const int headerTopPad = 6;
                            var top = (field.iFieldTop ?? 0) + headerTopPad;
                            var left = field.iFieldLeft ?? 0;
                            var width = field.iFieldWidth ?? 160;
                            var height = field.iFieldHeight ?? 44;

                            var labTop = (field.iLabTop ?? 0) + headerTopPad;
                            var labLeft = field.iLabLeft ?? 0;
                            var labWidth = field.iLabWidth;
                            var labHeight = field.iLabHeight;
                            var labStyle = $"top:{labTop}px; left:{labLeft}px;";
                            if (labWidth.HasValue) { labStyle += $" width:{labWidth.Value}px;"; }
                            if (labHeight.HasValue) { labStyle += $" height:{labHeight.Value}px;"; }

                            var liClass = "draggable-field inline"; // æ°¸é æ©«æ’


                            var isCheckbox = (field.ComboStyle ?? 0) == 1;
                            var isNumber = IsNumberType(field.DataType);
                            var hasLookupSetting = !string.IsNullOrWhiteSpace(field.LookupTable)
                                && !string.IsNullOrWhiteSpace(field.LookupKeyField)
                                && !string.IsNullOrWhiteSpace(field.LookupResultField);
                            var fieldName = field.FieldName ?? "";
                            var hasLookupDisplay = headerLookupMap != null && headerLookupMap.ContainsKey(fieldName);
                            var lookupResultType = "";
                            if (headerLookupTypeMap != null && headerLookupTypeMap.TryGetValue(fieldName, out var rt))
                            {
                                lookupResultType = rt ?? "";
                            }
                            var lookupIsNumber = IsNumberType(lookupResultType);
                            var alignRight = lookupIsNumber || (isNumber && !hasLookupSetting && !hasLookupDisplay);
                            var alignCenter = hasLookupSetting;
                            var editColor = NormalizeEditColor(field.EditColor);
                            var editStyle = !string.IsNullOrWhiteSpace(editColor) ? $"background-color:{editColor} !important;" : "";
                            var editStyleForSelect = editStyle;
                            var isReadOnly = (field.ReadOnly ?? 0) == 1;
                            var readOnlyClass = isReadOnly ? "dict-readonly" : "";
                            var readOnlyAttr = isReadOnly ? " data-readonly=\"1\"" : " data-readonly=\"0\"";
                            var isDateType = (field.DataType ?? "").IndexOf("date", StringComparison.OrdinalIgnoreCase) >= 0;

                            <li class="header-label-item"
                                data-field="@field.FieldName"
                                data-tab="@tab.Key"
                                title="@field.FieldName"
                                style="@labStyle">
                                @field.DisplayLabel
                            </li>

                            // 1) å‹¾é¸æ¡†
                            if (isCheckbox)
                            {
                                var s = rawValue?.ToString()?.Trim() ?? "";
                                var isChecked = s == "1"
                                                || s.Equals("true", StringComparison.OrdinalIgnoreCase)
                                                || s.Equals("y", StringComparison.OrdinalIgnoreCase)
                                                || s.Equals("yes", StringComparison.OrdinalIgnoreCase);

                                <li class="@liClass @(alignRight ? "field-number" : "field-text")"
                                    data-field="@field.FieldName"
                                    data-tab="@tab.Key"
                                    title="@field.FieldName"
                                    style="top:@(top)px; left:@(left)px; width:@(width)px; height:@(height)px;">
                                    <span class="field-drag-handle" aria-hidden="true"></span>
                                    <div class="form-check d-flex align-items-center" style="height:100%; margin:0; padding-left: 0; @editStyle">
                                        <input type="hidden" name="@field.FieldName" value="0" />
                                        <input class="form-check-input"
                                               type="checkbox"
                                               name="@field.FieldName"
                                               value="1"
                                               @(isChecked ? "checked" : "")
                                               @(isReadOnly ? "disabled" : "")
                                               @Html.Raw(readOnlyAttr) />
                                    </div>
                                </li>
                            }
                            // 2) åˆ¤æ–·æœ‰ lookup table è¨­å®š
                            else if (!string.IsNullOrWhiteSpace(field.LookupTable) &&
                                !string.IsNullOrWhiteSpace(field.LookupKeyField) &&
                                !string.IsNullOrWhiteSpace(field.LookupResultField))
                            {
                                // ä¸‹æ‹‰é¸å–®å…ƒä»¶ï¼ˆå¯è¼¸å…¥ï¼‰
                                <li class="@liClass @(alignRight ? "field-number" : "field-text")"
                                    data-field="@field.FieldName"
                                    data-tab="@tab.Key"
                                    title="@field.FieldName"
                                    style="top:@(top)px; left:@(left)px; width:@(width)px; height:@(height)px;">
                                    <span class="field-drag-handle" aria-hidden="true"></span>
                                    <input type="hidden"
                                           name="@field.FieldName"
                                           value="@rawValue"
                                           class="lookup-key"
                                           data-field="@field.FieldName" />
                                    <input type="text"
                                           class="form-control lookup-dropdown @(readOnlyClass)"
                                           value="@rawValue"
                                           data-field="@field.FieldName"
                                           data-table="@field.LookupTable"
                                           data-key="@field.LookupKeyField"
                                           data-result="@field.LookupResultField.Replace(" ", "")"
                                           data-cond1-field="@field.LookupCond1Field"
                                           data-cond1-source="@field.LookupCond1ResultField"
                                           data-cond2-field="@field.LookupCond2Field"
                                           data-cond2-source="@field.LookupCond2ResultField"
                                           data-selected="@rawValue"
                                           autocomplete="off"
                                           style="@editStyleForSelect"
                                           @Html.Raw(readOnlyAttr) />
                                    <button type="button" class="lookup-toggle" aria-label="å±•é–‹ä¸‹æ‹‰" tabindex="-1"></button>
                                </li>
                            }
                            else if (isDateType)
                            {
                                var datePickerValue = "";
                                if (rawValue != null && DateTime.TryParse(rawValue.ToString(), out var dt))
                                {
                                    datePickerValue = dt.ToString("yyyy-MM-dd");
                                }
                                <li class="@liClass @(alignRight ? "field-number" : "field-text")"
                                    data-field="@field.FieldName"
                                    data-tab="@tab.Key"
                                    title="@field.FieldName"
                                    style="top:@(top)px; left:@(left)px; width:@(width)px; height:@(height)px;">
                                    <span class="field-drag-handle" aria-hidden="true"></span>
                                    <input type="text"
                                           class="form-control resizable-input date-dropdown @(readOnlyClass)"
                                           name="@field.FieldName"
                                           value="@displayText"
                                           @(isReadOnly ? "readonly" : "")
                                           data-align="@(alignRight ? "right" : (alignCenter ? "center" : null))"
                                           style="@editStyle"
                                           @Html.Raw(readOnlyAttr) />
                                    <input type="date"
                                           class="date-picker-input"
                                           tabindex="-1"
                                           aria-hidden="true"
                                           value="@datePickerValue" />
                                    <button type="button" class="lookup-toggle date-toggle" aria-label="é¸æ“‡æ—¥æœŸ" tabindex="-1"></button>
                                </li>
                            }
                            else
                            {
                                <li class="@liClass"
                                    data-field="@field.FieldName"
                                    data-tab="@tab.Key"
                                    title="@field.FieldName"
                                    style="top:@(top)px; left:@(left)px; width:@(width)px; height:@(height)px;">
                                    <span class="field-drag-handle" aria-hidden="true"></span>
                                    <textarea class="form-control resizable-input @(readOnlyClass)"
                                            name="@field.FieldName"
                                            @(isReadOnly ? "readonly" : "")
                                            data-align="@(alignRight ? "right" : (alignCenter ? "center" : null))"
                                            style="@editStyle"
                                            @Html.Raw(readOnlyAttr)>@displayText</textarea>
                                </li>
                            }
                        }
                    </ul>
                </div>
            }
        </div>
    </div>
</form>

<script>window._dictTableName = "@(ViewData["DictTableName"] ?? Model.TableName)";</script>

<!-- SweetAlert2 foræç¤º -->
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>
<script src="~/js/toolbarHandler.js?v=@DateTime.Now.Ticks"></script>
<link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css" />

<script>
// ============================
// 0) é é¢å¸¸æ•¸ï¼Razor æ³¨å…¥
// ============================
const PAGE = {
  paperNum: "@PaperNum",
  keyField: ("@(keyFieldName ?? "PaperNum")" || "PaperNum").trim(),
  headerTable: ("@(Model.HeaderTableName ?? "")".trim() || "").toLowerCase(),
  headerSaveTable: ("@(ViewData["HeaderRealTableName"] ?? Model.HeaderTableName ?? "")".trim() || "").toLowerCase(),
  detailTable: "@(tableName ?? "")".trim(),
  queryRedirectUrl: "@(ViewData["QueryRedirectUrl"])",
  addApiUrl: "@addApiUrl",
  deleteApiUrl: "@DeleteApiUrl",
  detailRouteTemplate: "@detailRouteTemplate",
  headerFields: @Html.Raw(JsonSerializer.Serialize(headerFieldsList)),
};

// æ”¾åœ¨æœ€å‰é¢ï¼ˆè¾­å…¸é–‹é—œï¼‰
window.__DICT_OPEN__ = false;

// è®“å…¶å®ƒå·¥å…·å¯ä»¥å–åˆ°ç›®å‰å–®è™Ÿ
window.selectedPaperNum = '@headerPaperNum';

const PAGE_PAPER_NUM = ("@PaperNum" || "").trim();
const KEY_FIELD = ("@(keyFieldName ?? "PaperNum")" || "PaperNum").trim();

const backToMainTpl = (PAGE.queryRedirectUrl || '').trim()
  ? PAGE.queryRedirectUrl.replace(/\/$/, '') + '/{0}'
  : '';
const subTpl = (PAGE.detailRouteTemplate || '').replace(/\{PaperNum\}/gi, '{0}');
const finalSwitchTpl = backToMainTpl || subTpl;


new ToolbarHandler({
  searchBtnId: "btnSubSearch",
  addBtnId: "btnSubAddNew",
  deleteBtnId: "btnSubBatchDelete",
  getSelectedId: () => (PAGE.paperNum || window.selectedPaperNum || ''),
  modalId: "searchModal",
  formId: "searchForm",
  addApiUrl: PAGE.addApiUrl,
  deleteApiUrlFn: id => `/api/${PAGE.deleteApiUrl}/${id || PAGE.paperNum}`,
  // å‹•æ…‹å–®æ“šçš„ä½œå»¢ï¼šèµ° PaperActionï¼ˆé¿å…æ‰¾ä¸åˆ° /api/{Table}/{PaperNum} controller è€Œ 404ï¼‰
  paperAction: { url: '/api/PaperAction/DoAction', paperId: "@Model.HeaderTableName", eoc: 0, aftFinished: 2 },
  detailRouteTemplate: subTpl,  // ä½¿ç”¨å–®èº«é è·¯å¾‘ï¼Œæ–°å¢å¾Œè·³è½‰åˆ°å–®èº«é 
  tableName: PAGE.headerTable || "@tableName",  // å„ªå…ˆä½¿ç”¨ä¸»è¡¨ï¼ˆå–®é ­ï¼‰é€²è¡ŒæŸ¥è©¢
  renderTable: null,
  renderPagination: null,
  renderOrderCount: null,
  restoreSearchForm: null,
  queryRedirectUrl: PAGE.queryRedirectUrl,
  forceStoredQueryOnRedirect: true
});

// å–®èº«é  â†’ ä¸»é  åˆ‡æ›
(function hookToggleBackToMain() {
  const rawBtn = document.getElementById('btnToggle') ||
    Array.from(document.querySelectorAll('button, a'))
      .find(el => (el.textContent || '').trim() === 'åˆ‡æ›');
  if (!rawBtn) return;
  const btn = rawBtn.cloneNode(true);
  rawBtn.replaceWith(btn);
  btn.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
    const base = ("@queryRedirectUrl" || '').trim().replace(/\/$/, '');
    if (!base) { Swal.fire({ icon: 'error', title: 'æœªæä¾›è¿”å›ä¸»é è·¯å¾‘' }); return; }
      const id = (PAGE_PAPER_NUM || window.selectedPaperNum || '').trim();
      if (id) {
        localStorage.setItem("lastViewedPaperNum", id);
      }
      location.href = base;
  }, { capture: true });
})();

// ============================
// å…±ç”¨å°å·¥å…·ï¼ˆæ•¸å€¼è™•ç†ã€å­—ä¸²åŒ–ï¼‰
// ============================
function normalizeNumberFields(obj, fieldDefs) {
  (fieldDefs || []).forEach(f => {
    if ((f.DataType || '').toLowerCase() === 'number') {
      const k = f.FieldName;
      if (obj[k] != null) obj[k] = obj[k].toString().replace(/,/g, '');
    }
  });
}

function normalizeBool(val) {
  const s = (val ?? '').toString().trim().toLowerCase();
  return s === '1' || s === 'true' || s === 'y' || s === 'yes';
}

function withTemporarilyEnabled(formEl, callback) {
  const disabledEls = Array.from(formEl.querySelectorAll('input:disabled, select:disabled, textarea:disabled'));
  disabledEls.forEach(el => el.disabled = false);
  try { return callback(); } finally { disabledEls.forEach(el => el.disabled = true); }
}

function collectHeaderFormData() {
  const form = document.getElementById('orderHeaderForm');
  return withTemporarilyEnabled(form, () => Object.fromEntries(new FormData(form)));
}

function collectHeaderChanges() {
  const form = document.getElementById('orderHeaderForm');
  if (!form) return {};

  const metaList = (Array.isArray(PAGE?.headerFields)) ? PAGE.headerFields : [];
  const lookupFields = new Set(
    metaList
      .filter(f => f && f.LookupTable && f.LookupKeyField && f.LookupResultField)
      .map(f => (f.FieldName || '').toString())
      .filter(f => f)
  );

  return withTemporarilyEnabled(form, () => {
    const changes = {};
    const inputs = form.querySelectorAll('input[name], select[name], textarea[name]');

    inputs.forEach(inp => {
      const name = (inp.name || '').toString().trim();
      if (!name) return;
      const isLookupKey = inp.classList.contains('lookup-key');
      if (isLookupKey && !lookupFields.has(name)) return;

      let currentValue = '';
      if (inp.type === 'checkbox') {
        currentValue = inp.checked ? '1' : '0';
      } else {
        currentValue = (inp.value ?? '').toString();
      }
      currentValue = currentValue.trim();

      const initValue = (inp.dataset.init ?? '').toString().trim();

      if (lookupFields.has(name)) {
        const container = inp.closest('li') || inp.parentElement;
        const hidden = container?.querySelector('input.lookup-key[name]');
        const textInput = container?.querySelector(`input.lookup-dropdown[data-field="${CSS.escape(name)}"]`);
        const hiddenValue = (hidden?.value ?? '').toString().trim();
        const hiddenInit = (hidden?.dataset?.init ?? '').toString().trim();
        const inputValue = (textInput?.value ?? currentValue).toString().trim();
        const inputInit = (textInput?.dataset?.init ?? '').toString().trim();

        let candidate = hiddenValue || inputValue;
        if (inputValue && hiddenValue) {
          const hv = hiddenValue.toLowerCase();
          const iv = inputValue.toLowerCase();
          if (!(iv === hv || iv.startsWith(hv + ' ') || iv.startsWith(hv + '-'))) {
            candidate = inputValue;
          }
        } else if (inputValue) {
          candidate = inputValue;
        }

        const initCandidate = hiddenInit || inputInit || initValue;
        if (candidate === initCandidate) return;
        changes[name] = candidate;
        return;
      }

      if (isLookupKey) return;
      if (currentValue === initValue) return;
      changes[name] = currentValue;
    });

    const paperNum = (PAGE.paperNum || window.selectedPaperNum || changes.PaperNum || '').toString().trim();
    if (paperNum) changes.PaperNum = paperNum;

    return changes;
  });
}

function normalizeLookupHeaderValues(header) {
  const form = document.getElementById('orderHeaderForm');
  if (!form || !header) return header;

  const metaList = (Array.isArray(PAGE?.headerFields)) ? PAGE.headerFields : [];
  const lookupFields = new Set(
    metaList
      .filter(f => f && f.LookupTable && f.LookupKeyField && f.LookupResultField)
      .map(f => (f.FieldName || '').toString())
      .filter(f => f)
  );

  lookupFields.forEach(field => {
    if (header[field] == null) return;
    const inp = form.querySelector(`input.lookup-dropdown[data-field="${CSS.escape(field)}"]`);
    const hidden = inp?.closest('li')?.querySelector('input.lookup-key[name]');
    const rawHeader = (header[field] ?? '').toString().trim();
    const inputValue = (inp?.value ?? '').toString().trim();
    const hiddenValue = (hidden?.value ?? '').toString().trim();
    let candidate = (hiddenValue || rawHeader).toString().trim();

    if (inputValue && hiddenValue) {
      const hv = hiddenValue.toLowerCase();
      const iv = inputValue.toLowerCase();
      if (!(iv === hv || iv.startsWith(hv + ' ') || iv.startsWith(hv + '-'))) {
        candidate = inputValue;
      }
    } else if (inputValue) {
      candidate = inputValue;
    }

    const map = inp?._lookupLabelToKey || {};
    const mapped = (window.safeMapLookupKey ? window.safeMapLookupKey(candidate, map) : candidate) ?? candidate;
    const fallback = candidate.split(' - ')[0] || candidate;
    const key = (mapped && mapped !== candidate ? mapped : fallback).trim();
    if (key) header[field] = key;
  });

  form.querySelectorAll('select[name]').forEach(sel => {
    const field = (sel.name || '').toString();
    if (!field || header[field] == null) return;
    if (lookupFields.size && !lookupFields.has(field)) return;
    const raw = (header[field] ?? '').toString().trim();
    if (!raw) return;
    if (raw.includes(' - ')) {
      const v = raw.split(' - ')[0].trim();
      if (v) header[field] = v;
    }
  });

  return header;
}

function getPaperNum() {
  const p1 = (PAGE.paperNum || window.selectedPaperNum || '').trim();
  if (p1) return p1;
  const header = collectHeaderFormData();
  return (header.PaperNum || header.papernum || '').toString().trim();
}

// ============================
// å„²å­˜å–®èº«ï¼ˆMultiTabDetailï¼‰
// ============================
async function saveMultiTabChanges(options) {
  const opts = Object.assign({ silentSuccess: false }, options || {});
  const headerTableName = window._headerTableName;
  const keyCandidates = ['PaperNum', 'Item', 'SeqNum', 'Seq', 'LineNum', 'RowNo', 'SerialNum', 'LineId'];

  const getRowFieldValue = (row, fieldName) => {
    if (!row || !fieldName) return undefined;
    const target = fieldName.toString().toLowerCase();
    const input = Array.from(row.querySelectorAll('.cell-edit[data-field]'))
      .find(el => (el.dataset.field || '').toString().toLowerCase() === target);
    if (!input) return undefined;
    if (input.type === 'checkbox') return input.checked ? '1' : '0';
    return (input.value ?? '').toString().trim();
  };

  // ? é‡å° FMEdIssueMainï¼Œåœ¨å„²å­˜å‰é‡æ–°æª¢æŸ¥è³‡æ–™åº«çš„å¯¦éš›ç‹€æ…‹
  if (headerTableName === 'FMEdIssueMain') {
    try {
      const paperNum = window._paperNum || PAGE.paperNum;
      const resp = await fetch(`/api/FMEdIssueMain/${encodeURIComponent(paperNum)}`);
      if (resp.ok) {
        const mainData = await resp.json();
        const currentFinished = mainData.Finished;

        // å…è¨±å„²å­˜çš„ç‹€æ…‹ï¼šä½œæ¥­ä¸­(0) å’Œ å¯©æ ¸ä¸­(3)
        const allowedStatuses = [0, 3];
        if (currentFinished !== null && !allowedStatuses.includes(currentFinished)) {
          const statusMap = {0:'ä½œæ¥­ä¸­', 1:'å·²ç¢ºèª', 2:'ä½œå»¢ä¸­', 3:'å¯©æ ¸ä¸­', 4:'å·²çµæ¡ˆ'};
          const statusName = statusMap[currentFinished] || `ä»£ç¢¼:${currentFinished}`;

          await Swal.fire({
            icon: 'warning',
            title: 'å–®æ“šç‹€æ…‹å·²è®Šæ›´',
            html: `æ­¤å–®æ“šç‹€æ…‹å·²è®Šæ›´ç‚ºã€Œ<b>${statusName}</b>ã€ï¼Œç„¡æ³•å„²å­˜ä¿®æ”¹ã€‚<br>è«‹é‡æ–°æ•´ç†é é¢ä»¥å–å¾—æœ€æ–°ç‹€æ…‹ã€‚`,
            confirmButtonText: 'é‡æ–°æ•´ç†é é¢',
            showCancelButton: true,
            cancelButtonText: 'å–æ¶ˆ'
          }).then((result) => {
            if (result.isConfirmed) {
              location.reload();
            }
          });
          return { ok: false, hasChanges: false };
        }
      }
    } catch (err) {
      console.error('? [å„²å­˜] æª¢æŸ¥ç‹€æ…‹å¤±æ•—:', err);
      // ç¹¼çºŒåŸ·è¡Œå„²å­˜ï¼ˆè®“è§¸ç™¼å™¨æ±ºå®šæ˜¯å¦å…è¨±ï¼‰
    }
  }

  // æ”¶é›†æ‰€æœ‰å·²ä¿®æ”¹çš„åˆ—è³‡æ–™ï¼ˆåƒ…é™ç•¶å‰å–®è™Ÿï¼‰
  const currentPaperNum = window._paperNum || PAGE.paperNum;


  const allChanges = [];
  const tables = document.querySelectorAll('.multi-tab-detail .table-container');

  for (const container of tables) {
    const tableName = container.dataset.dictTable;
    if (!tableName) continue;

    const tbody = container.querySelector('tbody');
    if (!tbody) continue;

    const rows = tbody.querySelectorAll('tr[data-state="modified"], tr[data-state="added"]');
    const changes = [];

    for (const row of rows) {
      const isAdded = (row.dataset.state || '').toString().toLowerCase() === 'added';
      // ? é—œéµä¿®æ­£ï¼šåªè™•ç†ç•¶å‰å–®è™Ÿçš„è³‡æ–™
      const rowPaperNum = row.dataset.paperNum;

      if (rowPaperNum && rowPaperNum !== currentPaperNum) {
        continue;
      }

      const rowData = {};
      let hasChangedField = false;
      const inputs = row.querySelectorAll('.cell-edit');

      for (const inp of inputs) {
        const fieldName = inp.dataset.field || inp.name;
        if (fieldName) {
          let currentValue = '';
          let initValue = inp.dataset.init ?? '';
          if (inp.type === 'checkbox') {
            currentValue = inp.checked ? '1' : '0';
            initValue = normalizeBool(initValue) ? '1' : '0';
          } else {
            currentValue = (inp.value ?? '').trim();
            initValue = (initValue ?? '').toString().trim();
          }
          if (!isAdded && currentValue === initValue) continue;

          // ? æ™ºèƒ½å‹åˆ¥è½‰æ›ï¼šæ•¸å­—æ¬„ä½è½‰æˆæ•¸å­—ï¼Œç©ºå€¼è½‰æˆ null
          let value = currentValue;

          // ç©ºå€¼çµ±ä¸€è½‰æˆ nullï¼Œè®“å¾Œç«¯è™•ç†æˆ DBNull.Value
          if (value === '' || value === undefined || value === null) {
            value = null;
          } else {
            // å¦‚æœæ¬„ä½åç¨±åŒ…å«å¸¸è¦‹çš„æ•¸å­—æ¬„ä½é—œéµå­—ï¼Œå˜—è©¦è½‰æˆæ•¸å­—
            const numberFieldPatterns = /Qnty|Item|Serial|Amount|Price|Qty|Num|Count|Weight|Rate|Pop|Pcs$/i;

            if (numberFieldPatterns.test(fieldName)) {
              // ç§»é™¤åƒåˆ†ä½é€—è™Ÿ
              const cleanValue = value.replace(/,/g, '');
              const numValue = Number(cleanValue);

              // åªæœ‰åœ¨æ˜¯æœ‰æ•ˆæ•¸å­—æ™‚æ‰è½‰æ›ï¼Œå¦å‰‡ä¿æŒåŸå€¼ï¼ˆè®“å¾Œç«¯å ±éŒ¯ï¼‰
              if (!isNaN(numValue)) {
                value = numValue;
              }
            }
          }

          rowData[fieldName] = value;
          hasChangedField = true;
        }
      }

      if (!isAdded && !hasChangedField) continue;

      // ? ç¢ºä¿ PaperNum å’Œ Item ä¸€å®šå­˜åœ¨ï¼ˆå¾ dataset å–å¾—ä¸»éµå€¼ï¼‰
      if (!rowData.PaperNum && rowPaperNum) {
        rowData.PaperNum = rowPaperNum;
      }

      const rowItem = row.dataset.item;
      if (!rowData.Item && rowItem) {
        // Item éœ€è¦è½‰æˆæ•¸å­—
        const itemNum = Number(rowItem);
        if (!isNaN(itemNum)) {
          rowData.Item = itemNum;
        } else {
        }
      }

      // ? è£œä¸Šå¯èƒ½çš„éµæ¬„ä½ï¼ˆå³ä½¿æœªè®Šæ›´ï¼‰ï¼Œé¿å…æ‰¾ä¸åˆ°ä¸»éµ
      keyCandidates.forEach(k => {
        if (rowData[k] !== undefined) return;
        const v = getRowFieldValue(row, k);
        if (v != null && v !== '') rowData[k] = v;
      });

      // ç¢ºä¿æœ‰è³‡æ–™å†åŠ å…¥ï¼Œä¸¦ä¸”é¡¯ç¤ºå®Œæ•´çš„ rowData å…§å®¹
      if (Object.keys(rowData).length > 0) {
        changes.push(rowData);
      }
    }

    if (changes.length > 0) {
      allChanges.push({ tableName, changes });
    }
  }

  const subDetailPayload = (typeof window.__paper3lSubDetailCollectChanges === 'function')
    ? window.__paper3lSubDetailCollectChanges()
    : null;
  if (subDetailPayload?.changes?.length) {
    allChanges.push(subDetailPayload);
  }

  if (allChanges.length === 0) {
    return { ok: true, hasChanges: false };
  }

  try {
    let saveSuccess = true;
    let saveErrors = [];

    const formatSaveError = (raw, tableName) => {
      const text = (raw || '').toString();
      const key = (tableName || '').toString().replace(/^dbo\./i, '').trim().toLowerCase();
      const dict = window._detailFieldDicts?.[key] || {};
      const colMatch = text.match(/è³‡æ–™è¡Œ\s+'([^']+)'/i) || text.match(/column\s+'([^']+)'/i);
      const col = colMatch ? colMatch[1] : '';
      if (!col) return text;
      const label = dict[col] || dict[col.toLowerCase?.()] || col;
      return `${label}(${col})ä¸èƒ½ç‚ºç©º`;
    };

    for (const { tableName, changes, keyFields: keyFieldsOverride } of allChanges) {

      // å–å¾—ä¸»éµæ¬„ä½ï¼ˆå¾ç¬¬ä¸€ç­†è³‡æ–™æ¨æ–·ï¼‰
      const firstRow = changes[0];
      const keyFields = Array.isArray(keyFieldsOverride) ? keyFieldsOverride.slice(0) : [];
      if (keyFields.length === 0) {
        keyCandidates.forEach(k => {
          if (firstRow[k] !== undefined) keyFields.push(k);
        });
      }
      if (keyFields.length === 0) {
        keyFields.push(HEADER_KEY_FIELD);
      }

      const payload = {
        TableName: tableName,
        Data: changes,
        KeyFields: keyFields
      };

      const resp = await fetch('/api/CommonTable/SaveTableChanges', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!resp.ok) {
        saveSuccess = false;
        const errorText = await resp.text();
        const friendly = formatSaveError(errorText, tableName);
        saveErrors.push(`${tableName}: ${friendly}`);
        console.error(`? [å„²å­˜] ${tableName} å„²å­˜å¤±æ•—:`, errorText);
      } else {
        const result = await resp.json();
        const badRows = Array.isArray(result?.results)
          ? result.results.filter(r => r && r.ok === false)
          : [];
        if (badRows.length) {
          saveSuccess = false;
          const reasons = badRows.map(r => r.reason || r.skip || 'å„²å­˜å¤±æ•—');
          saveErrors.push(`${tableName}: ${reasons.join('; ')}`);
        }

        // å„²å­˜æˆåŠŸå¾Œï¼Œå°‡æ‰€æœ‰å·²ä¿®æ”¹åˆ—çš„ç‹€æ…‹æ”¹ç‚º unchangedï¼Œä¸¦åŒæ­¥æ›´æ–° view é¡¯ç¤ºå€¼
        const container = document.querySelector(`.table-container[data-dict-table="${tableName}"]`);
        if (container) {
          container.querySelectorAll('tr[data-state="modified"], tr[data-state="added"]').forEach(tr => {
            tr.dataset.state = 'unchanged';

            // ? åŒæ­¥æ›´æ–° view é¡¯ç¤ºå€¼ï¼šå°‡ input çš„å€¼è¤‡è£½åˆ°å°æ‡‰çš„ cell-view
            tr.querySelectorAll('.cell-edit').forEach(input => {
              const fieldName = input.dataset.field || input.name;
              if (!fieldName) return;

              // æ‰¾åˆ°åŒä¸€å€‹ td å…§çš„ cell-view
              const td = input.closest('td');
              if (td) {
                const viewSpan = td.querySelector('.cell-view');
                if (viewSpan) {
                  // æ›´æ–°é¡¯ç¤ºå€¼ï¼ˆä¿ç•™åƒåˆ†ä½æ ¼å¼åŒ–ï¼Œå¦‚æœæœ‰çš„è©±ï¼‰
                  let displayValue = input.value?.trim() || '';

                  // å¦‚æœæ˜¯æ•¸å­—æ¬„ä½ï¼Œå¯ä»¥é¸æ“‡æ€§åŠ ä¸Šåƒåˆ†ä½
                  const numberFieldPatterns = /Qnty|Amount|Price|Qty|Count|Weight$/i;
                  if (numberFieldPatterns.test(fieldName) && displayValue) {
                    const num = parseFloat(displayValue.replace(/,/g, ''));
                    if (!isNaN(num)) {
                      displayValue = num.toLocaleString('en-US', {
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 4
                      });
                    }
                  }

                  viewSpan.textContent = displayValue;
                }
              }
            });
          });
        }
      }
    }

    if (saveSuccess) {
      return { ok: true, hasChanges: true };
    }

    await Swal.fire({
      icon: 'error',
      title: 'å„²å­˜å¤±æ•—',
      html: saveErrors.join('<br>')
    });
    return { ok: false, hasChanges: true };
  } catch (err) {
    console.error('? [å„²å­˜] å„²å­˜éŒ¯èª¤:', err);
    await Swal.fire({
      icon: 'error',
      title: 'å„²å­˜éŒ¯èª¤',
      text: String(err)
    });
    return { ok: false, hasChanges: true };
  }
}

// ============================
// å„²å­˜å–®é ­
// ============================
async function saveHeaderForm() {
  const header = collectHeaderChanges();
  normalizeNumberFields(header, PAGE.headerFields);
  normalizeLookupHeaderValues(header);

  const payload = { ...header, __headerTable: PAGE.headerSaveTable || PAGE.headerTable };

  try {
    const detailSave = await saveMultiTabChanges({ silentSuccess: true });
    if (!detailSave.ok) return { ok: false };

    const changeKeys = Object.keys(header).filter(k => k.toLowerCase() !== 'papernum');
    if (!changeKeys.length) {
      return { ok: true, hasChanges: detailSave.hasChanges === true };
    }

    const resp = await fetch('/api/OrderHeaderApi/SaveOrderHeader', {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
    });
    if (resp.ok) {
      const result = await resp.json();
      if (result.updated) {
        if (result.data) {
          try { applyHeaderRow(result.data); } catch {}
        }
        if (typeof window.__refreshHeaderData === 'function') {
          try { await window.__refreshHeaderData(); } catch {}
        }
        if (typeof window.__refreshMultiTab === 'function') {
          try { await window.__refreshMultiTab(); } catch {}
        }
        if (typeof window.__paper3lSubDetailRefresh === 'function') {
          try { await window.__paper3lSubDetailRefresh(); } catch {}
        }
      } else {
        Swal.fire({ icon: 'info', title: 'æ²’æœ‰è³‡æ–™ç•°å‹•' });
      }
      return { ok: true };
    }
    let msg = 'å„²å­˜å¤±æ•—'; try { const txt = await resp.text(); msg = txt || msg; } catch {}
    Swal.fire({ icon: 'error', title: msg });
    return { ok: false };
  } catch (err) {
    Swal.fire({ icon: 'error', title: 'ç¶²è·¯æˆ–ä¼ºæœå™¨éŒ¯èª¤' });
    return { ok: false };
  }
}

document.getElementById('orderHeaderForm').addEventListener('submit', async function (e) {
  e.preventDefault();
  await saveHeaderForm();
});

// ============================
// ä¸‹æ‹‰é¸é …è‡ªå‹•å­˜æª”
// ============================
let autoSaveHeaderTimer = null;
let autoSaveHeaderInFlight = false;
let autoSaveDetailTimer = null;
let autoSaveDetailInFlight = false;

window.__autoSaveHeader = () => {
  if (!getHeaderEditState()) return;
  if (autoSaveHeaderTimer) clearTimeout(autoSaveHeaderTimer);
  autoSaveHeaderTimer = setTimeout(async () => {
    if (autoSaveHeaderInFlight) return;
    autoSaveHeaderInFlight = true;
    try { await saveHeaderForm(); } finally { autoSaveHeaderInFlight = false; }
  }, 200);
};

window.__autoSaveDetail = () => {
  if (!getHeaderEditState()) return;
  if (autoSaveDetailTimer) clearTimeout(autoSaveDetailTimer);
  autoSaveDetailTimer = setTimeout(async () => {
    if (autoSaveDetailInFlight) return;
    autoSaveDetailInFlight = true;
    try { await saveMultiTabChanges({ silentSuccess: true }); } finally { autoSaveDetailInFlight = false; }
  }, 200);
};

document.addEventListener('change', (e) => {
  const el = e.target;
  if (!(el instanceof HTMLElement)) return;
  if (!el.closest('.erp-header-form')) return;
  if (el.matches('select')) {
    window.__autoSaveHeader?.();
    return;
  }
  if (el.matches('input.lookup-dropdown')) {
    window.__autoSaveHeader?.();
  }
});

// ============================
// æª¢è¦–/ç·¨è¼¯æ¨¡å¼åˆ‡æ›
// ============================
const editBtn = document.getElementById('btnViewEditToggle');
if (editBtn) {
  let isEdit = false;
  if (localStorage.getItem("afterSave") === "1" && typeof window.__headerIsEdit !== 'boolean') {
    window.__headerIsEdit = true;
  }

  function setLookupReadOnly(el, readOnly) {
    if (!el) return;
    const isSelect = el.tagName && el.tagName.toLowerCase() === 'select';
    if (readOnly) {
      el.dataset.lockedValue = el.value ?? '';
      el.classList.add('lookup-readonly');
      el.setAttribute('aria-readonly', 'true');
      el.title = 'ç€è¦½æ¨¡å¼ï¼šå¯æŸ¥çœ‹ä¸‹æ‹‰å…§å®¹ï¼Œä¸èƒ½ä¿®æ”¹';
      if (isSelect) {
        el.disabled = false;
      } else {
        el.readOnly = true;
        el.disabled = false;
      }
    } else {
      el.classList.remove('lookup-readonly');
      el.removeAttribute('aria-readonly');
      el.title = '';
      el.dataset.lockedValue = el.value ?? '';
      if (isSelect) {
        el.disabled = false;
      } else {
        el.readOnly = false;
        el.disabled = false;
      }
    }
  }

  function applyHeaderEditState(editing) {
    document.querySelectorAll('.erp-header-form input, .erp-header-form textarea, .erp-header-form select')
      .forEach(el => {
        if (el.closest('.modal')) return;
        const isDictReadOnly = el.dataset.readonly === '1';
        if (el.matches('.lookup-dropdown')) {
          setLookupReadOnly(el, isDictReadOnly || !editing);
        } else {
          if (isDictReadOnly) {
            if (el.type === 'checkbox') {
              el.disabled = true;
            } else {
              el.readOnly = true;
            }
            el.classList.add('dict-readonly');
            el.disabled = false;
          } else {
            el.disabled = !editing;
          }
        }
      });
  }

  function applyToolbarEditState(editing) {
    // +- æŒ‰éˆ•ï¼šç·¨è¼¯æ¨¡å¼æ™‚ç«‹å³äº®èµ·
    const addDeleteIds = ['btnSubDetailAdd', 'btnSubDetailDelete'];
    addDeleteIds.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.disabled = !editing;
      el.classList.toggle('disabled', !editing);
    });

    // å‹¾å‰æŒ‰éˆ•ï¼šç·¨è¼¯æ¨¡å¼ + æœ‰ç•°å‹•æ™‚æ‰äº®èµ·
    const saveCheckIds = ['btnSaveHeader', 'btnCancelChanges'];
    const hasChanges = !!window.__unsavedChanges;
    saveCheckIds.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.disabled = !editing || !hasChanges;
      el.classList.toggle('disabled', !editing || !hasChanges);
    });

    const viewOnlyIds = ['btnSubSearch', 'btnSwitch', 'btnSubAddNew', 'btnPrint', 'btnPaperTrace', 'btnPaperLog', 'btnCancel', 'btnFirst', 'btnPrev', 'btnNext', 'btnLast', 'btnEditNotes', 'btnEditMoney'];
    viewOnlyIds.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      if (editing) {
        el.dataset.prevDisabled = el.disabled ? '1' : '0';
        el.disabled = true;
        el.classList.add('disabled');
      } else {
        const wasDisabled = el.dataset.prevDisabled === '1';
        el.disabled = wasDisabled;
        if (!wasDisabled) el.classList.remove('disabled');
        delete el.dataset.prevDisabled;
      }
    });
  }

  document.addEventListener('change', (e) => {
    const sel = e.target;
    if (!(sel instanceof HTMLSelectElement || sel instanceof HTMLInputElement)) return;
    if (!sel.matches('.erp-header-form .lookup-dropdown')) return;
    if (sel.closest('.modal')) return;
    if (isEdit && sel.dataset.readonly !== '1') return;

    const locked = sel.dataset.lockedValue ?? '';
    if ((sel.value ?? '') !== locked) {
      sel.value = locked;
      syncLookupLabel(sel);
    }
    e.stopPropagation();
  }, true);
  document.addEventListener('input', (e) => {
    const sel = e.target;
    if (!(sel instanceof HTMLInputElement)) return;
    if (!sel.matches('.erp-header-form .lookup-dropdown')) return;
    if (sel.closest('.modal')) return;
    if (isEdit && sel.dataset.readonly !== '1') return;

    const locked = sel.dataset.lockedValue ?? '';
    if ((sel.value ?? '') !== locked) {
      sel.value = locked;
      syncLookupLabel(sel);
    }
    e.stopPropagation();
  }, true);
  document.addEventListener('keydown', (e) => {
    const sel = e.target;
    if (!(sel instanceof HTMLSelectElement)) return;
    if (!sel.matches('.erp-header-form .lookup-dropdown')) return;
    if (sel.closest('.modal')) return;
    if (isEdit && sel.dataset.readonly !== '1') return;

    const blockKeys = ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown', ' ', 'Enter'];
    if (blockKeys.includes(e.key)) {
      e.preventDefault();
      e.stopPropagation();
    }
  }, true);

  function getHeaderEditState() {
    if (typeof window.__headerIsEdit === 'boolean') return window.__headerIsEdit;
    const btn = document.getElementById('btnViewEditToggle');
    return !!btn && (btn.textContent || '').trim() === 'ä¿ç•™';
  }

  function getHeaderLabelText(fieldName) {
    if (!fieldName) return '';
    const label = document.querySelector(`.header-label-item[data-field="${CSS.escape(fieldName)}"]`);
    return (label?.textContent || '').trim();
  }

  function refreshDependentLookups(changedField) {
    const labelText = getHeaderLabelText(changedField);
    document.querySelectorAll('.erp-header-form .lookup-dropdown[data-field]').forEach(input => {
      if (input.closest('.modal')) return;
      const src1 = (input.dataset.cond1Source || '').trim();
      const src2 = (input.dataset.cond2Source || '').trim();
      const match1 = src1 && (src1 === changedField || (labelText && src1 === labelText));
      const match2 = src2 && (src2 === changedField || (labelText && src2 === labelText));
      if (!match1 && !match2) return;
      delete input.dataset.lookupLoaded;
      delete input.dataset.lookupCondKey;
      input._lookupItems = [];
      if (typeof loadLookupOptions === 'function') loadLookupOptions(input);
    });
  }

  document.addEventListener('change', (e) => {
    const el = e.target;
    if (!(el instanceof HTMLInputElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement)) return;
    if (!el.closest('.erp-header-form') || el.closest('.modal')) return;
    const fieldName = (el.getAttribute('name') || el.dataset.field || '').toString().trim();
    if (!fieldName) return;
    refreshDependentLookups(fieldName);
  }, true);

  // ç·¨è¼¯æ¨¡å¼ï¼šlookup input ç”¨ Backspace/Delete ç›´æ¥æ¸…ç©º
  document.addEventListener('keydown', (e) => {
    const inp = e.target;
    if (!(inp instanceof HTMLInputElement)) return;
    if (!inp.matches('.erp-header-form .lookup-dropdown')) return;
    if (inp.closest('.modal')) return;
    if (!getHeaderEditState() || inp.dataset.readonly === '1') return;
    if (e.key !== 'Backspace' && e.key !== 'Delete') return;
    if (inp.readOnly) return;
    if (!inp.value) return;
    const init = inp.dataset.init ?? inp.dataset.selected ?? '';
    const start = inp.selectionStart ?? 0;
    const end = inp.selectionEnd ?? 0;
    const allSelected = start === 0 && end === inp.value.length;
    const rawKey = String(inp.value ?? '').split(' - ')[0];
    const unchanged = rawKey === String(init ?? '');
    if (allSelected || unchanged) {
      inp.value = '';
      syncLookupLabel(inp);
      e.preventDefault();
      e.stopPropagation();
    }
  }, true);
  const getHeaderValueByLabel = (labelText) => {
    const $label = $('.header-label-item').filter(function () {
      return $(this).text().trim() === labelText;
    }).first();
    if (!$label.length) return null;
    const fieldName = $label.data('field');
    if (!fieldName) return null;
    const $li = $(`.draggable-field[data-field="${fieldName}"]`).first();
    if (!$li.length) return null;
    const $ctrl = $li.find('select, input, textarea').first();
    if (!$ctrl.length) return null;
    if ($ctrl.is('select')) return $ctrl.find('option:selected').text().trim();
    return ($ctrl.val() || '').toString().trim();
  };

  function setHeaderEditMode(editing) {
    isEdit = !!editing;
    window.__headerIsEdit = isEdit;
    try {
      window.dispatchEvent(new CustomEvent('headerEditModeChanged', { detail: { isEdit } }));
    } catch {}
    const topToolbar = document.getElementById('topToolbar');
    if (topToolbar) {
      topToolbar.classList.toggle('mode-edit', isEdit);
      topToolbar.classList.toggle('mode-view', !isEdit);
    }
    const countBox = document.getElementById('toolbarCountBox');
    if (countBox) {
      countBox.classList.toggle('mode-edit', isEdit);
      countBox.classList.toggle('mode-view', !isEdit);
    }
    editBtn.innerHTML = isEdit
      ? '<i class="bi bi-save"></i>ä¿ç•™'
      : '<i class="bi bi-pencil-square"></i>ä¿®æ”¹';
    applyHeaderEditState(isEdit);
    applyToolbarEditState(isEdit);

    // åˆ‡æ›å–®é ­æ¬„ä½çš„ disabled ç‹€æ…‹
    document.querySelectorAll('.erp-header-form input, .erp-header-form textarea, .erp-header-form select')
      .forEach(el => {
        if (el.closest('.modal')) return;
        const isDictReadOnly = el.dataset.readonly === '1';
        if (el.matches('.lookup-dropdown')) {
          setLookupReadOnly(el, isDictReadOnly || !isEdit);
          if (isDictReadOnly) el.classList.add('dict-readonly');
          return;
        }
        if (isDictReadOnly) {
          if (el.type === 'checkbox') {
            el.disabled = true;
          } else {
            el.readOnly = true;
            el.disabled = false;
          }
          el.classList.add('dict-readonly');
        } else {
          el.disabled = !isEdit;
        }
      });

    // ? åˆ‡æ›å–®èº«è¡¨æ ¼çš„é¡¯ç¤º/ç·¨è¼¯æ¨¡å¼ï¼ˆé‡å° _MultiTabDetail.cshtmlï¼‰
    document.querySelectorAll('.multi-tab-detail .erp-table .cell-view')
      .forEach(el => el.classList.toggle('d-none', isEdit));
    document.querySelectorAll('.multi-tab-detail .erp-table .cell-edit')
      .forEach(el => el.classList.toggle('d-none', !isEdit));

    // ç¶å®š input äº‹ä»¶ï¼Œæ¨™è¨˜åˆ—ç‚ºå·²ä¿®æ”¹
    if (isEdit) {
      document.querySelectorAll('.multi-tab-detail .erp-table .cell-edit').forEach(inp => {
        inp.addEventListener('input', () => {
          const tr = inp.closest('tr');
          if (tr && tr.dataset.state !== 'added') {
            tr.dataset.state = 'modified';
          }
          window.__unsavedChanges = true;
          if (typeof window.updateSaveCheckButtons === 'function') window.updateSaveCheckButtons();
        });
      });
    }
  }

  window.__setHeaderEditMode = setHeaderEditMode;

  editBtn.addEventListener('click', async function () {
    const headerTableName = window._headerTableName;
    const paperNum = window._paperNum || (typeof PAGE !== 'undefined' ? PAGE.paperNum : null);

    // å¦‚æœæ˜¯å¾ã€Œç·¨è¼¯æ¨¡å¼ã€åˆ‡å›ã€Œæª¢è¦–æ¨¡å¼ã€ï¼ˆä¿ç•™ï¼‰ï¼Œå‰‡å„²å­˜å–®èº«è³‡æ–™
    if (isEdit) {
      const detailSave = await saveMultiTabChanges();
      if (!detailSave.ok) return;
      setHeaderEditMode(false);
      return;
    }

    // å¾ã€Œæª¢è¦–æ¨¡å¼ã€åˆ‡åˆ°ã€Œç·¨è¼¯æ¨¡å¼ã€ï¼ˆä¿®æ”¹ï¼‰ï¼Œå‘¼å«å¾Œç«¯ API æª¢æŸ¥
    if (!paperNum || !headerTableName) {
      console.warn('[ä¿®æ”¹æŒ‰éˆ•] ç¼ºå°‘ paperNum æˆ– headerTableName');
      setHeaderEditMode(true);
      return;
    }

    try {
      const checkResp = await fetch('/api/PaperAction/CheckCanEdit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          paperId: headerTableName,
          paperNum: paperNum,
          itemId: window._itemId || '',
          userId: window._userId || localStorage.getItem('erpLoginUserId') || 'admin',
          useId: window._useId || 'A001'
        })
      });

      if (!checkResp.ok) {
        const errData = await checkResp.json().catch(() => ({}));
        await Swal.fire({ icon: 'error', title: 'æª¢æŸ¥å¤±æ•—', text: errData.message || 'ç„¡æ³•é©—è­‰ç·¨è¼¯æ¬Šé™' });
        return;
      }

      const result = await checkResp.json();

      // æ”¯æ´ PascalCase (C# é è¨­) å’Œ camelCase
      const canEdit = result.CanEdit ?? result.canEdit;
      const message = result.Message ?? result.message;
      const requiresRejection = result.RequiresRejection ?? result.requiresRejection;
      const canAutoReject = result.CanAutoReject ?? result.canAutoReject;
      const rejectRequiresNotes = result.RejectRequiresNotes ?? result.rejectRequiresNotes;
      const rejectMessage = result.RejectMessage ?? result.rejectMessage;
      const latestData = result.LatestData ?? result.latestData;

      // æ›´æ–°å‰ç«¯ç‹€æ…‹ (å¾å¾Œç«¯å–å¾—æœ€æ–°è³‡æ–™)
      if (latestData) {
        window._finishedStatus = latestData.Finished;
      }

      if (canEdit) {
        setHeaderEditMode(true);
        return;
      }

      // ä¸èƒ½ç›´æ¥ç·¨è¼¯
      if (!requiresRejection) {
        await Swal.fire({ icon: 'warning', title: 'ç„¡æ³•ä¿®æ”¹', text: message });
        return;
      }

      // éœ€è¦é€€å¯©ä½†æ²’æœ‰æ¬Šé™
      if (!canAutoReject) {
        await Swal.fire({ icon: 'warning', title: 'ç„¡æ³•ä¿®æ”¹', text: message });
        return;
      }

      // æœ‰æ¬Šé™å¯è‡ªå‹•é€€å¯©ï¼Œé¡¯ç¤ºç¢ºèªå°è©±æ¡†
      const shouldReject = await showRejectConfirmDialog({ message, rejectRequiresNotes, rejectMessage });
      if (!shouldReject.confirmed) return;

      // åŸ·è¡Œé€€å¯©
      const rejectResp = await fetch('/api/PaperAction/RejectForEdit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          paperId: headerTableName,
          paperNum: paperNum,
          itemId: window._itemId || '',
          userId: window._userId || localStorage.getItem('erpLoginUserId') || 'admin',
          useId: window._useId || 'A001',
          rejectNotes: shouldReject.notes || ''
        })
      });

      if (!rejectResp.ok) {
        const errData = await rejectResp.json().catch(() => ({}));
        await Swal.fire({ icon: 'error', title: 'é€€å¯©å¤±æ•—', text: errData.message || 'ç„¡æ³•å®Œæˆé€€å¯©æ“ä½œ' });
        return;
      }

      // é€€å¯©æˆåŠŸï¼Œé‡æ–°è¼‰å…¥é é¢ä¸¦è‡ªå‹•é€²å…¥ç·¨è¼¯æ¨¡å¼
      localStorage.setItem('afterReject', '1');
      location.reload();

    } catch (err) {
      console.error('[ä¿®æ”¹æŒ‰éˆ•] éŒ¯èª¤:', err);
      await Swal.fire({ icon: 'error', title: 'ç³»çµ±éŒ¯èª¤', text: 'ç„¡æ³•é©—è­‰ç·¨è¼¯æ¬Šé™ï¼Œè«‹ç¨å¾Œå†è©¦' });
    }
  });

  // é€€å¯©ç¢ºèªå°è©±æ¡†
  async function showRejectConfirmDialog(checkResult) {
    if (checkResult.rejectRequiresNotes) {
      const result = await Swal.fire({
        icon: 'question',
        title: 'ç¢ºèªé€€å¯©',
        html: `${checkResult.rejectMessage || checkResult.message}<br><br>è«‹è¼¸å…¥é€€å¯©åŸå› ï¼š`,
        input: 'textarea',
        inputPlaceholder: 'è«‹è¼¸å…¥é€€å¯©åŸå› ',
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®šé€€å¯©',
        cancelButtonText: 'å–æ¶ˆ',
        inputValidator: (value) => {
          if (!value || !value.trim()) return 'è«‹è¼¸å…¥é€€å¯©åŸå› ';
        }
      });
      return { confirmed: result.isConfirmed, notes: result.value || '' };
    } else {
      const result = await Swal.fire({
        icon: 'question',
        title: 'ç¢ºèªé€€å¯©',
        text: checkResult.rejectMessage || checkResult.message,
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®šé€€å¯©',
        cancelButtonText: 'å–æ¶ˆ'
      });
      return { confirmed: result.isConfirmed, notes: '' };
    }
  }

  window.addEventListener('load', () => {
    captureHeaderInitValues();
    setHeaderEditMode(false);
    if (localStorage.getItem("afterReject") === "1") {
      localStorage.removeItem("afterReject");
      setHeaderEditMode(true);
      return;
    }
    if (localStorage.getItem("afterSave") === "1") {
      localStorage.removeItem("afterSave");
      document.getElementById("btnViewEditToggle")?.click();
    }
  });
}

// ============================
// Header ç‰ˆé¢æ‹–æ‹‰å„²å­˜ / Lookup ä¸‹æ‹‰åˆå§‹åŒ–ï¼ˆjQueryï¼‰
// ============================
$(function () {
  let debounceTimer;
  const debounceSave = () => { clearTimeout(debounceTimer); debounceTimer = setTimeout(saveLayoutChanges, 400); };

  function saveLayoutChanges() {
    const layout = [];
    const headerTopPad = 6;
    const hiddenTabs = $(".tab-pane").not(".show");
    hiddenTabs.addClass("temporary-show").addClass("show").css("display", "block");
    $(".draggable-field").each(function () {
      const $li = $(this);
      const $label = $(`.header-label-item[data-field="${$li.data("field")}"]`).first();
      const labelPos = $label.length ? $label.position() : null;
      const fieldTop = Math.max(0, Math.round($li.position().top) - headerTopPad);
      const fieldLeft = Math.round($li.position().left);
      const labTop = labelPos ? Math.max(0, Math.round(labelPos.top) - headerTopPad) : null;
      const labLeft = labelPos ? Math.round(labelPos.left) : null;
      layout.push({
        fieldName: $li.data("field"),
        top: fieldTop,
        left: fieldLeft,
        width: Math.round($li.outerWidth()),
        height: Math.round($li.outerHeight()),
        labTop: labTop,
        labLeft: labLeft,
        ishowWhere: parseInt($li.attr("data-tab")) || 1
      });
    });
    hiddenTabs.removeClass("show").removeClass("temporary-show").css("display", "");
    if (!layout.length) return;

    fetch("/api/TableFieldLayout/SaveHeaderLayout", {
      method: "POST", headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tableName: "@Model.HeaderTableName", layoutUpdates: layout })
    }).catch(()=>{});
  }

  $(".draggable-field").each(function () {
    const $li = $(this);
    $li.draggable({
      handle: ".field-drag-handle",
      helper: function () {
        const labelText = $('.header-label-item[data-field="' + $li.data('field') + '"]').text().trim();
        return $("<div>").text(labelText).css({
          width: "80px", height: $li.outerHeight() + "px",
          background: "#eef", border: "1px dashed #999", padding: "4px", "font-size": "0.9em"
        });
      },
      appendTo: "body", zIndex: 10000,
      start: function () { $(this).hide(); },
      stop: function (event, ui) {
        const $item = $(this);
        $item.show();

        const $parent = $item.parent();
        const parentOff = $parent.offset();
        if (parentOff) {
          $item.css({
            position: "absolute",
            top: Math.round(ui.offset.top - parentOff.top),
            left: Math.round(ui.offset.left - parentOff.left)
          });
        }

        debounceSave();
      }
    });
    $li.resizable({ handles: "e, se", minWidth: 50, minHeight: 22, stop: debounceSave });
  });

  function setLayoutEditEnabled(enabled) {
    const $body = $(document.body);
    const uid = (localStorage.getItem('erpLoginUserId') || window._userId || '').toString().trim().toLowerCase();
    const cachedAdmin = uid ? localStorage.getItem(`erpIsAdmin:${uid}`) === '1' : false;
    const bodyAdmin = document.body?.dataset?.isAdmin === '1';
    const canEnable = !!enabled && (window.__isAdmin === true || cachedAdmin || bodyAdmin);
    $body.toggleClass("layout-edit-enabled", canEnable);
    $(".draggable-field").each(function () {
      try { $(this).draggable(canEnable ? "enable" : "disable"); } catch {}
      try { $(this).resizable(canEnable ? "enable" : "disable"); } catch {}
    });
  }

  setLayoutEditEnabled(false);
  $(document).on("keydown", function (e) {
    if (e.key === "Shift" || e.shiftKey) {
      window.__layoutShiftDown = true;
      setLayoutEditEnabled(true);
    }
  });
  $(document).on("keyup", function (e) {
    if (e.key === "Shift" || !e.shiftKey) {
      window.__layoutShiftDown = false;
      setLayoutEditEnabled(false);
    }
  });
  window.addEventListener('adminStateReady', () => {
    if (window.__layoutShiftDown) setLayoutEditEnabled(true);
  });

  // ============================
  // å¤šé¸/ç¾¤çµ„æ‹–æ›³/å°é½Šï¼ˆå¿«æ·éµï¼‰
  //  - Ctrl/Meta+é»æ“Šï¼šåˆ‡æ›é¸å–
  //  - é»æ“Šç©ºç™½ï¼šæ¸…é™¤é¸å–
  //  - æ‹–æ›³ä»»ä¸€è¢«é¸å–çš„ labelï¼šæ•´çµ„ä¸€èµ·ç§»å‹•
  //  - L/R/T/Bï¼šå·¦/å³/ä¸Š/ä¸‹å°é½Š
  //  - H/Vï¼šæ°´å¹³/å‚ç›´å¹³å‡åˆ†ä½ˆ
  //  - æ–¹å‘éµï¼šå¾®èª¿ï¼ˆShift=10pxï¼‰
  // ============================
  const $doc = $(document);
  const SELECTED_CLASS = "md-selected";
  let dragGroupSnapshot = null;

    function $allFields() { return $(".draggable-field"); }
    function getLabelForField($field) {
      const fieldName = $field?.data("field");
      if (!fieldName) return $();
      return $(`.header-label-item[data-field="${fieldName}"]`).first();
    }
    function moveLabel($label, top, left) {
      if (!$label || !$label.length) return;
      $label.css({ position: "absolute", top: Math.max(0, top), left: Math.max(0, left) });
    }
  function $selected() { return $allFields().filter("." + SELECTED_CLASS); }
  function isTypingTarget(e) {
    const t = e?.target;
    if (!t) return false;
    const tag = (t.tagName || "").toLowerCase();
    return tag === "input" || tag === "textarea" || tag === "select" || t.isContentEditable;
  }
  function clearSelection() { $selected().removeClass(SELECTED_CLASS); }
  function toggleSelection($el) { $el.toggleClass(SELECTED_CLASS); }
  function selectOnly($el) { clearSelection(); $el.addClass(SELECTED_CLASS); }

  $doc.on("mousedown", ".field-drag-handle", function (e) {
    if (window.__DICT_OPEN__) return;
    const $field = $(this).closest(".draggable-field");
    if (!$field.length) return;

    if (e.ctrlKey || e.metaKey) {
      toggleSelection($field);
    } else if (!$field.hasClass(SELECTED_CLASS)) {
      selectOnly($field);
    }
  });
  $doc.on("mousedown", ".header-label-item", function (e) {
    if (window.__DICT_OPEN__) return;
    const fieldName = $(this).data("field");
    if (!fieldName) return;
    const $field = $(`.draggable-field[data-field="${fieldName}"]`).first();
    if (!$field.length) return;

    if (e.ctrlKey || e.metaKey) {
      toggleSelection($field);
    } else if (!$field.hasClass(SELECTED_CLASS)) {
      selectOnly($field);
    }
  });
  $doc.on("mousedown", function (e) {
    if (window.__DICT_OPEN__) return;
    if ($(e.target).closest(".draggable-field, .header-label-item, .ui-resizable-handle, .modal").length) return;
    clearSelection();
  });

  function ensureDragGroupSnapshot($base) {
    const $sel = $selected();
    const $group = ($sel.length ? $sel : $base);
    if (!$base.hasClass(SELECTED_CLASS) && $sel.length) selectOnly($base);
    dragGroupSnapshot = {
      baseEl: $base.get(0),
      baseTop: Math.round($base.position().top),
      baseLeft: Math.round($base.position().left),
      items: $group.toArray().map(el => {
        const $el = $(el);
        const $label = getLabelForField($el);
        const labelPos = $label.length ? $label.position() : null;
        return {
          el,
          top: Math.round($el.position().top),
          left: Math.round($el.position().left),
          labelEl: $label.get(0) || null,
          labelTop: labelPos ? Math.round(labelPos.top) : null,
          labelLeft: labelPos ? Math.round(labelPos.left) : null
        };
      })
    };
  }

    $allFields().each(function () {
      const $li = $(this);
      $li.draggable("option", "start", function () {
        if (window.__DICT_OPEN__) return;
        ensureDragGroupSnapshot($(this));
        $(this).hide();
      });
      $li.draggable("option", "drag", function (event, ui) {
        const $item = $(this);
        if (!dragGroupSnapshot || dragGroupSnapshot.baseEl !== $item.get(0)) return;
        const $parent = $item.parent();
        const parentOff = $parent.offset();
        if (!parentOff) return;
        const newTop = Math.round(ui.offset.top - parentOff.top);
        const newLeft = Math.round(ui.offset.left - parentOff.left);
        const dy = newTop - dragGroupSnapshot.baseTop;
        const dx = newLeft - dragGroupSnapshot.baseLeft;
        dragGroupSnapshot.items.forEach(it => {
          if (it.labelEl && it.labelTop != null && it.labelLeft != null) {
            moveLabel($(it.labelEl), it.labelTop + dy, it.labelLeft + dx);
          }
        });
      });
      $li.draggable("option", "stop", function (event, ui) {
        const $item = $(this);
        $item.show();

      const $parent = $item.parent();
      const parentOff = $parent.offset();
      if (!parentOff) return;

      const newTop = Math.round(ui.offset.top - parentOff.top);
      const newLeft = Math.round(ui.offset.left - parentOff.left);

        if (dragGroupSnapshot && dragGroupSnapshot.baseEl === $item.get(0)) {
          const dy = newTop - dragGroupSnapshot.baseTop;
          const dx = newLeft - dragGroupSnapshot.baseLeft;
          dragGroupSnapshot.items.forEach(it => {
            const $el = $(it.el);
            $el.css({
              position: "absolute",
              top: Math.max(0, it.top + dy),
              left: Math.max(0, it.left + dx)
            });
            if (it.labelEl && it.labelTop != null && it.labelLeft != null) {
              moveLabel($(it.labelEl), it.labelTop + dy, it.labelLeft + dx);
            }
          });
          dragGroupSnapshot = null;
          debounceSave();
          return;
        }

        const oldPos = $item.position();
        const dy = newTop - Math.round(oldPos.top);
        const dx = newLeft - Math.round(oldPos.left);
        $item.css({ position: "absolute", top: newTop, left: newLeft });
        const $label = getLabelForField($item);
        if ($label.length) {
          const labelPos = $label.position();
          moveLabel($label, Math.round(labelPos.top) + dy, Math.round(labelPos.left) + dx);
        }
        dragGroupSnapshot = null;
        debounceSave();
      });
    });

  function applyToSelected(mutator) {
    const $sel = $selected();
    if (!$sel.length) return false;
    $sel.each(function () { mutator($(this)); });
    debounceSave();
    return true;
  }
  function alignSelected(mode) {
    const $sel = $selected();
    if ($sel.length < 2) return false;
    const boxes = $sel.toArray().map(el => {
      const $el = $(el);
      const p = $el.position();
      const w = $el.outerWidth();
      const h = $el.outerHeight();
      const $ctrl = $el.find('select, input, textarea').first();
      const ctrlOff = $ctrl.length ? $ctrl.offset() : null;
      const elOff = $el.offset();
      const ctrlLeftAbs = ctrlOff?.left ?? elOff.left;
      const ctrlTopAbs = ctrlOff?.top ?? elOff.top;
      const ctrlW = $ctrl.length ? $ctrl.outerWidth() : w;
      const ctrlH = $ctrl.length ? $ctrl.outerHeight() : h;
      return {
        $el,
        top: Math.round(p.top),
        left: Math.round(p.left),
        right: Math.round(p.left + w),
        bottom: Math.round(p.top + h),
        w,
        h,
        ctrlLeftAbs,
        ctrlRightAbs: ctrlLeftAbs + ctrlW,
        ctrlTopAbs,
        ctrlBottomAbs: ctrlTopAbs + ctrlH,
        ctrlW,
        ctrlH
      };
    });
    const minCtrlLeftAbs = Math.min(...boxes.map(b => b.ctrlLeftAbs));
    const maxCtrlRightAbs = Math.max(...boxes.map(b => b.ctrlRightAbs));

    const minLeft = Math.min(...boxes.map(b => b.left));
    const maxRight = Math.max(...boxes.map(b => b.right));
    const minTop = Math.min(...boxes.map(b => b.top));
    const maxBottom = Math.max(...boxes.map(b => b.bottom));

    boxes.forEach(b => {
      if (mode === "L") {
        const delta = minCtrlLeftAbs - b.ctrlLeftAbs;
        b.$el.css("left", Math.max(0, Math.round(b.left + delta)));
      }
      if (mode === "R") {
        const targetCtrlLeftAbs = maxCtrlRightAbs - b.ctrlW;
        const delta = targetCtrlLeftAbs - b.ctrlLeftAbs;
        b.$el.css("left", Math.max(0, Math.round(b.left + delta)));
      }
      if (mode === "T") b.$el.css("top", minTop);
      if (mode === "B") b.$el.css("top", Math.max(0, maxBottom - b.h));
    });
    debounceSave();
    return true;
  }
  function distributeSelected(axis) {
    const $sel = $selected();
    if ($sel.length < 3) return false;
    const boxes = $sel.toArray().map(el => {
      const $el = $(el);
      const p = $el.position();
      const w = $el.outerWidth();
      const h = $el.outerHeight();
      return { $el, top: Math.round(p.top), left: Math.round(p.left), w, h };
    });
    if (axis === "H") {
      boxes.sort((a, b) => a.left - b.left);
      const first = boxes[0], last = boxes[boxes.length - 1];
      const span = (last.left - first.left);
      const gaps = boxes.length - 1;
      const step = gaps ? Math.round(span / gaps) : 0;
      boxes.forEach((b, i) => b.$el.css("left", Math.max(0, first.left + step * i)));
    } else {
      boxes.sort((a, b) => a.top - b.top);
      const first = boxes[0], last = boxes[boxes.length - 1];
      const span = (last.top - first.top);
      const gaps = boxes.length - 1;
      const step = gaps ? Math.round(span / gaps) : 0;
      boxes.forEach((b, i) => b.$el.css("top", Math.max(0, first.top + step * i)));
    }
    debounceSave();
    return true;
  }

  $doc.on("keydown", function (e) {
    if (window.__DICT_OPEN__) return;
    if (isTypingTarget(e)) return;
    const key = (e.key || "").toUpperCase();

    if (key === "L" || key === "R" || key === "T" || key === "B") {
      if (alignSelected(key)) { e.preventDefault(); return; }
    }
    if (key === "H" || key === "V") {
      if (distributeSelected(key)) { e.preventDefault(); return; }
    }

    const step = e.shiftKey ? 10 : 1;
    if (e.key === "ArrowLeft")  { if (applyToSelected($el => $el.css("left", Math.max(0, Math.round($el.position().left) - step)))) { e.preventDefault(); } return; }
    if (e.key === "ArrowRight") { if (applyToSelected($el => $el.css("left", Math.max(0, Math.round($el.position().left) + step)))) { e.preventDefault(); } return; }
    if (e.key === "ArrowUp")    { if (applyToSelected($el => $el.css("top",  Math.max(0, Math.round($el.position().top) - step)))) { e.preventDefault(); } return; }
    if (e.key === "ArrowDown")  { if (applyToSelected($el => $el.css("top",  Math.max(0, Math.round($el.position().top) + step)))) { e.preventDefault(); } return; }
  });

  $(".header-fields-tab").droppable({
    accept: ".draggable-field", tolerance: "pointer",
    over: function () { $(this).addClass("drop-hover"); },
    out:  function () { $(this).removeClass("drop-hover"); },
    drop: function (event, ui) {
      $(this).removeClass("drop-hover");
      const $zone = $(this), $item = $(ui.draggable);
      const newTabIndex = parseInt($zone.data("tab-index")) || 1;
      $item.appendTo($zone).attr("data-tab", newTabIndex).css({
        top: ui.offset.top - $zone.offset().top,
        left: ui.offset.left - $zone.offset().left,
        position: "absolute"
      });
      debounceSave();
    }
  });

  let dragTabSwitchTimer = null;
  $("#headerTabs button").droppable({
    accept: ".draggable-field",
    over: function () { const $tabBtn = $(this); dragTabSwitchTimer = setTimeout(() => { $tabBtn.trigger("click"); }, 600); },
    out:  function () { clearTimeout(dragTabSwitchTimer); }
  });

  function applyLookupDataLegacy(el, data, selected) {
    const $el = $(el);
    $el.empty().append('<option value="">--è«‹é¸æ“‡--</option>');
    (data || []).forEach(row => {
      const val = row.key;
      const label = Object.keys(row).filter(p => p.startsWith('result')).map(p => row[p]).join(' - ');
      const $opt = $('<option>').val(val).text(label);
      if (val == selected) $opt.attr('selected', true);
      $el.append($opt);
    });
    $el.next('.lookup-label').text($el.find('option:selected').text());
    if (el.classList.contains('lookup-readonly')) {
      el.dataset.lockedValue = el.value ?? '';
    }
  }

  function applyLookupData(el, data, selected) {
    const rows = data || [];
    const $el = $(el);
    if ($el.is('select')) {
      $el.empty().append('<option value="">--å‡ºéšè©³--</option>');
      rows.forEach(row => {
        const val = row.key;
        const label = Object.keys(row).filter(p => p.startsWith('result')).map(p => row[p]).join(' - ');
        const $opt = $('<option>').val(val).text(label);
        if (val == selected) $opt.attr('selected', true);
        $el.append($opt);
      });
      $el.next('.lookup-label').text($el.find('option:selected').text());
      if (el.classList.contains('lookup-readonly')) {
        el.dataset.lockedValue = el.value ?? '';
      }
      return;
    }

    const inputEl = el;
    const keyToLabel = {};
    const labelToKey = {};
    const items = [];
    rows.forEach(row => {
      const val = row.key;
      const label = Object.keys(row).filter(p => p.startsWith('result')).map(p => row[p]).join(' - ');
      const keyStr = val == null ? '' : String(val);
      keyToLabel[keyStr] = label;
      const normKey = normalizeLookupKey(keyStr);
      if (normKey && keyToLabel[normKey] == null) keyToLabel[normKey] = label;
      const display = formatLookupDisplay(keyStr, label);
      if (display) {
        labelToKey[display] = keyStr;
        const dispLower = normalizeLookupKey(display);
        if (dispLower && labelToKey[dispLower] == null) labelToKey[dispLower] = keyStr;
      }
      labelToKey[keyStr] = keyStr;
      if (normKey && labelToKey[normKey] == null) labelToKey[normKey] = keyStr;
      items.push({ key: keyStr, label });
    });

    inputEl._lookupKeyToLabel = keyToLabel;
    inputEl._lookupLabelToKey = labelToKey;
    inputEl._lookupItems = items;
    const initRaw = selected ?? '';
    const initMapped = mapLookupKey(initRaw, labelToKey);
    const initFallback = initRaw.split(' - ')[0] || initRaw;
    const initKey = (initMapped && initMapped !== initRaw) ? initMapped : initFallback;
    if (initKey !== '') inputEl.value = formatLookupDisplay(initKey, getLookupLabel(initKey, keyToLabel));
    const hidden = inputEl.closest('li')?.querySelector('input.lookup-key[name]');
    if (hidden) hidden.value = initKey;
    syncLookupLabel(inputEl);
    if (inputEl.classList.contains('lookup-readonly')) {
      inputEl.dataset.lockedValue = inputEl.value ?? '';
    }
    if (document.activeElement === inputEl || inputEl.dataset.forceOpen === '1' || activeLookupInput === inputEl) {
      const allowApply = !!(getHeaderEditState() && inputEl.dataset.readonly !== '1' && !inputEl.readOnly);
      openLookupDropdownForInput(inputEl, true, allowApply);
      delete inputEl.dataset.forceOpen;
    }
  }

  function loadLookupOptions(el) {
    if (!el || el.dataset.lookupLoading === '1') return;
    const table = (el.dataset.table || '').trim();
    const key = (el.dataset.key || '').trim();
    const result = (el.dataset.result || '').trim();
    if (!table || !key || !result) return;

    const cond1Field = (el.dataset.cond1Field || '').trim();
    const cond1Source = (el.dataset.cond1Source || '').trim();
    const cond2Field = (el.dataset.cond2Field || '').trim();
    const cond2Source = (el.dataset.cond2Source || '').trim();
    const cond1ValueField = cond1Source || cond1Field;
    const cond2ValueField = cond2Source || cond2Field;
    const cond1Value = cond1ValueField ? resolveCondValue(cond1ValueField) : '';
    const cond2Value = cond2ValueField ? resolveCondValue(cond2ValueField) : '';
    const cond1FieldParam = cond1Field || cond1Source;
    const cond2FieldParam = cond2Field || cond2Source;
    const condKey = `${cond1Field}:${cond1Value}|${cond2Field}:${cond2Value}`;
    if (el.dataset.lookupLoaded === '1' && el.dataset.lookupCondKey === condKey) return;

    el.dataset.lookupCondKey = condKey;
    el.dataset.lookupLoading = '1';
    const url = `/api/TableFieldLayout/LookupData?table=${encodeURIComponent(table)}&key=${encodeURIComponent(key)}&result=${encodeURIComponent(result)}`
      + (cond1FieldParam && cond1Value ? `&cond1Field=${encodeURIComponent(cond1FieldParam)}&cond1Value=${encodeURIComponent(cond1Value)}` : '')
      + (cond2FieldParam && cond2Value ? `&cond2Field=${encodeURIComponent(cond2FieldParam)}&cond2Value=${encodeURIComponent(cond2Value)}` : '');
    fetch(url)
      .then(r => r.ok ? r.json() : [])
      .then(data => {
        applyLookupData(el, data, el.dataset.selected);
        el.dataset.lookupLoaded = '1';
      })
      .catch(() => {})
      .finally(() => { delete el.dataset.lookupLoading; });
  }

  const LOOKUP_EMPTY_LABEL = '--è«‹é¸æ“‡--';
  let activeLookupList = null;
  let activeLookupInput = null;

  function normalizeLookupText(value) {
    return (value ?? '').toString().trim().toLowerCase();
  }

  function normalizeLookupKey(value) {
    return (value ?? '').toString().trim().toLowerCase();
  }

  function resolveCondValue(fieldOrLabel) {
    const key = (fieldOrLabel || '').toString().trim();
    if (!key) return '';
    const direct = readHeaderValue(key);
    if (direct) return direct;
    const labelEl = Array.from(document.querySelectorAll('.header-label-item'))
      .find(el => (el.textContent || '').trim() === key);
    const field = labelEl?.getAttribute('data-field') || '';
    if (!field) return '';
    return readHeaderValue(field);
  }

  function getLookupLabel(key, keyToLabel) {
    if (!key || !keyToLabel) return '';
    if (keyToLabel[key] != null) return keyToLabel[key];
    const lower = normalizeLookupKey(key);
    return lower && keyToLabel[lower] != null ? keyToLabel[lower] : '';
  }

  function mapLookupKey(raw, labelToKey) {
    if (!raw || !labelToKey) return raw ?? '';
    if (labelToKey[raw] != null) return labelToKey[raw];
    const lower = normalizeLookupKey(raw);
    return lower && labelToKey[lower] != null ? labelToKey[lower] : raw;
  }

  function getLookupKeyFromInput(input) {
    const raw = (input?.value ?? '').toString().trim();
    if (!raw) return '';
    return raw.split(' - ')[0];
  }

  function buildLookupListForInput(input, showAll = false) {
    const list = document.createElement('div');
    list.className = 'lookup-dropdown-list';
    const items = Array.isArray(input?._lookupItems) ? input._lookupItems : [];
    const currentKey =
      input?.closest('li')?.querySelector('input.lookup-key[name]')?.value ??
      getLookupKeyFromInput(input);
    const filter = showAll ? '' : normalizeLookupText(input?.value ?? '');

    const addItem = (key, label) => {
      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'lookup-dropdown-item';
      item.dataset.key = key == null ? '' : String(key);
      item.textContent = formatLookupDisplay(key, label) || String(key ?? '');
      if ((currentKey ?? '') === (key ?? '')) item.classList.add('is-selected');
      list.appendChild(item);
    };

    addItem('', LOOKUP_EMPTY_LABEL);
    items.forEach(it => {
      const key = it?.key ?? '';
      const label = it?.label ?? '';
      const display = formatLookupDisplay(key, label);
      if (filter) {
        const f = normalizeLookupText(filter);
        const match =
          normalizeLookupText(key).includes(f) ||
          normalizeLookupText(label).includes(f) ||
          normalizeLookupText(display).includes(f);
        if (!match) return;
      }
      addItem(key, label);
    });
    return list;
  }

  function positionDropdown(list, anchor) {
    if (!list || !anchor) return;
    const rect = anchor.getBoundingClientRect();
    const spaceBelow = window.innerHeight - rect.bottom;
    const maxHeight = Math.max(140, Math.min(260, spaceBelow - 8));
    const placeBelow = spaceBelow >= 140;
    list.style.position = 'fixed';
    list.style.left = `${Math.max(6, rect.left)}px`;
    list.style.top = placeBelow ? `${rect.bottom}px` : `${Math.max(6, rect.top - maxHeight)}px`;
    list.style.minWidth = `${Math.max(120, rect.width)}px`;
    list.style.maxHeight = `${maxHeight}px`;
  }

  function closeLookupDropdown() {
    if (activeLookupList) activeLookupList.remove();
    activeLookupList = null;
    activeLookupInput = null;
    document.removeEventListener('mousedown', onLookupDocDown, true);
    document.removeEventListener('pointerdown', onLookupDocDown, true);
    document.removeEventListener('click', onLookupDocDown, true);
    document.removeEventListener('focusin', onLookupFocusIn, true);
    document.removeEventListener('keydown', onLookupKeydown, true);
    window.removeEventListener('resize', onLookupResize, true);
  }

  function onLookupDocDown(e) {
    if (activeLookupList && activeLookupList.contains(e.target)) return;
    if (activeLookupInput && activeLookupInput.contains(e.target)) return;
    closeLookupDropdown();
  }

  function onLookupFocusIn(e) {
    if (activeLookupList && activeLookupList.contains(e.target)) return;
    if (activeLookupInput && activeLookupInput.contains(e.target)) return;
    closeLookupDropdown();
  }

  function onLookupKeydown(e) {
    if (e.key !== 'Escape') return;
    closeLookupDropdown();
  }

  function onLookupResize() {
    closeLookupDropdown();
  }

  function openLookupDropdownForInput(input, showAll = false, allowApply = true) {
    if (!input) return;
    const items = Array.isArray(input._lookupItems) ? input._lookupItems : [];

    closeLookupDropdown();

    const list = buildLookupListForInput(input, showAll);
    activeLookupList = list;
    activeLookupInput = input;

    const onPick = (e) => {
      const item = e.target.closest('.lookup-dropdown-item');
      if (!item) return;
      e.preventDefault();
      e.stopPropagation();
      if (!allowApply) { closeLookupDropdown(); return; }
      const key = item.dataset.key ?? '';
      const label = getLookupLabel(key, input._lookupKeyToLabel || {});
      input.value = key ? formatLookupDisplay(key, label) : '';
      const hidden = input.closest('li')?.querySelector('input.lookup-key[name]');
      if (hidden) hidden.value = key;
      input.dataset.selected = key ?? '';
      syncLookupLabel(input);
      try {
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      } catch {}
      if (input.closest('.erp-header-form') && typeof window.__autoSaveHeader === 'function') {
        window.__autoSaveHeader();
      }
      closeLookupDropdown();
    };

    list.addEventListener('pointerdown', onPick);
    list.addEventListener('mousedown', onPick);
    list.addEventListener('click', onPick);

    document.body.appendChild(list);
    positionDropdown(list, input);
    document.addEventListener('mousedown', onLookupDocDown, true);
    document.addEventListener('pointerdown', onLookupDocDown, true);
    document.addEventListener('click', onLookupDocDown, true);
    document.addEventListener('focusin', onLookupFocusIn, true);
    document.addEventListener('keydown', onLookupKeydown, true);
    window.addEventListener('resize', onLookupResize, true);
  }

  $('.lookup-dropdown').each(function() {
    const el = this;
    loadLookupOptions(el);
    if (el.tagName && el.tagName.toLowerCase() === 'select') {
      $(el).on('change', function() {
        $(this).next('.lookup-label').text($(this).find('option:selected').text());
      });
      $(el).on('focus', function() {
        loadLookupOptions(this);
      });
    } else {
      $(el).on('input change', function() {
        syncLookupLabel(this);
        if (activeLookupInput === this) {
          const allowApply = !!(getHeaderEditState() && this.dataset.readonly !== '1' && !this.readOnly);
          openLookupDropdownForInput(this, false, allowApply);
        }
      });
      $(el).on('focus', function() {
        loadLookupOptions(this);
        try {
          const map = this._lookupLabelToKey || {};
        const key = window.safeMapLookupKey(this.value, map);
          if (key) this.value = key;
          const len = (this.value || '').length;
          if (len) this.setSelectionRange(0, len);
          else this.select();
        } catch { }
      });
      $(el).on('blur', function() {
        const keyToLabel = this._lookupKeyToLabel || {};
        const raw = (this.value || '').trim();
        if (!raw) return;
        const key = window.safeMapLookupKey(raw, this._lookupLabelToKey || {});
        const label = getLookupLabel(key, keyToLabel);
        if (label) {
          this.value = formatLookupDisplay(key, label);
          syncLookupLabel(this);
        }
        setTimeout(() => {
          if (activeLookupInput === this) closeLookupDropdown();
        }, 0);
      });
      $(el).siblings('.lookup-toggle').on('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const inputEl = $(this).siblings('input.lookup-dropdown')[0];
        if (!inputEl) return;
        inputEl.dataset.forceOpen = '1';
        try { inputEl.focus(); } catch {}
        loadLookupOptions(inputEl);
        const allowApply = !!(getHeaderEditState() && inputEl.dataset.readonly !== '1' && !inputEl.readOnly);
        openLookupDropdownForInput(inputEl, true, allowApply);
      });
      $(el).on('keydown', function(e) {
        if (e.key !== 'Backspace' && e.key !== 'Delete') return;
        if (this.readOnly) return;
        if (!this.value) return;
        const init = this.dataset.init ?? this.dataset.selected ?? '';
        const start = this.selectionStart ?? 0;
        const end = this.selectionEnd ?? 0;
        const allSelected = start === 0 && end === this.value.length;
        const rawKey = String(this.value ?? '').split(' - ')[0];
        const unchanged = rawKey === String(init ?? '');
        if (allSelected || unchanged) {
          this.value = '';
          syncLookupLabel(this);
          e.preventDefault();
        }
      });
    }
  });

  const normalizeDateForPicker = (value) => {
    const s = String(value ?? '').trim();
    if (!s) return '';
    const m = s.match(/^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})/);
    if (m) return `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`;
    const d = new Date(s);
    if (isNaN(d)) return '';
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
  };

  const formatDateForDisplay = (ymd) => {
    const m = String(ymd ?? '').match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return '';
    return `${m[1]}/${m[2]}/${m[3]}`;
  };

  $('.date-dropdown').each(function() {
    const textInput = this;
    const dateInput = $(this).siblings('input.date-picker-input')[0];
    if (!dateInput) return;
    const normalized = normalizeDateForPicker(textInput.value);
    if (normalized) dateInput.value = normalized;

    $(dateInput).on('change', function() {
      if (!this.value) return;
      textInput.value = formatDateForDisplay(this.value) || this.value;
      try {
        textInput.dispatchEvent(new Event('input', { bubbles: true }));
        textInput.dispatchEvent(new Event('change', { bubbles: true }));
      } catch { }
    });

    $(textInput).on('input change', function() {
      const v = normalizeDateForPicker(this.value);
      if (v) dateInput.value = v;
    });

    $(textInput).siblings('.date-toggle').on('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      if (!getHeaderEditState() || textInput.dataset.readonly === '1' || textInput.readOnly) return;
      if (typeof dateInput.showPicker === 'function') {
        dateInput.showPicker();
      } else {
        dateInput.focus();
        dateInput.click();
      }
    });
  });

  function setInitialTabHeights(offsetPx = 4) {
    const hiddenTabs = $(".tab-pane").not(".show");
    hiddenTabs.addClass("tmp-show").addClass("show").css("display", "block");
    $(".header-fields-tab").each(function () {
      let maxBottom = 0;
      $(this).children(".draggable-field").each(function () {
        const $el = $(this);
        maxBottom = Math.max(maxBottom, $el.position().top + $el.outerHeight());
      });
      $(this).height(Math.max(0, Math.ceil(maxBottom + offsetPx)));
    });
    hiddenTabs.removeClass("show tmp-show").css("display", "");
  }
  requestAnimationFrame(() => setInitialTabHeights(4));
});

// SHIFT é¡¯ç¤ºç¸®æ”¾æŠŠæ‰‹
document.addEventListener('keydown', (e) => {
  if (e.key !== 'Shift') return;
  document.body.classList.add('shift-resize');
});
document.addEventListener('keyup', (e) => {
  if (e.key !== 'Shift') return;
  document.body.classList.remove('shift-resize');
});

// ============================
// ç¬¬ä¸€ç­† / ä¸Šä¸€ç­† / ä¸‹ä¸€ç­† / æœ€å¾Œä¸€ç­†
// ============================
const NAV_BTN_FIRST = document.getElementById('btnFirst');
const NAV_BTN_PREV = document.getElementById('btnPrev');
const NAV_BTN_NEXT = document.getElementById('btnNext');
const NAV_BTN_LAST = document.getElementById('btnLast');
let navIds = [], navIndex = -1;
const headerCountEl = document.getElementById('toolbarHeaderCount');
const detailCountEl = document.getElementById('toolbarDetailCount');

function loadLastFilters() {
  try {
    const tn = (PAGE.headerTable || '').toString().trim().toLowerCase();
    const fk = tn ? `orderListQueryFilters:${tn}` : "orderListQueryFilters";
    const s1 = localStorage.getItem(fk);
    if (s1) return JSON.parse(s1);

    // legacy: only accept global filters if they were saved for the same table
    const legacyTable = (localStorage.getItem("orderListQueryTable") || '').toLowerCase();
    const s2 = legacyTable === tn ? localStorage.getItem("orderListQueryFilters") : null;
    return s2 ? JSON.parse(s2) : [];
  }
  catch { return []; }
}
function getDetailBasePath() { return location.pathname.replace(/\/[^\/]+$/, "/"); }
function gotoPaper(pn) { if (!pn) return; localStorage.setItem("lastViewedPaperNum", pn); location.href = getDetailBasePath() + pn; }
function updateNavButtons() {
  const hasFirst = navIndex > 0;
  const hasPrev = navIndex > 0;
  const hasNext = navIndex >= 0 && navIndex < navIds.length - 1;
  const hasLast = navIndex >= 0 && navIndex < navIds.length - 1;
  if (NAV_BTN_FIRST) {
    NAV_BTN_FIRST.disabled = !hasFirst;
    NAV_BTN_FIRST.onclick = () => hasFirst && gotoPaper(navIds[0]);
  }
  if (NAV_BTN_PREV) {
    NAV_BTN_PREV.disabled = !hasPrev;
    NAV_BTN_PREV.onclick = () => hasPrev && gotoPaper(navIds[navIndex - 1]);
  }
  if (NAV_BTN_NEXT) {
    NAV_BTN_NEXT.disabled = !hasNext;
    NAV_BTN_NEXT.onclick = () => hasNext && gotoPaper(navIds[navIndex + 1]);
  }
  if (NAV_BTN_LAST) {
    NAV_BTN_LAST.disabled = !hasLast;
    NAV_BTN_LAST.onclick = () => hasLast && gotoPaper(navIds[navIds.length - 1]);
  }
  updateToolbarCounts();
}
async function fetchIdListByPagedQuery(filters) {
  const fs = [...(filters || []), {Field:"page",Op:"",Value:"1"}, {Field:"pageSize",Op:"",Value:"999999"}];
  const res = await fetch('/api/PagedQuery/PagedQuery', {
    method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ table: PAGE.headerTable, filters: fs })
  });
  const json = await res.json();
  const rows = Array.isArray(json.data) ? json.data : [];
  return rows.map(r => r[PAGE.keyField]).filter(Boolean);
}
async function fetchIdListByDynamicTable(filters) {
  const fs = [...(filters || []), { Field: "page", Op: "", Value: "1" }, { Field: "pageSize", Op: "", Value: "999999" }];
  const itemId = (window._itemId || window._singleItemId || '').toString().trim();
  const res = await fetch('/api/DynamicTable/PagedQuery', {
    method: 'POST', headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ table: PAGE.headerTable, itemId, filters: fs })
  });
  if (!res.ok) throw new Error('DynamicTable/PagedQuery failed');
  const json = await res.json();
  const rows = Array.isArray(json.data) ? json.data : [];
  return rows.map(r => (r?.[PAGE.keyField] ?? r?.[PAGE.keyField?.toLowerCase?.()]))
    .filter(Boolean)
    .map(x => x.toString());
}
async function initRowNavigation() {
  try {
    const filters = loadLastFilters();
    // ä¾åºå˜—è©¦ï¼šIdListï¼ˆè‹¥æœ‰ï¼‰â†’ PagedQueryï¼ˆEF DbSetï¼‰â†’ DynamicTableï¼ˆSQL å‹•æ…‹æŸ¥è©¢ï¼Œæœ€é€šç”¨ï¼‰
    try { navIds = await fetchIdListByApi(filters); }
    catch {
      try { navIds = await fetchIdListByPagedQuery(filters); }
      catch { navIds = await fetchIdListByDynamicTable(filters); }
    }
    const cur = (PAGE.paperNum || '').toString().trim().toLowerCase();
    navIndex = navIds.findIndex(x => (x || '').toString().trim().toLowerCase() === cur);
    updateNavButtons();
  } catch {
    if (NAV_BTN_FIRST) NAV_BTN_FIRST.disabled = true;
    if (NAV_BTN_PREV) NAV_BTN_PREV.disabled = true;
    if (NAV_BTN_NEXT) NAV_BTN_NEXT.disabled = true;
    if (NAV_BTN_LAST) NAV_BTN_LAST.disabled = true;
  }
}
initRowNavigation();

function getActiveDetailRowStats() {
  const activePane = document.querySelector('.multi-tab-detail .tab-pane.show.active');
  if (!activePane) return { index: 0, total: 0 };
  const tbody = activePane.querySelector('tbody');
  if (!tbody) return { index: 0, total: 0 };
  const rows = Array.from(tbody.querySelectorAll('tr'))
    .filter(tr => (tr.dataset.state || '').toString().toLowerCase() !== 'empty');
  const total = rows.length;
  if (!total) return { index: 0, total: 0 };
  const selected = tbody.querySelector('tr.row-selected');
  const idx = selected ? rows.indexOf(selected) + 1 : 1;
  return { index: idx, total };
}

function updateToolbarCounts() {
  if (headerCountEl) {
    const total = navIds.length;
    if (total > 0 && navIndex >= 0) {
      headerCountEl.textContent = `${navIndex + 1}/${total}`;
    } else {
      const tn = (PAGE.headerTable || '').toString().trim().toLowerCase();
      let storedTotal = 0;
      let storedIndex = 0;
      try {
        storedTotal = parseInt(localStorage.getItem(`orderListQueryTotal:${tn}`) || '0', 10);
        storedIndex = parseInt(localStorage.getItem(`orderListQueryIndex:${tn}`) || '0', 10);
      } catch {}
      if (storedTotal > 0) {
        const idxText = storedIndex > 0 ? String(storedIndex) : '--';
        headerCountEl.textContent = `${idxText}/${storedTotal}`;
      } else {
        headerCountEl.textContent = '--/--';
      }
    }
  }
  if (detailCountEl) {
    const stats = getActiveDetailRowStats();
    detailCountEl.textContent = stats.total > 0 ? `${stats.index}/${stats.total}` : '--/--';
  }
}

window.__updateToolbarCounts = updateToolbarCounts;

// ============================
// å›ºå®šå·¥å…·åˆ—ï¼šç¬¬äºŒ/ç¬¬ä¸‰éšæ–°å¢åˆªæ¸›
// ============================
(function wireSubDetailToolbar() {
  const btnAdd = document.getElementById('btnSubDetailAdd');
  const btnDel = document.getElementById('btnSubDetailDelete');
  if (!btnAdd && !btnDel) return;
  btnAdd?.classList.remove('d-none');
  btnDel?.classList.remove('d-none');
  const root = document.querySelector('.mmd-wrapper');

  const pickApi = () => {
    const domId = root?.id;
    if (domId && window._mmdApi?.[domId]) return window._mmdApi[domId];
    const keys = Object.keys(window._mmdApi || {});
    return keys.length ? window._mmdApi[keys[0]] : null;
  };

  const warn = (msg) => {
    if (window.Swal?.fire) Swal.fire({ icon: 'info', title: msg });
    else alert(msg);
  };

  const clickMultiTabAction = (kind) => {
    const selector = kind === 'add' ? '.btn-add-row' : '.btn-delete-row';
    const activePane = document.querySelector('.multi-tab-detail .tab-pane.active');
    const scope = activePane || document.querySelector('.multi-tab-detail');
    if (!scope) return { ok: false, reason: 'no-multitab' };
    const btn = scope.querySelector(selector) || document.querySelector(`.multi-tab-detail ${selector}`);
    if (!btn) return { ok: false, reason: 'no-button' };
    btn.click();
    return { ok: true };
  };

  const getActiveMultiTabCtx = () => {
    const activePane = document.querySelector('.multi-tab-detail .tab-pane.active');
    if (!activePane) return null;
    const navBtn = document.querySelector('.multi-tab-detail .nav-link.active[data-api-url]');
    const apiUrl = navBtn?.dataset?.apiUrl || '';
    const tbody = activePane.querySelector('tbody');
    let selectedRow = tbody?.querySelector('tr.row-selected') || null;
    if (!selectedRow) {
      const focusTr = document.activeElement?.closest?.('.multi-tab-detail tbody tr');
      if (focusTr && tbody?.contains(focusTr)) selectedRow = focusTr;
    }
    return { activePane, apiUrl, tbody, selectedRow };
  };

  const detailDefaultsCache = {};

  const escAttr = (v) => String(v ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');

  const getDetailDefaults = async (table) => {
    const key = (table || '').toString().toLowerCase();
    if (!key) return {};
    if (detailDefaultsCache[key]) return detailDefaultsCache[key];
    const url = `/api/OrderHeaderApi/DetailDefaults?table=${encodeURIComponent(table)}`;
    const res = await fetch(url);
    if (!res.ok) return {};
    const data = await res.json();
    const defs = data?.defaults || {};
    detailDefaultsCache[key] = defs;
    return defs;
  };

  function isMultiTabBlankRow(tr, fields) {
    if (!tr) return false;
    const inputs = Array.from(tr.querySelectorAll('.cell-edit[data-field]'));
    if (!inputs.length) return false;
    let hasValue = false;
    inputs.forEach(inp => {
      const f = (inp.dataset.field || '').toString().toLowerCase();
      if (f === 'papernum' || f === 'item') return;
      const val = (inp.value ?? '').toString().trim();
      if (val === '') return;
      if (/^[-â€“â€”]+$/.test(val)) return;
      const num = Number(val);
      if (Number.isFinite(num) && num === 0) return;
      hasValue = true;
    });
    return !hasValue;
  }

  const addMultiTabBlankRow = async () => {
    const ctx = getActiveMultiTabCtx();
    if (!ctx || !ctx.tbody) return { ok: false, reason: 'no-multitab' };
    const { activePane, tbody } = ctx;
    const table = activePane.querySelector('table.erp-table');
    const headerCells = Array.from(table?.querySelectorAll('thead th') || []);
    const fields = headerCells
      .map(th => (th.dataset.field || '').toString())
      .filter(Boolean);
    if (!fields.length) return { ok: false, reason: 'no-fields' };
    const alignMap = new Map(headerCells.map(th => {
      const key = (th.dataset.field || '').toString().toLowerCase();
      const alignClass = th.classList.contains('align-right') ? 'align-right' : 'align-left';
      return [key, alignClass];
    }));

    const dictTable = activePane?.querySelector?.('.table-container')?.dataset?.dictTable || '';
    const safeTable = (dictTable || '').toString().replace(/^dbo\./i, '').trim();
    const defaults = safeTable ? await getDetailDefaults(safeTable) : {};
    const readOnlyMap = safeTable && window._detailFieldReadOnlyMap
      ? (window._detailFieldReadOnlyMap[safeTable.toLowerCase()] || {})
      : {};

    let maxItem = 0;
    tbody.querySelectorAll('tr').forEach(tr => {
      const n = parseInt(tr.dataset.item || '', 10);
      if (!isNaN(n) && n > maxItem) maxItem = n;
    });
    const newItem = maxItem + 1;
    const pn = (getPaperNum() || '').trim();

    const isEditing = !!document.querySelector('.multi-tab-detail .cell-edit:not(.d-none)');
    const viewClass = isEditing ? 'cell-view d-none' : 'cell-view';
    const editClass = isEditing ? 'cell-edit' : 'cell-edit d-none';

    const pendingRow = tbody.querySelector('tr[data-state="added"]');
    const blankRow = pendingRow || Array.from(tbody.querySelectorAll('tr')).find(tr => isMultiTabBlankRow(tr, fields));
    if (blankRow) {
      tbody.querySelectorAll('tr.row-selected').forEach(r => r.classList.remove('row-selected'));
      blankRow.classList.add('row-selected');
      blankRow.dataset.state = 'added';
      if (!blankRow.dataset.paperNum) blankRow.dataset.paperNum = pn;
      if (!blankRow.dataset.item) blankRow.dataset.item = String(newItem);
      blankRow.querySelectorAll('.cell-view').forEach(el => el.classList.add('d-none'));
      blankRow.querySelectorAll('.cell-edit').forEach(el => el.classList.remove('d-none'));
      const first = blankRow.querySelector('.cell-edit');
      first?.focus();
      if (typeof window.__updateToolbarCounts === 'function') window.__updateToolbarCounts();
      return { ok: true, reused: true };
    }
    let html = `<tr data-paper-num="${pn}" data-item="${newItem}" data-state="added" class="row-selected">`;
      fields.forEach(field => {
        const fieldKey = (field || '').toString().toLowerCase();
        const isReadOnly = !!readOnlyMap[fieldKey];
        const roClass = isReadOnly ? ' readonly-cell' : '';
        const roAttr = isReadOnly ? ' data-readonly="1" readonly' : ' data-readonly="0"';
        const defVal = (defaults && Object.prototype.hasOwnProperty.call(defaults, field)) ? defaults[field] : '';
        const value = defVal == null ? '' : String(defVal);
        const safeValue = escAttr(value);
        const alignClass = alignMap.get(fieldKey) || 'align-left';
        html += `<td class="${alignClass}" data-readonly="${isReadOnly ? '1' : '0'}">
          <span class="${viewClass}${roClass}" data-init-view="${safeValue}" data-readonly="${isReadOnly ? '1' : '0'}">${safeValue}</span>
          <input type="text" class="${editClass}${roClass}" data-field="${field}" data-init="${safeValue}" value="${safeValue}"${roAttr}>
        </td>`;
      });
    html += '</tr>';

    tbody.querySelectorAll('tr.row-selected').forEach(r => r.classList.remove('row-selected'));
    tbody.insertAdjacentHTML('beforeend', html);
    const newRow = tbody.querySelector('tr:last-child');
    if (newRow) {
      const firstInput = newRow.querySelector('input.cell-edit');
      if (firstInput) {
        try { firstInput.focus(); } catch {}
      }
    }
    if (typeof window.__updateToolbarCounts === 'function') window.__updateToolbarCounts();
    return { ok: true };
  };

  const deleteMultiTabSelectedRow = async () => {
    const ctx = getActiveMultiTabCtx();
    if (!ctx || !ctx.tbody) return { ok: false, reason: 'no-multitab' };
    const { apiUrl, selectedRow, tbody, activePane } = ctx;
    if (!selectedRow) return { ok: false, reason: 'no-row' };

    const paperNum = selectedRow.dataset.paperNum || '';
    const item = selectedRow.dataset.item || '';
    const state = selectedRow.dataset.state || '';

    const { isConfirmed } = await Swal.fire({
      icon: 'question',
      title: 'ç¢ºå®šè¦åˆªé™¤é€™ä¸€ç­†æ˜ç´°ï¼Ÿ',
      text: `é …æ¬¡ï¼š${item}`,
      showCancelButton: true,
      confirmButtonText: 'åˆªé™¤',
      cancelButtonText: 'å–æ¶ˆ',
      confirmButtonColor: '#dc3545'
    });
    if (!isConfirmed) return { ok: true, canceled: true };

    if (state === 'added') {
      const next = selectedRow.nextElementSibling || selectedRow.previousElementSibling;
      selectedRow.remove();
      if (next) next.classList.add('row-selected');
      if (typeof window.__updateToolbarCounts === 'function') window.__updateToolbarCounts();
      return { ok: true };
    }

    const dictTable = activePane?.querySelector?.('.table-container')?.dataset?.dictTable || '';
    const safeTable = (dictTable || '').toString().replace(/^dbo\./i, '').trim();
    if (!safeTable) return { ok: false, reason: 'no-table' };

    const deleteUrl = `/api/OrderHeaderApi/DeleteRow?table=${encodeURIComponent(safeTable)}&paperNum=${encodeURIComponent(paperNum)}&item=${encodeURIComponent(item)}`;
    const response = await fetch(deleteUrl, { method: 'DELETE' });
    if (!response.ok) {
      let errorMessage = `HTTP ${response.status}`;
      try {
        const errorData = await response.json();
        if (errorData && errorData.error) errorMessage = errorData.error;
      } catch {
        try {
          const errorText = await response.text();
          if (errorText) errorMessage = errorText;
        } catch {}
      }
      return { ok: false, reason: 'delete-failed', error: errorMessage };
    }

    const next = selectedRow.nextElementSibling || selectedRow.previousElementSibling;
    selectedRow.remove();
    if (next) next.classList.add('row-selected');
    if (typeof window.__updateToolbarCounts === 'function') window.__updateToolbarCounts();
    return { ok: true };
  };

  const tryAddPaper3L = () => {
    if (typeof window.__paper3lSubDetailAddRow !== 'function') return { handled: false };
    if (window.__activeDetailGrid !== 'paper3l') return { handled: false };
    try {
      const res = window.__paper3lSubDetailAddRow();
      return res && typeof res === 'object' ? res : { handled: false };
    } catch (err) {
      return { handled: true, ok: false, reason: 'add-failed', error: err?.message || String(err) };
    }
  };

  btnAdd?.addEventListener('click', async () => {
    const api = pickApi();
    if (api?.addSubDetailRow) {
      api.addSubDetailRow();
      return;
    }
    const r3 = tryAddPaper3L();
    if (r3?.handled) {
      if (r3?.ok) return;
      if (r3?.reason === 'add-failed') return warn(`æ–°å¢å¤±æ•—ï¼š${r3.error || ''}`.trim());
      return;
    }
    const r = await addMultiTabBlankRow();
    if (!r.ok) {
      warn(r.reason === 'no-fields' ? 'æ‰¾ä¸åˆ°æ˜ç´°æ¬„ä½' : 'è«‹å…ˆåˆ‡åˆ°æ˜ç´°åˆ†é å†æ–°å¢');
    }
  });

  const tryDeletePaper3L = async () => {
    if (typeof window.__paper3lSubDetailDeleteRow !== 'function') return { handled: false };
    if (window.__activeDetailGrid !== 'paper3l') return { handled: false };
    try {
      const res = await window.__paper3lSubDetailDeleteRow();
      return res && typeof res === 'object' ? res : { handled: false };
    } catch (err) {
      return { handled: true, ok: false, reason: 'delete-failed', error: err?.message || String(err) };
    }
  };

  btnDel?.addEventListener('click', async () => {
    const api = pickApi();
    if (api?.deleteSubDetailRow) {
      api.deleteSubDetailRow();
      return;
    }
    const r3 = await tryDeletePaper3L();
    if (r3?.handled) {
      if (r3?.ok || r3?.canceled) return;
      if (r3?.reason === 'no-row') return warn('è«‹å…ˆé¸å–åˆ—å†åˆªé™¤');
      if (r3?.reason === 'no-keys') return warn('æ‰¾ä¸åˆ°ç¬¬ä¸‰éšéµæ¬„ä½');
      if (r3?.reason === 'delete-failed') return warn(`åˆªé™¤å¤±æ•—ï¼š${r3.error || ''}`.trim());
      return;
    }
    const r = await deleteMultiTabSelectedRow();
    if (r?.ok) return;
    if (r?.reason === 'no-row') return warn('è«‹å…ˆé¸å–åˆ—å†åˆªé™¤');
    if (r?.reason === 'no-table') return warn('æ‰¾ä¸åˆ°æ˜ç´°è¡¨è¨­å®š');
    if (r?.reason === 'delete-failed') return warn(`åˆªé™¤å¤±æ•—ï¼š${r.error || ''}`.trim());
    const k = clickMultiTabAction('delete');
    if (!k.ok) warn(k.reason === 'no-button' ? 'è«‹å…ˆåˆ‡åˆ°æ˜ç´°åˆ†é ä¸¦é¸å–åˆ—å†åˆªé™¤' : 'æ‰¾ä¸åˆ°æ˜ç´°æŒ‰éˆ•æ§åˆ¶å™¨');
  });
})();

// ============================
// å…¶ä»–ï¼šæŠŠæœ€å¾Œæª¢è¦–çš„å–®è™Ÿå­˜åœ¨ localStorage
// ============================
localStorage.setItem("lastViewedPaperNum", window.selectedPaperNum);
function getHeaderValueByLabel(labelText) {
  const labelEl = Array.from(document.querySelectorAll('.header-label-item'))
    .find(el => (el.textContent || '').trim() === labelText);
  if (!labelEl) return '';
  const fieldName = labelEl.getAttribute('data-field') || '';
  if (!fieldName) return '';
  const li = document.querySelector(`.draggable-field[data-field="${CSS.escape(fieldName)}"]`);
  if (!li) return '';
  const ctrl = li.querySelector('select, input, textarea');
  if (!ctrl) return '';
  if (ctrl.tagName.toLowerCase() === 'select') {
    const opt = ctrl.options[ctrl.selectedIndex];
    return (opt?.text || opt?.value || '').trim();
  }
  return (ctrl.value || '').trim();
}

// æœªå„²å­˜æ——æ¨™
  function formatLookupDisplay(code, label) {
    if (!code) return "";
    const c = String(code);
    const l = label == null ? "" : String(label);
    if (!l) return c;
    if (l === c) return c;
    const cLower = c.toLowerCase();
    const lLower = l.toLowerCase();
    if (lLower === cLower) return l;
    if (lLower.startsWith(cLower + " - ") || lLower.startsWith(cLower + "-") || lLower.startsWith(cLower + " ")) return l;
    return `${c} - ${l}`;
  }

  function syncLookupLabel(selectEl) {
    if (!selectEl) return;
    const label = selectEl.nextElementSibling;
    if (selectEl instanceof HTMLSelectElement) {
      if (label && label.classList.contains('lookup-label')) {
        const text = selectEl.options[selectEl.selectedIndex]?.text ?? '';
        label.textContent = text;
      }
      return;
    }
  if (selectEl instanceof HTMLInputElement) {
    const keyToLabel = selectEl._lookupKeyToLabel || {};
    const labelToKey = selectEl._lookupLabelToKey || {};
    const raw = selectEl.value ?? '';
    const mapped = window.safeMapLookupKey(raw, labelToKey);
    const fallback = raw.split(' - ')[0] || raw;
    const key = (mapped && mapped !== raw) ? mapped : fallback;
    const labelText = getLookupLabel(key, keyToLabel);
    const display = formatLookupDisplay(key, labelText);
    if (labelText && raw !== display) {
      selectEl.value = display;
    }
    if (label && label.classList.contains('lookup-label')) {
      label.textContent = display || raw;
    }
    const hidden = selectEl.closest('li')?.querySelector('input.lookup-key[name]');
    if (hidden) hidden.value = raw === '' ? '' : key;
    selectEl.dataset.selected = key ?? '';
  }
}

  function captureHeaderInitValues() {
    document.querySelectorAll('.erp-header-form input, .erp-header-form textarea, .erp-header-form select')
      .forEach(el => {
        if (el.closest('.modal')) return;
        if (el.dataset.init != null) return;
        if (el.type === 'checkbox') {
          el.dataset.init = el.checked ? '1' : '0';
        } else {
          el.dataset.init = el.value ?? '';
        }
      });
  }

  function resetHeaderForm() {
    document.querySelectorAll('.erp-header-form input, .erp-header-form textarea, .erp-header-form select')
      .forEach(el => {
        if (el.closest('.modal')) return;
        const init = el.dataset.init ?? '';
        if (el.type === 'checkbox') {
          el.checked = init === '1' || init.toLowerCase?.() === 'true';
        } else {
          el.value = init;
        }
        if (el.matches('.lookup-dropdown')) syncLookupLabel(el);
      });
  }

  window.__unsavedChanges = false;

  // æ›´æ–°å‹¾å‰æŒ‰éˆ•ç‹€æ…‹çš„å‡½æ•¸
  function updateSaveCheckButtons() {
    const isEditing = !!window.__headerIsEdit;
    const hasChanges = !!window.__unsavedChanges;
    const saveCheckIds = ['btnSaveHeader', 'btnCancelChanges'];
    saveCheckIds.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.disabled = !isEditing || !hasChanges;
      el.classList.toggle('disabled', !isEditing || !hasChanges);
    });
  }
  window.updateSaveCheckButtons = updateSaveCheckButtons;

document.addEventListener('input', (e) => {
  if (e.target.closest('.erp-header-form')) {
    window.__unsavedChanges = true;
    updateSaveCheckButtons();
  }
});
document.addEventListener('change', (e) => {
  if (e.target.closest('.erp-header-form') || e.target.closest('.multi-tab-detail')) {
    window.__unsavedChanges = true;
    updateSaveCheckButtons();
  }
});
window.addEventListener('pageshow', () => {
  window.__unsavedChanges = false;
  updateSaveCheckButtons();
});

  const cancelChangesBtn = document.getElementById('btnCancelChanges');
  if (cancelChangesBtn) {
    cancelChangesBtn.addEventListener('click', async () => {
      const wasEdit = !!window.__headerIsEdit;
      if (window.__unsavedChanges) {
        if (!confirm('å–æ¶ˆæœªå„²å­˜çš„è®Šæ›´ä¸¦é‚„åŸè³‡æ–™ï¼Ÿ')) return;
      }

      resetHeaderForm();
      if (typeof window.resetMultiTabEdits === 'function') {
        window.resetMultiTabEdits();
      }
      if (typeof window.__paper3lSubDetailReset === 'function') {
        try { await window.__paper3lSubDetailReset(wasEdit); } catch {}
      }
      if (typeof window.__setHeaderEditMode === 'function') {
        window.__setHeaderEditMode(false);
        if (wasEdit) window.__setHeaderEditMode(true);
      }
      window.__unsavedChanges = false;
      updateSaveCheckButtons();
    });
  }
</script>

<style>
/* =========================================
   A) å…¨å±€/ç‰ˆé¢
   ========================================= */
body { background: var(--page-bg) !important; }
.erp-detail-container {
  min-height: 100vh;
  padding: 4px 8px;
  margin: 0;
  background: var(--page-bg);
}

/* =========================================
   B) Header è¡¨å–® & Tabs
   ========================================= */
.erp-header-form,
.erp-header-form select,
.erp-header-form textarea,
.erp-header-form input { font-size: var(--field-value-size); }

.erp-header-form{
  background: transparent;
  border-radius: 10px;
  padding: 0 8px 8px;
}

/* å–®é ­/å–®èº«å¯¬åº¦èˆ‡å·¦å´é–“è·ä¸€è‡´ */
.erp-header-form,
.multi-tab-detail {
  padding-left: var(--detail-left-pad);
  max-width: var(--detail-max-width);
  width: 100%;
  box-sizing: border-box;
}
.erp-header-form .row{
  margin-left: 0;
  margin-right: 0;
  --bs-gutter-x: 0;
}

/* å–®é ­/å–®èº«é–“è·ï¼šç¸®å°è¡¨å–®åº•éƒ¨ç•™ç™½ */
.erp-header-form { margin-bottom: 0; }

.erp-header-form select.form-select{
  font-size: 1em !important; height: 100% !important; min-height: 22px !important; line-height: 1.2 !important;
  padding: 2px 30px 2px 6px !important; appearance: none; -webkit-appearance: none; -moz-appearance: none;
  background-image: url('data:image/svg+xml;utf8,<svg width="11" height="11" fill="gray" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5l3.5 3.5L9 4.5" stroke="gray" stroke-width="2" fill="none" stroke-linecap="round"/></svg>');
  background-repeat: no-repeat; background-position: right 10px center; background-size: 14px 14px; box-shadow: none !important; border-radius: 0 !important;
  margin: 0 !important;
}
.erp-header-form .form-check{
  padding-left: 0 !important;
  min-height: 0 !important;
}
.erp-header-form input[type="checkbox"],
.erp-header-form .form-check-input{
  width: 18px !important;
  height: 18px !important;
  min-width: 18px !important;
  min-height: 18px !important;
  max-width: 18px !important;
  max-height: 18px !important;
  line-height: 18px !important;
  display: inline-block !important;
  vertical-align: middle !important;
  box-sizing: border-box !important;
  margin: 0 !important;
  padding: 0 !important;
  border: 1px solid #6c7a90 !important;
  border-radius: 2px !important;
  background-color: #fff !important;
  appearance: none !important;
  -webkit-appearance: none !important;
  -moz-appearance: none !important;
}
.erp-header-form input[type="checkbox"]:checked,
.erp-header-form .form-check-input:checked{
  background-color: #2c3e50 !important;
  border-color: #2c3e50 !important;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'><path d='M2.2 6.3l2.2 2.2 5.4-5.4' stroke='white' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round'/></svg>") !important;
  background-repeat: no-repeat !important;
  background-position: center !important;
  background-size: 10px 10px !important;
}
.header-fields-tab{
  position: relative;
  min-height: 72px;
  width: 100%;
  box-sizing: border-box;
  padding-top: 6px;
  padding-bottom: 2px;
  margin-bottom: .25rem !important;
  background: #eef2f9 !important; box-shadow: 0 2px 6px rgba(0,0,0,0.04);
}
.drop-hover{ background-color:#cce5ff !important; border-radius:4px; }

.erp-header-form .nav-tabs .nav-link{ border-radius:8px 8px 0 0 !important; padding:var(--tab-pad-y) var(--tab-pad-x); font-size:var(--field-label-size); font-weight:500; color:#4a6fa8; background:#dde7f7; border:1px solid #bccdea; border-bottom-color:#aabedd; }
.erp-header-form .nav-tabs .nav-link.active{
  background:#ffffff; color:#1b3f8a; border-color:#7da3df #7da3df #fff #7da3df !important; box-shadow:0 3px 10px 0 rgba(14,53,95,0.18); font-weight:750;
}
.erp-header-form .nav-tabs .nav-link:not(.active):hover{
  background:#d0dcf2;
  color:#3b5d92;
}

.top-toolbar{
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
  width: 100%;
  padding-left: var(--detail-left-pad);
  margin-bottom: 2px;
  border-radius: 10px;
  background: transparent;
  border: 1px solid #c7d0e0;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-right: 8px;
  box-shadow: 0 1px 2px rgba(20, 40, 80, 0.06);
  transition: background-color 0.2s ease;
}
.top-toolbar .toolbar-icon-row{
  display: flex;
  gap: 4px;
  align-items: center;
}
.top-toolbar .toolbar-icon-row #btnFirst{
  margin-left: 6px;
}
/* å°èˆªæŒ‰éˆ•åœ–æ¨™ç¸®å° */
.top-toolbar #btnFirst i,
.top-toolbar #btnPrev i,
.top-toolbar #btnNext i,
.top-toolbar #btnLast i {
  font-size: 16px;
}
.top-toolbar .toolbar-main{
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: nowrap;
  flex: 1 1 0;
  min-width: 0;
}
.top-toolbar .toolbar-main > div{
  flex: 1 1 auto;
  min-width: 0;
}
.top-toolbar .toolbar-right{
  display: flex;
  gap: 4px;
  margin-left: 2px;
  flex: 0 0 auto;
}
.top-toolbar .toolbar-main > div:first-child{
  flex: 0 1 auto;
}
.top-toolbar .toolbar-btn{
  font-size: var(--top-toolbar-font-size);
  height: var(--top-toolbar-btn-height);
  min-height: var(--top-toolbar-btn-height);
  padding: 0 6px;
  line-height: 1;
}
.top-toolbar .toolbar-btn-icon{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: var(--top-toolbar-btn-height);
  min-height: var(--top-toolbar-btn-height);
  padding: 0;
  width: 30px;
  border-radius: 8px;
  font-size: var(--top-toolbar-icon-font-size);
  line-height: 1;
}
.top-toolbar .toolbar-btn-icon .toolbar-icon{
  display: inline-block;
}
.top-toolbar #btnSubDetailDelete .toolbar-icon{
  transform: translateY(-3px);
}
.top-toolbar .toolbar-btn:disabled{
  background: #f1f3f7;
  border-color: #c5ccd8;
  color: #9aa7bb;
  cursor: not-allowed;
  box-shadow: none;
  opacity: 0.8;
}
.top-toolbar .toolbar-btn-add{
  background: #f7fcf9;
  border-color: #7ccfa1;
  color: #1f7a45;
}
.top-toolbar .toolbar-btn-del,
.top-toolbar .toolbar-btn-cancel{
  background: #fff4f4;
  border-color: #e08a8a;
  color: #b33939;
}
.top-toolbar .toolbar-btn-check,
.top-toolbar .toolbar-btn-cancel{
  font-size: 18px;
}
.top-toolbar.mode-view,
.top-toolbar.mode-edit{
  background: transparent;
}
.top-toolbar .dropdown-menu{
  min-width: 10rem;
  padding: .5rem 0;
  border: 1px solid rgba(0,0,0,0.15);
  border-radius: .5rem;
  box-shadow: 0 .5rem 1rem rgba(0,0,0,.175);
}
.top-toolbar .dropdown-item{
  padding: .35rem 1rem;
  font-weight: 500;
  color: #212529;
}
.top-toolbar .dropdown-item:hover,
.top-toolbar .dropdown-item:active{
  background: #2d5fa8;
  color: #fff;
}
.top-toolbar .dropdown-toggle::after{
  display: none;
}

#topToolbar{
  position: sticky;
  top: calc(var(--app-toolbar-height, 56px) + 4px);
  z-index: 1200;
  margin-left: calc(-1 * var(--rail-reserve) + 24px);
  padding-left: 24px;
}
body.modal-open #topToolbar{
  z-index: 500; /* avoid covering bootstrap modals */
}

.toolbar-count-box{
  display: inline-flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: var(--top-toolbar-btn-height, 36px);
  min-width: 74px;
  padding: 2px 8px;
  border-radius: 6px;
  font-weight: 700;
  line-height: 1.05;
  color: #fff;
  user-select: none;
}
.toolbar-count-box .count-line{
  font-size: 0.75rem;
}
.toolbar-count-box.mode-view{
  background: #1e4db7;
}
.toolbar-count-box.mode-edit{
  background: #f00000;
}

.edit-notesmoney-body{
  display: grid;
  gap: 16px;
}
.edit-notesmoney-actions{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}
.modal#editNotesMoneyModal .modal-header{
  padding-top: 6px;
  padding-bottom: 6px;
}
.modal#editNotesMoneyModal .modal-title{
  margin: 0;
}
.modal#editNotesMoneyModal .modal-dialog{
  margin-top: 10vh;
}
.edit-notesmoney-actions .edit-notesmoney-btn{
  border-radius: 8px;
  font-weight: 600;
}
.edit-notesmoney-block{
  border: 1px solid #e3e7ef;
  border-radius: 10px;
  padding: 10px 12px;
  background: #fafbff;
}
.edit-notesmoney-title{
  font-weight: 700;
  margin-bottom: 8px;
}
.edit-notesmoney-table{
  width: 100%;
  border-collapse: collapse;
}
.edit-notesmoney-table th,
.edit-notesmoney-table td{
  border: 1px solid #e6e9f2;
  padding: 6px 8px;
  font-size: 0.95rem;
  vertical-align: middle;
}
.edit-notesmoney-table th{
  background: #f2f5fb;
  font-weight: 600;
}
.edit-notesmoney-input{
  width: 100%;
  min-width: 80px;
}
.edit-notesmoney-checkbox{
  width: 18px;
  height: 18px;
  min-width: 18px;
  margin: 0;
}

/* draggable æ¬„ä½ï¼ˆæ©«æ’ label + æ§ä»¶ï¼‰ */
.draggable-field{ position:absolute; display:flex; flex-direction:column; box-sizing:border-box; overflow:hidden; background:transparent; border:1px dashed transparent; }
.draggable-field:hover{ border-color:#c7d3e1; }
.draggable-field.inline{ display:flex; flex-direction:row; align-items: center; gap:4px; flex:0 0 auto; min-width:0; max-width:100%; box-sizing:border-box; }
.header-label-item{ position:absolute; display:flex; align-items:center; justify-content:flex-end; text-align:right; font-size:var(--field-label-size); line-height:1.2; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; padding:0 4px 0 2px; z-index:2; pointer-events:none; }
.field-drag-handle{ position:absolute; left:0; top:0; width:10px; height:100%; cursor:default; background:transparent; z-index:3; }
.draggable-field.inline .field-control{ flex:1 1 auto; height:100%; display:flex; }
.draggable-field.inline textarea,
.draggable-field.inline input,
.draggable-field.inline .form-select{
  flex:1 1 auto; width:100%; height:100%; min-height:22px; min-width:0; max-width:100%; line-height:1.2; resize:none; padding:4px 6px; font-size:var(--field-value-size); border-radius:0 !important; box-sizing:border-box;
  text-align: left;
}
.draggable-field.inline.field-number textarea,
.draggable-field.inline.field-number input,
.draggable-field.inline.field-number .form-select{
  text-align: right !important;
}
.erp-header-form textarea[data-align="right"],
.erp-header-form input[data-align="right"],
.erp-header-form select[data-align="right"]{
  text-align: right !important;
}
.erp-header-form textarea[data-align="center"],
.erp-header-form input[data-align="center"],
.erp-header-form select[data-align="center"]{
  text-align: center !important;
}
.erp-header-form .resizable-input{
  padding: 2px 4px !important;
  resize: none !important;
  overflow: hidden;
  white-space: nowrap;
}
/* æ˜ç´°è¡¨é ­/æ¬„ä½å­—é«”å¤§å°ä¸€è‡´ */
.erp-table th{ font-size: var(--field-label-size); }
.erp-table td{ font-size: var(--field-value-size); }
.draggable-field.inline label{
  white-space: nowrap !important;
  overflow: visible !important;
  text-overflow: clip !important;
  max-width: none !important;
}
.draggable-field.md-selected{
  border-radius: 8px;
  border-color:#5b8def;
  background:rgba(91,141,239,0.08);
}
.erp-header-form .lookup-dropdown.lookup-readonly{
  /* ç€è¦½æ¨¡å¼å…è¨±å±•é–‹ä¸‹æ‹‰ï¼Œä½†ä¸å…è¨±ä¿®æ”¹ï¼šå¤–è§€æ¯”ç…§ disabled çš„ç°åº• */
  background-color: var(--bs-secondary-bg, #e9ecef) !important;
  color: var(--bs-secondary-color, #6c757d) !important;
  opacity: 1; /* é¿å…åƒ disabled ä¸€æ¨£æ•´é«”è®Šæ·¡ */
  cursor: default;
}
.erp-header-form .lookup-dropdown.lookup-readonly:focus{
  border-color: #ced4da;
  box-shadow: none !important;
}
.erp-header-form .lookup-dropdown{
  padding-right: 24px !important;
}
.erp-header-form .date-dropdown{
  padding-right: 24px !important;
}
.erp-header-form .lookup-toggle{
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 18px;
  height: 18px;
  border: 0;
  background: transparent;
  cursor: pointer;
  z-index: 6;
}
.erp-header-form .lookup-toggle::before{
  content: "";
  display: block;
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 6px solid #6b7280;
  margin: 0 auto;
}
.erp-header-form .date-picker-input{
  position: absolute;
  right: 4px;
  top: 50%;
  transform: translateY(-50%);
  width: 18px;
  height: 18px;
  opacity: 0;
  pointer-events: none;
}
.lookup-dropdown-list{
  z-index: 2000;
  background: #fff;
  border: 1px solid #b6c2d9;
  border-radius: 6px;
  box-shadow: 0 8px 20px rgba(30, 41, 59, 0.18);
  overflow: auto;
}
.lookup-dropdown-item{
  display: block;
  width: 100%;
  border: 0;
  background: transparent;
  text-align: left;
  padding: 6px 10px;
  font-size: var(--field-value-size);
  cursor: pointer;
}
.lookup-dropdown-item:hover,
.lookup-dropdown-item:focus{
  background: #e2e8f0;
  outline: none;
}
.lookup-dropdown-item.is-selected{
  background: #dbeafe;
}
.erp-header-form .lookup-dropdown option,
.erp-header-form .lookup-dropdown optgroup{
  background-color: var(--bs-body-bg, #fff) !important;
  color: var(--bs-body-color, #212529) !important;
}
.erp-header-form .dict-readonly,
.erp-header-form .dict-readonly:focus{
  background-color: var(--bs-secondary-bg, #e9ecef) !important;
  color: var(--bs-secondary-color, #6c757d) !important;
  border-color: #ced4da !important;
  box-shadow: none !important;
  cursor: not-allowed;
}
/* jQuery UI resizableï¼šè®“å³å´æ‹‰å¯¬æŠŠæ‰‹æ›´å¥½æŠ“ */
.draggable-field.ui-resizable .ui-resizable-e{
  position: absolute;
  top: 0; right: 0; width: 10px; height: 100%;
  cursor: ew-resize; background: transparent;
  z-index: 5;
}
.draggable-field.ui-resizable:hover .ui-resizable-e{
  background: rgba(32,86,172,0.10);
}
.draggable-field.ui-resizable .ui-resizable-se{
  position: absolute;
  right: 0; bottom: 0; width: 14px; height: 14px;
  cursor: se-resize; background: transparent;
  z-index: 5;
}
.field-drag-handle,
.draggable-field.ui-resizable .ui-resizable-e,
.draggable-field.ui-resizable .ui-resizable-se{
  display: none !important;
}
.layout-edit-enabled .field-drag-handle{
  display: block !important;
  cursor: move;
}
.layout-edit-enabled .header-label-item{
  pointer-events: auto;
}
body.shift-resize .draggable-field.ui-resizable .ui-resizable-e,
body.shift-resize .draggable-field.ui-resizable .ui-resizable-se{
  display: block !important;
}

/* =========================================
   D) å…¶å®ƒ
   ========================================= */
.highlight-red { color:#e53b2d; font-weight:700; }
.highlight-blue{ color:#2564b3; font-weight:700; }

/* --- Action Rail åŸºç¤ç‰ˆä½ & å…§å®¹å³ç§»ï¼ˆå›ºå®šåœ¨æ¨£æ¿ï¼‰--- */
/* æ›´æ–°æ™‚é–“: 2025-03-20 13:45 */
:root{
  --fab-left: 20px;
  --fab-width: 120px;
  --fab-gap: 14px;
  --rail-reserve: 146px;
  --action-rail-top: 44px;
}

.action-rail{
  position: fixed;
  left: var(--fab-left);
  top: var(--action-rail-top);
  box-sizing: border-box;
  max-height: calc(100vh - (var(--action-rail-top) + 20px)); /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé¿å…è¶…å‡ºè¦–çª— */
  display: flex;
  flex-direction: column;
  gap: 2px;
  z-index: 900;
  overflow-y: auto;
  overflow-x: visible;
  background: transparent;
  border-radius: 0;
  padding: 0;
}

body.with-toolbar .action-rail{
  top: calc(var(--action-rail-top) + var(--app-toolbar-height, 0px));
  max-height: calc(100vh - (var(--action-rail-top) + 20px + var(--app-toolbar-height, 0px)));
}

/* action-rail çš„æ²è»¸æ¨£å¼ - ä½¿ç”¨ overlay æ¨¡å¼ä¸ä½”ç©ºé–“ */
.action-rail::-webkit-scrollbar {
  width: 8px;
}

.action-rail::-webkit-scrollbar-track {
  background: transparent;
}

.action-rail::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.25);
  border-radius: 4px;
  border: 2px solid transparent;
  background-clip: padding-box;
}

.action-rail::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.4);
  background-clip: padding-box;
}

/* æŒ‰éˆ•çš„å…±åŒå¤–è§€ï¼ˆä¿æŒåœ¨æ¨£æ¿ï¼Œè®“æ‰€æœ‰é é¢ä¸€è‡´ï¼‰ */
.fab{
  position: relative;
  width: var(--fab-width);
  min-width: 0;
  padding: 6px 8px;
  font-size: .92rem;
  letter-spacing: 0;
  white-space: normal;
  word-break: break-word;
  background:#f8f9fb;
  color:#1f5fbf;
  font-weight:600;
  border-radius:10px;
  cursor:pointer;
  box-shadow:0 2px 8px rgba(20,40,80,.12);
  border:1px solid #cfd7e6;
}
.fab:hover{
  background:#e9f1ff;
  border-color:#9fbaf0;
}
.fab:focus-visible{
  outline:2px solid #9fbaf0;
  outline-offset:2px;
}
.fab-red{ background:#dc3545; color:#fff; }
.fab-blue{ background:#3583dc; color:#fff; }
</style>
