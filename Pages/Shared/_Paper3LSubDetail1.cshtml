@using System.Text.Json
@{
    var sd = ViewData["SubDetail1"] as PcbErpApi.Pages.DynamicTemplate.Paper3LDetailModel.SubDetailClientConfig;
    if (sd == null || string.IsNullOrWhiteSpace(sd.DictTable))
    {
        return;
    }

    var json = JsonSerializer.Serialize(sd, new JsonSerializerOptions { PropertyNamingPolicy = null });
}

<div class="paper3l-subdetail mt-0">
    <div class="d-flex align-items-center justify-content-between mb-0">
        <div class="subdetail-title">@sd.Title</div>
        <div class="text-muted small" id="paper3l-subdetail-count"></div>
    </div>
    <div id="paper3l-subdetail-container" class="erp-table-wrapper p-2" style="max-width:1400px;" data-dict-table="@sd.DictTable">
        <div class="alert alert-info mb-0">請先在上方明細選取一筆資料</div>
    </div>
</div>

<style>
  .paper3l-subdetail table th{ font-size: var(--field-label-size); }
  .paper3l-subdetail table td{ font-size: var(--field-value-size); }
  .paper3l-subdetail .partnum-field{ position: relative; }
  .paper3l-subdetail .partnum-lookup-btn{
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    width: 22px;
    border: 0;
    border-left: 1px solid #9fb1d0;
    background: #e9f1ff;
    color: #1f5fbf;
    font-weight: 700;
    line-height: 1;
    padding: 0;
    cursor: pointer;
  }
  .paper3l-subdetail .partnum-lookup-btn:hover{ background: #dbe9ff; }
  .paper3l-subdetail .partnum-field .cell-view,
  .paper3l-subdetail .partnum-field .cell-edit{
    padding-right: 26px !important;
  }
</style>

<script>
(function() {
  const cfg = @Html.Raw(json);
  const container = document.getElementById('paper3l-subdetail-container');
  const countEl = document.getElementById('paper3l-subdetail-count');
  let lastRows = null;
  let readOnlyMap = new Map();
  let dictMetaMap = new Map();
  if (container) {
    container.addEventListener('pointerdown', () => {
      window.__activeDetailGrid = 'paper3l';
    }, true);
    container.addEventListener('click', () => {
      window.__activeDetailGrid = 'paper3l';
    }, true);
  }

  function cleanTableName(t) {
    return (t || '').toString().replace(/^dbo\./i, '').trim().toLowerCase();
  }

  function escapeHtml(v) {
    return String(v ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function isPartNumField(name) {
    return !!name && String(name).replace(/_/g, '').toLowerCase() === 'partnum';
  }

  function getPartNumFromCell(cell) {
    if (!cell) return '';
    const input = cell.querySelector('.cell-edit');
    if (input) return (input.value || '').trim();
    const view = cell.querySelector('.cell-view');
    return (view?.textContent || '').trim();
  }

  document.addEventListener('click', (e) => {
    if (e.__partnumHandled) return;
    const btn = e.target.closest('.partnum-lookup-btn');
    if (!btn) return;
    e.__partnumHandled = true;
    e.preventDefault();
    e.stopPropagation();
    const cell = btn.closest('td');
    const partNum = getPartNumFromCell(cell);
    if (!partNum) return;
    const url = `/MIN/MatDetailPopup?PartNum=${encodeURIComponent(partNum)}`;
    const popupWidth = 680;
    const popupHeight = 520;
    const left = (screen.width - popupWidth) / 2;
    const top = (screen.height - popupHeight) / 2;
    window.open(url, 'MatDetailPopup', `width=${popupWidth},height=${popupHeight},left=${left},top=${top},resizable=yes,scrollbars=yes`);
  });


  function normalizeFieldKey(k) { return (k || '').toString().trim().toLowerCase(); }

  function getValueCaseInsensitive(obj, key) {
    if (!obj || !key) return undefined;
    const k = normalizeFieldKey(key);
    const hitKey = Object.keys(obj).find(x => normalizeFieldKey(x) === k);
    return hitKey ? obj[hitKey] : undefined;
  }

  function hasFieldCaseInsensitive(obj, key) {
    if (!obj || !key) return false;
    const k = normalizeFieldKey(key);
    return Object.keys(obj).some(x => normalizeFieldKey(x) === k);
  }

  const LOOKUP_META_CACHE = new Map(); // tn -> Map(fieldLower -> { table, key, result, keySelf, field })
  const LOOKUP_DATA_CACHE = new Map(); // tn -> Map(fieldLower -> Map(key -> label))
  const READONLY_META_CACHE = new Map(); // tn -> Map(fieldLower -> boolean)
  const DICT_META_CACHE = new Map(); // tn -> Map(fieldLower -> { dataType, formatStr })

  async function fetchDictMeta(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Map();
    if (DICT_META_CACHE.has(tn)) return DICT_META_CACHE.get(tn);
    try {
      const res = await fetch(`/api/TableFieldLayout/DictFields?table=${encodeURIComponent(tn)}&lang=TW`);
      if (!res.ok) {
        const empty = new Map();
        DICT_META_CACHE.set(tn, empty);
        return empty;
      }
      const rows = await res.json();
      const map = new Map();
      (rows || []).forEach(r => {
        const field = (r.fieldName || r.FieldName || '').toString();
        if (!field) return;
        map.set(field.toLowerCase(), {
          dataType: (r.dataType || r.DataType || '').toString(),
          formatStr: (r.formatStr || r.FormatStr || '').toString()
        });
      });
      DICT_META_CACHE.set(tn, map);
      return map;
    } catch {
      const empty = new Map();
      DICT_META_CACHE.set(tn, empty);
      return empty;
    }
  }

  async function fetchLookupMeta(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Map();
    if (LOOKUP_META_CACHE.has(tn)) return LOOKUP_META_CACHE.get(tn);
    try {
      const res = await fetch(`/api/TableFieldLayout/GetTableFieldsFull?table=${encodeURIComponent(tn)}&lang=TW`);
      if (!res.ok) {
        const empty = new Map();
        LOOKUP_META_CACHE.set(tn, empty);
        return empty;
      }
      const rows = await res.json();
      const map = new Map();
      (rows || []).forEach(r => {
        const field = (r.fieldName || r.FieldName || '').toString();
        if (!field) return;
        const table = (r.lookupTable || r.LookupTable || '').toString();
        const key = (r.lookupKeyField || r.LookupKeyField || '').toString();
        const result = (r.lookupResultField || r.LookupResultField || '').toString();
        const ocxTable = (r.ocxLKTableName || r.OCXLKTableName || '').toString();
        const ocxResult = (r.ocxLKResultName || r.OCXLKResultName || '').toString();
        const ocxKeyField = (r.keyFieldName || r.KeyFieldName || '').toString();
        const ocxKeySelf = (r.keySelfName || r.KeySelfName || '').toString();
        const keyMapsRaw = (r.keyMapsJson || r.KeyMapsJson || '').toString();
        let keyMaps = [];
        if (keyMapsRaw) {
          try { keyMaps = JSON.parse(keyMapsRaw) || []; } catch { keyMaps = []; }
        }
        if (table && key && result) {
          map.set(field.toLowerCase(), { field, table, key, result, keySelf: '', source: 'lookup', keyMaps });
          return;
        }
        if (ocxTable && ocxKeyField && ocxResult) {
          map.set(field.toLowerCase(), { field, table: ocxTable, key: ocxKeyField, result: ocxResult, keySelf: ocxKeySelf, source: 'ocx', keyMaps });
        }
      });
      LOOKUP_META_CACHE.set(tn, map);
      return map;
    } catch {
      const empty = new Map();
      LOOKUP_META_CACHE.set(tn, empty);
      return empty;
    }
  }

  async function fetchReadOnlyMeta(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Map();
    if (READONLY_META_CACHE.has(tn)) return READONLY_META_CACHE.get(tn);
    try {
      const res = await fetch(`/api/TableFieldLayout/GetTableFieldsFull?table=${encodeURIComponent(tn)}&lang=TW`);
      if (!res.ok) {
        const empty = new Map();
        READONLY_META_CACHE.set(tn, empty);
        return empty;
      }
      const rows = await res.json();
      const map = new Map();
      (rows || []).forEach(r => {
        const field = (r.fieldName || r.FieldName || '').toString();
        if (!field) return;
        const ro = Number(r.readOnly ?? r.ReadOnly ?? 0) === 1;
        map.set(field.toLowerCase(), ro);
      });
      READONLY_META_CACHE.set(tn, map);
      return map;
    } catch {
      const empty = new Map();
      READONLY_META_CACHE.set(tn, empty);
      return empty;
    }
  }

  async function fetchLookupMaps(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Map();
    if (LOOKUP_DATA_CACHE.has(tn)) return LOOKUP_DATA_CACHE.get(tn);
    const meta = await fetchLookupMeta(dictTable);
    const fieldMap = new Map();
    for (const [field, cfg] of meta.entries()) {
      try {
        const url = `/api/TableFieldLayout/LookupData?table=${encodeURIComponent(cfg.table)}&key=${encodeURIComponent(cfg.key)}&result=${encodeURIComponent(cfg.result)}`;
        const res = await fetch(url);
        if (!res.ok) continue;
        const data = await res.json();
        const map = new Map();
        (data || []).forEach(row => {
          const key = row.key == null ? '' : String(row.key);
          if (key === '') return;
          const labelParts = Object.keys(row)
            .filter(p => p.startsWith('result'))
            .map(p => row[p])
            .filter(v => v != null && typeof v !== 'object' && String(v).trim() !== '')
            .map(v => String(v));
          const deduped = labelParts.filter(v => v.trim() !== key.trim());
          const label = (deduped.length ? deduped : labelParts).join(' - ');
          const trimmed = key.trim();
          map.set(key, label || key);
          if (trimmed && trimmed !== key) map.set(trimmed, label || trimmed);
        });
        fieldMap.set(field, map);
      } catch { }
    }
    LOOKUP_DATA_CACHE.set(tn, fieldMap);
    return fieldMap;
  }

  async function fetchFieldWidths(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Map();
    try {
      const res = await fetch(`/api/TableFieldLayout/DictFields?table=${encodeURIComponent(tn)}&lang=TW`);
      if (!res.ok) return new Map();
      const rows = await res.json();
      const map = new Map();
      (rows || []).forEach(r => {
        const field = (r.fieldName || r.FieldName || '').toString();
        const w = r.fieldWidth ?? r.FieldWidth;
        const ds = r.displaySize ?? r.DisplaySize;
        if (!field) return;
        const px = Number.isFinite(w) ? Number(w) : (Number.isFinite(ds) ? Number(ds) * 10 : null);
        if (px && px > 0) map.set(field.toLowerCase(), Math.round(px));
      });
      return map;
    } catch {
      return new Map();
    }
  }

  function applyColumnWidth(table, ths, index, width) {
    const w = Math.max(30, Math.round(width));
    const th = ths[index];
    if (!th) return;
    th.style.width = `${w}px`;
    Array.from(table.querySelectorAll(`tbody tr td:nth-child(${index + 1})`)).forEach(td => td.style.width = `${w}px`);
  }

  function applySavedWidths(table, dictTable, fields) {
    const tn = cleanTableName(dictTable);
    if (!tn) return;
    try {
      const raw = localStorage.getItem(`colwidth:${tn}`);
      if (!raw) return;
      const cols = JSON.parse(raw) || [];
      const ths = Array.from(table.querySelectorAll('thead th'));
      cols.forEach(c => {
        const f = (c.fieldName || '').toString();
        const w = Number(c.width);
        if (!f || !Number.isFinite(w)) return;
        const idx = fields.findIndex(x => x.toLowerCase() === f.toLowerCase());
        if (idx >= 0) applyColumnWidth(table, ths, idx, w);
      });
    } catch { }
  }

  const resizeState = window.__paper3lResizeState || (window.__paper3lResizeState = {
    active: false,
    table: null,
    ths: [],
    dictTable: '',
    thIndex: -1,
    startX: 0,
    startWidth: 0,
    saveTimer: null
  });

  async function persistWidths(snapshot) {
    const table = snapshot?.table;
    const ths = snapshot?.ths || [];
    const dictTable = snapshot?.dictTable || '';
    const tn = cleanTableName(dictTable);
    if (!table || !ths.length || !tn) return;
    try {
      const payload = {
        tableName: tn,
        cols: ths.map(th => ({ fieldName: th.dataset.field, width: Math.round(th.getBoundingClientRect().width) }))
      };
      await fetch('/api/TableFieldLayout/SaveDetailLayout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      }).catch(() => { });
      localStorage.setItem(`colwidth:${tn}`, JSON.stringify(payload.cols));
    } catch { }
  }

  function debouncePersist(snapshot) {
    clearTimeout(resizeState.saveTimer);
    const snap = snapshot ? { ...snapshot } : null;
    resizeState.saveTimer = setTimeout(() => persistWidths(snap), 400);
  }

  if (!window.__paper3lResizeBound) {
    window.__paper3lResizeBound = true;
    document.addEventListener('mousemove', (e) => {
      if (!resizeState.active || !resizeState.table) return;
      const dx = e.pageX - resizeState.startX;
      const newW = Math.max(30, resizeState.startWidth + dx);
      applyColumnWidth(resizeState.table, resizeState.ths, resizeState.thIndex, newW);
    });
    document.addEventListener('mouseup', () => {
      if (!resizeState.active) return;
      resizeState.active = false;
      document.body.classList.remove('resizing');
      resizeState.ths.forEach(th => th.classList.remove('resizing'));
      Array.from(resizeState.table.querySelectorAll('tbody td.resizing')).forEach(td => td.classList.remove('resizing'));
      debouncePersist({ table: resizeState.table, ths: resizeState.ths, dictTable: resizeState.dictTable });
      resizeState.table = null;
      resizeState.ths = [];
      resizeState.dictTable = '';
      resizeState.thIndex = -1;
    });
  }

  function initColumnResize(table, dictTable) {
    if (!table) return;
    const ths = Array.from(table.querySelectorAll('thead th'));
    ths.forEach((th, idx) => {
      const handle = th.querySelector('.col-resizer');
      if (!handle) return;
      handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        resizeState.active = true;
        resizeState.table = table;
        resizeState.ths = ths;
        resizeState.dictTable = dictTable;
        resizeState.thIndex = idx;
        resizeState.startX = e.pageX;
        resizeState.startWidth = th.getBoundingClientRect().width;
        document.body.classList.add('resizing');
        th.classList.add('resizing');
        Array.from(table.querySelectorAll(`tbody tr td:nth-child(${idx + 1})`)).forEach(td => td.classList.add('resizing'));
      });
    });
  }

  async function loadSubDetail(rowData) {
    if (!container) return;
    if (!rowData) {
      container.innerHTML = '<div class="alert alert-info mb-0">請先在上方明細選取一筆資料</div>';
      if (countEl) countEl.textContent = '';
      window._paper3lSubDetailSelectedRows = window._paper3lSubDetailSelectedRows || {};
      window._paper3lSubDetailSelectedRows["1"] = null;
      return;
    }

    const filters = [];
    (cfg.KeyMap || []).forEach(km => {
      const parent = km.ParentField || km.parentField || km.Parent || km.Master;
      const child = km.ChildField || km.childField || km.Detail || km.Child;
      if (!parent || !child) return;
      const v = getValueCaseInsensitive(rowData, parent);
      if (v === undefined || v === null || String(v).trim() === '') return;
      filters.push({ Field: child, Op: '=', Value: String(v) });
    });

    // 若 mdKey 沒設定，至少用 PaperNum 兜底（避免整表撈）
    if (filters.length === 0) {
      const pn = getValueCaseInsensitive(rowData, 'PaperNum');
      if (pn) filters.push({ Field: 'PaperNum', Op: '=', Value: String(pn) });
    }

    if (filters.length === 0) {
      await renderTable([]);
      return;
    }

    filters.push({ Field: 'page', Op: '', Value: '1' });
    filters.push({ Field: 'pageSize', Op: '', Value: '9999' });

    container.innerHTML = '<div class="text-center py-4"><div class="spinner-border text-primary" role="status"></div></div>';

    try {
      const itemId = (window._itemId || window._singleItemId || '').toString().trim();
      const resp = await fetch('/api/DynamicTable/PagedQuery', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ table: cfg.DictTable, itemId, filters })
      });
      if (!resp.ok) {
        const text = await resp.text();
        throw new Error(text || `HTTP ${resp.status}`);
      }

      const json = await resp.json();
      const rows = (json && json.data) ? json.data : [];
      await renderTable(rows);
    } catch (err) {
      container.innerHTML = `<div class="alert alert-danger mb-0">載入失敗: ${escapeHtml(err && err.message ? err.message : err)}</div>`;
      if (countEl) countEl.textContent = '';
    }
  }

  function getCellValue(row, fieldName) {
    const v = getValueCaseInsensitive(row, fieldName);
    if (v == null) return '';
    if (typeof v === 'object') return '';
    const s = String(v);
    return s === '[object Object]' ? '' : v;
  }

  function parseDecimalsFromFormat(fmt) {
    const s = (fmt || '').toString();
    const dot = s.lastIndexOf('.');
    if (dot < 0) return null;
    const tail = s.slice(dot + 1);
    const min = (tail.match(/0/g) || []).length;
    const max = min + (tail.match(/#/g) || []).length;
    if (max === 0) return null;
    return { min, max };
  }

  function formatNumberByFormat(raw, formatStr) {
    const n = Number(String(raw).replace(/,/g, ''));
    if (!Number.isFinite(n)) return String(raw ?? '');
    const decimals = parseDecimalsFromFormat(formatStr);
    if (decimals) {
      return n.toLocaleString(undefined, {
        minimumFractionDigits: decimals.min,
        maximumFractionDigits: decimals.max
      });
    }
    return n.toLocaleString();
  }

  function tryParseDate(raw) {
    if (raw == null || raw === '') return null;
    if (raw instanceof Date && !isNaN(raw)) return raw;
    const s = String(raw).trim();
    if (!s) return null;
    const d = new Date(s);
    return isNaN(d) ? null : d;
  }

  function normalizeDateForPicker(value) {
    const s = String(value ?? '').trim();
    if (!s) return '';
    const m = s.match(/^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})/);
    if (m) return `${m[1]}-${m[2].padStart(2, '0')}-${m[3].padStart(2, '0')}`;
    const d = new Date(s);
    if (isNaN(d)) return '';
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
  }

  function formatDateForDisplay(ymd) {
    const m = String(ymd ?? '').match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return '';
    return `${m[1]}/${m[2]}/${m[3]}`;
  }

  function formatDisplayByMeta(raw, meta) {
    const dataType = (meta?.dataType || '').toLowerCase();
    if (!dataType) return String(raw ?? '');
    if (dataType.includes('date')) {
      const d = tryParseDate(raw);
      if (!d) return String(raw ?? '');
      return `${d.getFullYear()}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getDate()).padStart(2, '0')}`;
    }
    if (dataType.includes('int') || dataType.includes('decimal') || dataType.includes('numeric')
      || dataType.includes('money') || dataType.includes('float') || dataType.includes('real')) {
      return formatNumberByFormat(raw, meta?.formatStr);
    }
    return String(raw ?? '');
  }

  function isNumberType(dt) {
    const t = (dt || '').toString().trim().toLowerCase();
    if (!t) return false;
    return t === 'number'
      || t === 'int' || t === 'smallint' || t === 'tinyint' || t === 'bigint'
      || t.startsWith('decimal') || t.startsWith('numeric')
      || t.startsWith('money') || t.startsWith('smallmoney')
      || t.startsWith('float') || t.startsWith('real');
  }

  function isNumberValue(raw) {
    if (raw == null) return false;
    if (typeof raw === 'number') return Number.isFinite(raw);
    const s = String(raw).replace(/,/g, '').trim();
    if (!s) return false;
    return Number.isFinite(Number(s));
  }

  function getAlignClass(meta, raw) {
    if (isNumberType(meta?.dataType)) return 'align-right';
    return 'align-left';
  }

  function isDateType(meta) {
    const dt = (meta?.dataType || '').toString().toLowerCase();
    const fmt = (meta?.formatStr || '').toString().toLowerCase();
    return dt.includes('date') || fmt.includes('yyyy/mm/dd') || fmt.includes('yyyy-mm-dd');
  }

  function applyEditMode(isEdit) {
    container?.querySelectorAll('.cell-view').forEach(el => el.classList.toggle('d-none', isEdit));
    container?.querySelectorAll('.cell-edit').forEach(el => el.classList.toggle('d-none', !isEdit));
    const table = container?.querySelector('.erp-table');
    if (table) table.classList.toggle('date-edit', !!isEdit);
  }

  function getHeaderEditState() {
    if (typeof window.__headerIsEdit === 'boolean') return window.__headerIsEdit;
    const btn = document.getElementById('btnViewEditToggle');
    return !!btn && (btn.textContent || '').trim() === '保留';
  }

  const LOOKUP_EMPTY_LABEL = '--請選擇--';

  function buildLookupList(field, lookupMap, currentKey) {
    const list = document.createElement('div');
    list.className = 'lookup-dropdown-list';
    list.dataset.field = field;

    const addItem = (key, label) => {
      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'lookup-dropdown-item';
      item.dataset.key = key == null ? '' : String(key);
      item.textContent = label == null ? String(key ?? '') : String(label);
      if ((currentKey ?? '') === (key ?? '')) item.classList.add('is-selected');
      list.appendChild(item);
    };

    addItem('', LOOKUP_EMPTY_LABEL);
    for (const [key, label] of lookupMap.entries()) {
      if (key == null || String(key) === '') continue;
      addItem(String(key), label);
    }
    return list;
  }

  function positionDropdown(list, anchor) {
    if (!list || !anchor) return;
    const rect = anchor.getBoundingClientRect();
    const spaceBelow = window.innerHeight - rect.bottom;
    const maxHeight = Math.max(140, Math.min(260, spaceBelow - 8));
    const placeBelow = spaceBelow >= 140;
    list.style.position = 'fixed';
    list.style.left = `${Math.max(6, rect.left)}px`;
    list.style.top = placeBelow ? `${rect.bottom}px` : `${Math.max(6, rect.top - maxHeight)}px`;
    list.style.minWidth = `${Math.max(120, rect.width)}px`;
    list.style.maxHeight = `${maxHeight}px`;
  }

  function openLookupDropdown(td, field, lookupMap) {
    if (!td || !lookupMap || lookupMap.size === 0) return;
    const existing = document.querySelector('.lookup-dropdown-list');
    if (existing) existing.remove();

    const edit = td.querySelector('.cell-edit[data-field]');
    const view = td.querySelector('.cell-view');
    if (!edit || !view) return;

    const isReadOnly = td.dataset.readonly === '1' || edit.dataset.readonly === '1';
    if (isReadOnly) return;
    const canApply = getHeaderEditState() && !isReadOnly;
    const currentKey = edit.type === 'checkbox' ? (edit.checked ? '1' : '0') : (edit.value ?? '');
    const list = buildLookupList(field, lookupMap, currentKey);

    const cleanup = () => {
      list.remove();
      document.removeEventListener('mousedown', onDocDown, true);
      window.removeEventListener('resize', onResize, true);
    };

    const setRowFieldValue = (tr, fieldName, value, viewText) => {
      if (!tr || !fieldName) return;
      const target = Array.from(tr.querySelectorAll('input.cell-edit[data-field]'))
        .find(inp => (inp.dataset.field || '').toString().toLowerCase() === fieldName.toLowerCase());
      if (!target) return;
      target.value = value ?? '';
      const cell = target.closest('td');
      const viewEl = cell?.querySelector('.cell-view');
      if (viewEl) viewEl.textContent = viewText ?? value ?? '';
    };

    const updateRowCache = (tr, fieldName, value) => {
      if (!tr || !fieldName) return;
      const idx = parseInt(tr.dataset.idx || '-1', 10);
      if (isNaN(idx)) return;
      const rowData = window._paper3lSubDetailSelectedRows?.["1"];
      if (!rowData) return;
      rowData[fieldName] = value ?? '';
    };

    const applySelection = (newKey, label) => {
      if (!canApply) {
        cleanup();
        return;
      }
      const tr = td.closest('tr');
      const keyField = (td.dataset.lookupKeyField || '').toString();
      const keyValue = newKey ?? '';
      edit.value = keyValue ?? '';
      view.textContent = keyValue ?? '';
      setRowFieldValue(tr, field, keyValue, keyValue);
      requestAnimationFrame(() => {
        if (view) view.textContent = keyValue ?? '';
        if (edit) edit.value = keyValue ?? '';
      });

      if (keyField && keyField.toLowerCase() !== (field || '').toString().toLowerCase()) {
        setRowFieldValue(tr, keyField, keyValue, keyValue);
      }

      updateRowCache(tr, field, keyValue);
      if (keyField) updateRowCache(tr, keyField, keyValue);

      if (tr && tr.dataset.state !== 'added') tr.dataset.state = 'modified';
      window.__unsavedChanges = true;
      try {
        edit.dispatchEvent(new Event('input', { bubbles: true }));
        edit.dispatchEvent(new Event('change', { bubbles: true }));
      } catch {}
      cleanup();
    };

    const onDocDown = (e) => {
      if (list.contains(e.target)) return;
      cleanup();
    };
    const onResize = () => cleanup();

    const onPick = (e) => {
      const item = e.target.closest('.lookup-dropdown-item');
      if (!item) return;
      e.preventDefault();
      e.stopPropagation();
      const key = item.dataset.key ?? '';
      const label = item.textContent ?? key;
      applySelection(key, label);
    };
    list.addEventListener('pointerdown', onPick);
    list.addEventListener('mousedown', onPick);
    list.addEventListener('click', onPick);

    document.body.appendChild(list);
    positionDropdown(list, td);
    document.addEventListener('mousedown', onDocDown, true);
    window.addEventListener('resize', onResize, true);
  }

  function initDatePickers(scope) {
    if (!scope) return;
    const inputs = scope.querySelectorAll('input.cell-edit.date-dropdown');
    inputs.forEach(textInput => {
      const td = textInput.closest('td');
      const dateInput = td?.querySelector('input.cell-date-input');
      const toggle = td?.querySelector('.date-toggle');
      if (!dateInput || !toggle) return;

      const syncDateInput = () => {
        const v = normalizeDateForPicker(textInput.value);
        dateInput.value = v || '';
      };
      syncDateInput();

      const updateRowState = () => {
        const tr = td?.closest('tr');
        if (tr && tr.dataset.state !== 'added') tr.dataset.state = 'modified';
        window.__unsavedChanges = true;
      };

      dateInput.addEventListener('change', () => {
        const isReadOnly = td?.dataset?.readonly === '1' || textInput.dataset.readonly === '1' || textInput.readOnly;
        if (!getHeaderEditState() || isReadOnly) return;
        const formatted = formatDateForDisplay(dateInput.value) || dateInput.value;
        if (!formatted) return;
        textInput.value = formatted;
        const view = td?.querySelector('.cell-view');
        if (view) view.textContent = formatted;
        updateRowState();
        try {
          textInput.dispatchEvent(new Event('input', { bubbles: true }));
          textInput.dispatchEvent(new Event('change', { bubbles: true }));
        } catch { }
      });

      textInput.addEventListener('input', () => syncDateInput());
      textInput.addEventListener('change', () => syncDateInput());

      toggle.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const isReadOnly = td?.dataset?.readonly === '1' || textInput.dataset.readonly === '1' || textInput.readOnly;
        if (!getHeaderEditState() || isReadOnly) return;
        if (typeof dateInput.showPicker === 'function') {
          dateInput.showPicker();
        } else {
          dateInput.focus();
          dateInput.click();
        }
      });
    });
  }

  function buildKeyFieldsFromRow(row) {
    const candidates = ['PaperNum', 'Item', 'SeqNum', 'Seq', 'SerialNum', 'LineNum', 'LineId', 'RowNo'];
    return candidates.filter(k => row && row[k] !== undefined);
  }

  function isBlankRow(tr) {
    if (!tr) return false;
    const inputs = Array.from(tr.querySelectorAll('input.cell-edit[data-field]'));
    if (!inputs.length) return false;
    let hasValue = false;
    inputs.forEach(inp => {
      const v = (inp.value ?? '').toString().trim();
      if (v === '') return;
      if (/^[-–—]+$/.test(v)) return;
      const num = Number(v.replace(/,/g, ''));
      if (Number.isFinite(num) && num === 0) return;
      hasValue = true;
    });
    return !hasValue;
  }

  async function renderTable(rows) {
    rows = Array.isArray(rows) ? rows : [];
    try {
      lastRows = JSON.parse(JSON.stringify(rows));
    } catch {
      lastRows = rows.map(r => ({ ...r }));
    }
    const lookupMeta = await fetchLookupMeta(cfg.DictTable);
    const lookupMaps = await fetchLookupMaps(cfg.DictTable);
    readOnlyMap = await fetchReadOnlyMeta(cfg.DictTable);
    const metaMap = await fetchDictMeta(cfg.DictTable);
    dictMetaMap = metaMap;
    const lookupResultMap = new Map();
    for (const [fieldLower, cfgMeta] of lookupMeta.entries()) {
      const resultLower = (cfgMeta?.result || '').toString().toLowerCase();
      if (!resultLower) continue;
      const map = lookupMaps.get(fieldLower);
      if (!map) continue;
      if (!lookupResultMap.has(resultLower)) lookupResultMap.set(resultLower, { map, meta: cfgMeta });
    }
    if (!Array.isArray(rows) || rows.length === 0) {
      const fieldDefs = (cfg.Fields || []).length ? cfg.Fields : [];
      if (!fieldDefs.length) {
        container.innerHTML = '<div class="alert alert-info mb-0">無資料</div>';
        if (countEl) countEl.textContent = '0 / 0';
        window._paper3lSubDetailSelectedRows = window._paper3lSubDetailSelectedRows || {};
        window._paper3lSubDetailSelectedRows["1"] = null;
        return;
      }

      const fields = fieldDefs.map(f => f.FieldName || f.fieldName).filter(Boolean);
      let html = '<div style="overflow:auto;"><table class="erp-table"><thead><tr>';
      fieldDefs.forEach(f => {
        const fn = f.FieldName || f.fieldName;
        if (!fn) return;
        const lbl = f.DisplayLabel || f.displayLabel || fn;
        html += `<th class="align-left" data-field="${escapeHtml(fn)}" style="position:relative;"><span class="th-text">${escapeHtml(lbl)}</span><span class="col-resizer" draggable="false"></span></th>`;
      });
      html += '</tr></thead><tbody>';
      html += '<tr data-idx="0">';
      fields.forEach(fn => {
        const fieldLower = fn.toLowerCase();
        const isReadOnly = readOnlyMap.get(fieldLower) === true;
        const roClass = isReadOnly ? ' readonly-cell' : '';
        const roAttr = isReadOnly ? ' data-readonly="1" readonly' : ' data-readonly="0"';
        const meta = lookupMeta.get(fieldLower);
        const lookupMap = lookupMaps.get(fieldLower);
        const metaFieldLower = (meta?.field || '').toString().toLowerCase();
        const canDropdown = !!(meta?.source === 'lookup' && metaFieldLower && metaFieldLower === fieldLower && lookupMap && lookupMap.size);
        const fieldMeta = metaMap.get(fieldLower);
        const alignClass = getAlignClass(fieldMeta, null);
        const isDate = isDateType(fieldMeta);
        const keyFieldAttr = canDropdown ? ` data-lookup-key-field="${escapeHtml(meta?.key || '')}"` : "";
        const resultFieldAttr = canDropdown ? ` data-lookup-result-field="${escapeHtml(meta?.result || '')}"` : "";
        const tdClasses = [alignClass];
        if (canDropdown) tdClasses.push('lookup-cell');
        const isPartNum = isPartNumField(fn);
        if (isPartNum) tdClasses.push('partnum-field');
        const classAttr = tdClasses.length ? ` class="${tdClasses.join(' ')}"` : '';
        const partNumBtn = isPartNum ? '<button type="button" class="partnum-lookup-btn" title="開啟庫存一覽" aria-label="開啟庫存一覽">?</button>' : '';
        const lookupAttr = canDropdown
          ? ` data-lookup-field="${escapeHtml(fn)}"${keyFieldAttr}${resultFieldAttr}`
          : "";
        const dateEditClass = isDate ? ' date-dropdown' : '';
        const dateValue = isDate ? normalizeDateForPicker('') : '';
        const dateAddon = isDate
          ? `<input type="date" class="cell-edit d-none cell-date-input" tabindex="-1" aria-hidden="true" value="${escapeHtml(dateValue)}"${isReadOnly ? ' disabled' : ''}>
             <button type="button" class="cell-edit d-none date-toggle" aria-label="選擇日期" tabindex="-1"${isReadOnly ? ' disabled' : ''}></button>`
          : '';
        html += `<td${classAttr}${lookupAttr} data-readonly="${isReadOnly ? '1' : '0'}"><span class="cell-view${roClass}" data-readonly="${isReadOnly ? '1' : '0'}"></span><input class="cell-edit d-none${roClass}${dateEditClass}" data-field="${escapeHtml(fn)}" data-init="" value=""${roAttr}>${dateAddon}${partNumBtn}</td>`;
      });
      html += '</tr></tbody></table></div>';
      container.innerHTML = html;
      initDatePickers(container);
      if (countEl) countEl.textContent = '0 / 0';
      window._paper3lSubDetailSelectedRows = window._paper3lSubDetailSelectedRows || {};
      window._paper3lSubDetailSelectedRows["1"] = null;
      const table = container.querySelector('table.erp-table');
      if (table) {
        applySavedWidths(table, cfg.DictTable, fields);
        const widthMap = await fetchFieldWidths(cfg.DictTable);
        if (widthMap.size) {
          const ths = Array.from(table.querySelectorAll('thead th'));
          fields.forEach((f, idx) => {
            const w = widthMap.get(f.toLowerCase());
            if (w) applyColumnWidth(table, ths, idx, w);
          });
          try {
            const tn = cleanTableName(cfg.DictTable);
            const cols = fields.map((f, idx) => ({ fieldName: f, width: Math.round(ths[idx].getBoundingClientRect().width) }));
            localStorage.setItem(`colwidth:${tn}`, JSON.stringify(cols));
          } catch { }
        }
        initColumnResize(table, cfg.DictTable);
      }
      const tbody = container.querySelector('tbody');
      if (tbody) {
        tbody.addEventListener('input', (e) => {
          window.__activeDetailGrid = 'paper3l';
          const inp = e.target;
          if (!inp.classList.contains('cell-edit')) return;
          const tr = inp.closest('tr');
          if (tr && tr.dataset.state !== 'added') tr.dataset.state = 'modified';
          window.__unsavedChanges = true;
        });
        tbody.addEventListener('click', (e) => {
          window.__activeDetailGrid = 'paper3l';
          const tr = e.target.closest('tr');
          if (!tr || !tbody.contains(tr)) return;
          tbody.querySelectorAll('tr.row-selected').forEach(x => x.classList.remove('row-selected'));
          tr.classList.add('row-selected');
          window._paper3lSubDetailSelectedRows["1"] = {};
          if (typeof window.__updateToolbarCounts === 'function') {
            window.__updateToolbarCounts();
          }
        });
        tbody.addEventListener('focusin', () => {
          window.__activeDetailGrid = 'paper3l';
          if (typeof window.__updateToolbarCounts === 'function') {
            window.__updateToolbarCounts();
          }
        });
        tbody.addEventListener('dblclick', (e) => {
          const td = e.target.closest('td');
          if (!td || !tbody.contains(td)) return;
          const field = td.dataset.lookupField;
          if (!field) return;
          const fieldLower = field.toLowerCase();
          const map = lookupMaps.get(fieldLower);
          if (!map || map.size === 0) return;
          openLookupDropdown(td, field, map);
        });
      }

      applyEditMode(!!window.__headerIsEdit);
      return;
    }

    const fieldDefs = (cfg.Fields || []).length ? cfg.Fields : Object.keys(rows[0]).map(k => ({ FieldName: k, DisplayLabel: k }));
    const fields = fieldDefs.map(f => f.FieldName || f.fieldName).filter(Boolean);
    window._paper3lSubDetailSelectedRows = window._paper3lSubDetailSelectedRows || {};

    let html = '<div style="overflow:auto;"><table class="erp-table"><thead><tr>';
    fieldDefs.forEach(f => {
      const fn = f.FieldName || f.fieldName;
      if (!fn) return;
      const lbl = f.DisplayLabel || f.displayLabel || fn;
      html += `<th class="align-left" data-field="${escapeHtml(fn)}" style="position:relative;"><span class="th-text">${escapeHtml(lbl)}</span><span class="col-resizer" draggable="false"></span></th>`;
    });
    html += '</tr></thead><tbody>';

    rows.forEach((r, idx) => {
      html += `<tr data-idx="${idx}" data-state="unchanged">`;
      fields.forEach(fn => {
        const raw = getCellValue(r, fn);
        const hasField = hasFieldCaseInsensitive(r, fn);
        if (typeof raw === 'object') {
          const fieldLower = fn.toLowerCase();
          const isReadOnly = readOnlyMap.get(fieldLower) === true;
          const roClass = isReadOnly ? ' readonly-cell' : '';
          const roAttr = isReadOnly ? ' data-readonly="1" readonly' : ' data-readonly="0"';
          const fieldMeta = metaMap.get(fieldLower);
          const alignClass = getAlignClass(fieldMeta, raw);
          const isDate = isDateType(fieldMeta);
          const dateEditClass = isDate ? ' date-dropdown' : '';
          const dateValue = isDate ? normalizeDateForPicker('') : '';
          const dateAddon = isDate
            ? `<input type="date" class="cell-edit d-none cell-date-input" tabindex="-1" aria-hidden="true" value="${escapeHtml(dateValue)}"${isReadOnly ? ' disabled' : ''}>
               <button type="button" class="cell-edit d-none date-toggle" aria-label="選擇日期" tabindex="-1"${isReadOnly ? ' disabled' : ''}></button>`
            : '';
          html += `<td class="${alignClass}" data-readonly="${isReadOnly ? '1' : '0'}"><span class="cell-view${roClass}"></span><input class="cell-edit d-none${roClass}${dateEditClass}" data-field="${escapeHtml(fn)}" value=""${roAttr}>${dateAddon}${partNumBtn}</td>`;
          return;
        }
        const fieldLower = fn.toLowerCase();
        const isReadOnly = readOnlyMap.get(fieldLower) === true;
        const roClass = isReadOnly ? ' readonly-cell' : '';
        const roAttr = isReadOnly ? ' data-readonly="1" readonly' : ' data-readonly="0"';
        let meta = lookupMeta.get(fieldLower);
        let lookupMap = lookupMaps.get(fieldLower);
        const fieldMeta = metaMap.get(fieldLower);
        if (!meta) {
          const alt = lookupResultMap.get(fieldLower);
          if (alt) {
            meta = alt.meta;
            lookupMap = alt.map;
          }
        }
        let display = raw;
        let displayIsLookup = false;
        const metaKeySelf = (meta?.keySelf || '').toString().toLowerCase();
        const metaKey = (meta?.key || '').toString().toLowerCase();
        const metaResult = (meta?.result || '').toString().toLowerCase();
        const hasMultiKey = meta?.source === 'ocx'
          && Array.isArray(meta?.keyMaps)
          && meta.keyMaps.length > 1;
        const allowLookup = !!(meta && meta.table && meta.key && meta.result)
          && !hasMultiKey
          && fieldLower !== metaKeySelf
          && fieldLower !== metaKey;
        const metaFieldLower = (meta?.field || '').toString().toLowerCase();
        const canDropdown = !!(meta?.source === 'lookup'
          && lookupMap && lookupMap.size
          && ((metaFieldLower && metaFieldLower === fieldLower) || (metaResult && metaResult === fieldLower)));
        const allowDisplayLookup = allowLookup && !canDropdown;
        if (allowDisplayLookup && lookupMap) {
          let matched = false;
          let key = display;
          if ((!key || String(key).trim() === '') && (meta.keySelf || meta.key)) {
            const fallbackKey = meta.keySelf || meta.key || '';
            const fallback = getValueCaseInsensitive(r, fallbackKey);
            key = fallback == null ? '' : String(fallback);
          }
          const keyStr = key == null ? '' : String(key);
          if (keyStr && lookupMap.has(keyStr)) {
            display = lookupMap.get(keyStr) ?? keyStr;
            matched = true;
          }
          const trimmed = keyStr.trim();
          if (!matched && trimmed && lookupMap.has(trimmed)) {
            display = lookupMap.get(trimmed) ?? trimmed;
            matched = true;
          }
          displayIsLookup = matched;
          if (!matched && meta?.source === 'ocx' && !hasField) display = '';
        } else if (typeof display === 'string' && display.includes(' - ')) {
          display = display.split(' - ')[0].trim();
        }
        if (hasMultiKey && !hasField && fieldLower !== metaKeySelf && fieldLower !== metaKey) {
          display = '';
        }
        let v = display == null || typeof display === 'object' ? '' : String(display);
        if (!displayIsLookup) {
          v = formatDisplayByMeta(v, fieldMeta);
        }
        const inputValue = (isReadOnly || !allowLookup) ? v : raw;
        const viewText = (v == null ? '' : String(v)).trim();
        const editText = (inputValue == null ? '' : String(inputValue)).trim();
        const alignClass = getAlignClass(fieldMeta, raw);
        const isDate = isDateType(fieldMeta);
        const tdClasses = [alignClass];
        if (canDropdown) tdClasses.push('lookup-cell');
        const isPartNum = isPartNumField(fn);
        if (isPartNum) tdClasses.push('partnum-field');
        const classAttr = tdClasses.length ? ` class="${tdClasses.join(' ')}"` : '';
        const partNumBtn = isPartNum ? '<button type="button" class="partnum-lookup-btn" title="開啟庫存一覽" aria-label="開啟庫存一覽">?</button>' : '';
        const keyFieldAttr = canDropdown ? ` data-lookup-key-field="${escapeHtml(meta?.key || '')}"` : "";
        const resultFieldAttr = canDropdown ? ` data-lookup-result-field="${escapeHtml(meta?.result || '')}"` : "";
        const lookupAttr = canDropdown
          ? ` data-lookup-field="${escapeHtml(fn)}"${keyFieldAttr}${resultFieldAttr}`
          : "";
        const dateEditClass = isDate ? ' date-dropdown' : '';
        const dateValue = isDate ? normalizeDateForPicker(editText) : '';
        const dateAddon = isDate
          ? `<input type="date" class="cell-edit d-none cell-date-input" tabindex="-1" aria-hidden="true" value="${escapeHtml(dateValue)}"${isReadOnly ? ' disabled' : ''}>
             <button type="button" class="cell-edit d-none date-toggle" aria-label="選擇日期" tabindex="-1"${isReadOnly ? ' disabled' : ''}></button>`
          : '';
        html += `<td${classAttr}${lookupAttr} data-readonly="${isReadOnly ? '1' : '0'}"><span class="cell-view${roClass}" data-readonly="${isReadOnly ? '1' : '0'}">${escapeHtml(viewText)}</span><input class="cell-edit d-none${roClass}${dateEditClass}" data-field="${escapeHtml(fn)}" data-init="${escapeHtml(editText)}" value="${escapeHtml(editText)}"${roAttr}>${dateAddon}${partNumBtn}</td>`;
      });
      html += '</tr>';
    });

    html += '</tbody></table></div>';
    container.innerHTML = html;
    initDatePickers(container);
    if (countEl) countEl.textContent = `0 / ${rows.length}`;
    window._paper3lSubDetailSelectedRows["1"] = rows[0] || null;

    const table = container.querySelector('table.erp-table');
    if (table) {
      applySavedWidths(table, cfg.DictTable, fields);
      const widthMap = await fetchFieldWidths(cfg.DictTable);
      if (widthMap.size) {
        const ths = Array.from(table.querySelectorAll('thead th'));
        fields.forEach((f, idx) => {
          const w = widthMap.get(f.toLowerCase());
          if (w) applyColumnWidth(table, ths, idx, w);
        });
        try {
          const tn = cleanTableName(cfg.DictTable);
          const cols = fields.map((f, idx) => ({ fieldName: f, width: Math.round(ths[idx].getBoundingClientRect().width) }));
          localStorage.setItem(`colwidth:${tn}`, JSON.stringify(cols));
        } catch { }
      }
      initColumnResize(table, cfg.DictTable);
    }

    const tbody = container.querySelector('tbody');
    if (tbody) {
      tbody.addEventListener('input', (e) => {
        window.__activeDetailGrid = 'paper3l';
        const inp = e.target;
        if (!inp.classList.contains('cell-edit')) return;
        const tr = inp.closest('tr');
        if (tr && tr.dataset.state !== 'added') tr.dataset.state = 'modified';
        window.__unsavedChanges = true;
      });
      tbody.addEventListener('click', (e) => {
        window.__activeDetailGrid = 'paper3l';
        const tr = e.target.closest('tr');
        if (!tr || !tbody.contains(tr)) return;
        tbody.querySelectorAll('tr.row-selected').forEach(x => x.classList.remove('row-selected'));
        tr.classList.add('row-selected');
        const idx = parseInt(tr.dataset.idx || '-1', 10);
        if (!isNaN(idx) && rows[idx]) {
          window._paper3lSubDetailSelectedRows["1"] = rows[idx];
        }
        if (typeof window.__updateToolbarCounts === 'function') {
          window.__updateToolbarCounts();
        }
      });
      tbody.addEventListener('focusin', () => {
        window.__activeDetailGrid = 'paper3l';
        if (typeof window.__updateToolbarCounts === 'function') {
          window.__updateToolbarCounts();
        }
      });
      tbody.addEventListener('dblclick', (e) => {
        const td = e.target.closest('td');
        if (!td || !tbody.contains(td)) return;
        const field = td.dataset.lookupField;
        if (!field) return;
        const fieldLower = field.toLowerCase();
        const map = lookupMaps.get(fieldLower);
        if (!map || map.size === 0) return;
        openLookupDropdown(td, field, map);
      });
    }

    applyEditMode(!!window.__headerIsEdit);

    window.__paper3lSubDetailCollectChanges = () => {
      const t = container?.querySelector('tbody');
      if (!t) return null;
      const changes = [];
      t.querySelectorAll('tr[data-state="modified"], tr[data-state="added"]').forEach(tr => {
        const row = {};
        const keyCandidates = new Set(['papernum', 'item', 'seqnum', 'seq', 'serialnum', 'linenum', 'lineid', 'rowno']);
        const isAdded = (tr.dataset.state || '').toString().toLowerCase() === 'added';
        tr.querySelectorAll('input.cell-edit[data-field]').forEach(inp => {
          const field = inp.dataset.field || '';
          if (!field) return;
          const currentValue = (inp.value ?? '').trim();
          const initValue = (inp.dataset.init ?? '').toString().trim();
          const isKey = keyCandidates.has(field.toLowerCase());
          if (!isAdded && !isKey && currentValue === initValue) return;
          row[field] = currentValue;
        });
        if (Object.keys(row).length > 0) changes.push(row);
      });
      if (changes.length === 0) return null;
      const keyFields = buildKeyFieldsFromRow(changes[0]);
      return { tableName: cfg.DictTable, changes, keyFields };
    };

    window.__paper3lSubDetailAddRow = () => {
      const t = container?.querySelector('tbody');
      if (!t) return { handled: false };

      const pending = t.querySelector('tr[data-state="added"]');
      if (pending) {
        t.querySelectorAll('tr.row-selected').forEach(x => x.classList.remove('row-selected'));
        pending.classList.add('row-selected');
        pending.querySelectorAll('.cell-view').forEach(el => el.classList.add('d-none'));
        pending.querySelectorAll('.cell-edit').forEach(el => el.classList.remove('d-none'));
        pending.querySelector('.cell-edit')?.focus();
        return { handled: true, ok: true, reused: true };
      }

      const blankRow = Array.from(t.querySelectorAll('tr')).find(isBlankRow);
      if (blankRow) {
        t.querySelectorAll('tr.row-selected').forEach(x => x.classList.remove('row-selected'));
        blankRow.classList.add('row-selected');
        blankRow.dataset.state = 'added';
        blankRow.querySelectorAll('.cell-view').forEach(el => el.classList.add('d-none'));
        blankRow.querySelectorAll('.cell-edit').forEach(el => el.classList.remove('d-none'));
        blankRow.querySelector('.cell-edit')?.focus();
        return { handled: true, ok: true, reused: true };
      }

      const isEditing = !!container.querySelector('.cell-edit:not(.d-none)');
      const viewClass = isEditing ? 'cell-view d-none' : 'cell-view';
      const editClass = isEditing ? 'cell-edit' : 'cell-edit d-none';

      let html = '<tr data-state="added" class="row-selected">';
      fields.forEach(fn => {
        const fieldLower = fn.toLowerCase();
        const isReadOnly = readOnlyMap.get(fieldLower) === true;
        const roClass = isReadOnly ? ' readonly-cell' : '';
        const roAttr = isReadOnly ? ' data-readonly="1" readonly' : ' data-readonly="0"';
        let meta = lookupMeta.get(fieldLower);
        let lookupMap = lookupMaps.get(fieldLower);
        if (!meta) {
          const alt = lookupResultMap.get(fieldLower);
          if (alt) {
            meta = alt.meta;
            lookupMap = alt.map;
          }
        }
        const metaFieldLower = (meta?.field || '').toString().toLowerCase();
        const canDropdown = !!(meta?.source === 'lookup'
          && lookupMap && lookupMap.size
          && ((metaFieldLower && metaFieldLower === fieldLower) || (meta?.result || '').toString().toLowerCase() === fieldLower));
        const fieldMeta = dictMetaMap.get(fieldLower);
        const alignClass = getAlignClass(fieldMeta, null);
        const tdClasses = [alignClass];
        if (canDropdown) tdClasses.push('lookup-cell');
        const isPartNum = isPartNumField(fn);
        if (isPartNum) tdClasses.push('partnum-field');
        const classAttr = tdClasses.length ? ` class="${tdClasses.join(' ')}"` : '';
        const partNumBtn = isPartNum ? '<button type="button" class="partnum-lookup-btn" title="開啟庫存一覽" aria-label="開啟庫存一覽">?</button>' : '';
        const keyFieldAttr = canDropdown ? ` data-lookup-key-field="${escapeHtml(meta?.key || '')}"` : "";
        const resultFieldAttr = canDropdown ? ` data-lookup-result-field="${escapeHtml(meta?.result || '')}"` : "";
        const lookupAttr = canDropdown
          ? ` data-lookup-field="${escapeHtml(fn)}"${keyFieldAttr}${resultFieldAttr}`
          : "";
        html += `<td${classAttr}${lookupAttr} data-readonly="${isReadOnly ? '1' : '0'}"><span class="${viewClass}${roClass}" data-readonly="${isReadOnly ? '1' : '0'}"></span><input class="${editClass}${roClass}" data-field="${escapeHtml(fn)}" data-init="" value=""${roAttr}>${partNumBtn}</td>`;
      });
      html += '</tr>';

      t.querySelectorAll('tr.row-selected').forEach(x => x.classList.remove('row-selected'));
      t.insertAdjacentHTML('beforeend', html);
      const newRow = t.querySelector('tr:last-child');
      newRow?.querySelector('.cell-edit')?.focus();
      return { handled: true, ok: true };
    };

    window.__paper3lSubDetailDeleteRow = async () => {
      const t = container?.querySelector('tbody');
      if (!t) return { handled: false };
      const selected = t.querySelector('tr.row-selected');
      if (!selected) return { handled: true, ok: false, reason: 'no-row' };

      const state = (selected.dataset.state || '').toString().toLowerCase();
      if (state === 'added') {
        const next = selected.nextElementSibling || selected.previousElementSibling;
        selected.remove();
        if (next) next.classList.add('row-selected');
        return { handled: true, ok: true };
      }

      let row = {};
      selected.querySelectorAll('input.cell-edit[data-field]').forEach(inp => {
        const field = (inp.dataset.field || '').toString();
        if (!field) return;
        if (inp.type === 'checkbox') row[field] = inp.checked ? '1' : '0';
        else row[field] = (inp.value ?? '').toString().trim();
      });

      const cached = window._paper3lSubDetailSelectedRows?.["1"];
      let keyFields = buildKeyFieldsFromRow(row);
      if (keyFields.length === 0 && cached) {
        keyFields = buildKeyFieldsFromRow(cached);
        keyFields.forEach(k => {
          if (row[k] == null || row[k] === '') row[k] = cached[k];
        });
      }
      if (keyFields.length === 0) return { handled: true, ok: false, reason: 'no-keys' };

      const { isConfirmed } = await Swal.fire({
        icon: 'question',
        title: '確定要刪除這一筆明細？',
        showCancelButton: true,
        confirmButtonText: '刪除',
        cancelButtonText: '取消',
        confirmButtonColor: '#dc3545'
      });
      if (!isConfirmed) return { handled: true, ok: true, canceled: true };

      const payload = { TableName: cfg.DictTable, Data: [{ ...row, __delete: true }], KeyFields: keyFields };
      const resp = await fetch('/api/CommonTable/SaveTableChanges', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!resp.ok) {
        let errorMessage = `HTTP ${resp.status}`;
        try {
          const errorData = await resp.json();
          if (errorData && (errorData.error || errorData.message)) {
            errorMessage = errorData.error || errorData.message;
          }
        } catch {
          try {
            const errorText = await resp.text();
            if (errorText) errorMessage = errorText;
          } catch { }
        }
        return { handled: true, ok: false, reason: 'delete-failed', error: errorMessage };
      }

      const next = selected.nextElementSibling || selected.previousElementSibling;
      selected.remove();
      if (next) next.classList.add('row-selected');
      return { handled: true, ok: true };
    };
  }

  window.__paper3lSubDetailReset = async (keepEdit = true) => {
    if (!container) return;
    let rows = [];
    if (Array.isArray(lastRows)) {
      try {
        rows = JSON.parse(JSON.stringify(lastRows));
      } catch {
        rows = lastRows.map(r => ({ ...r }));
      }
    }
    await renderTable(rows);
    if (keepEdit) applyEditMode(true);
  };

  window.__paper3lSubDetailRefresh = async () => {
    const parentTabId = (cfg.ParentTabId || '').toString();
    const rowData = window._multiTabSelectedRows?.[parentTabId] || null;
    await loadSubDetail(rowData || null);
  };

  window.addEventListener('multiTabRowSelected', function(ev) {
    const detail = ev && ev.detail ? ev.detail : null;
    if (!detail) return;
    const tabId = detail.tabId;
    if ((cfg.ParentTabId || '').toString() && tabId !== cfg.ParentTabId) return;
    loadSubDetail(detail.rowData || null);
  });

  window.addEventListener('headerEditModeChanged', (e) => {
    applyEditMode(!!(e?.detail?.isEdit));
  });
})();
</script>

<style>
.paper3l-subdetail .erp-table-wrapper{
  background: #fff;
  box-shadow: 0 4px 18px 0 #c3d4e6;
  border-radius: 13px;
  border: 1px solid #d6dbe5;
  margin-top: 0;
}

.paper3l-subdetail .erp-table{
  width: max-content;
  display: inline-table;
  border-collapse: separate;
  border-spacing: 0;
  font-size: var(--field-value-size);
  background: #fff;
  table-layout: fixed;
}

.paper3l-subdetail .erp-table thead tr{ background: #e7ecf3; }
.paper3l-subdetail .erp-table th,
.paper3l-subdetail .erp-table td{
  background: #f1f5fb;
  padding: 0;
  border-bottom: 1px solid #9fb1d0;
  white-space: nowrap;
  text-align: center;
  font-weight: 500;
  border-right: 1px solid #9fb1d0;
  height: auto;
  position: relative;
}

.paper3l-subdetail .erp-table th.align-left,
.paper3l-subdetail .erp-table td.align-left{
  text-align: left;
}
.paper3l-subdetail .erp-table th.align-right,
.paper3l-subdetail .erp-table td.align-right{
  text-align: right;
}
.paper3l-subdetail .erp-table th:last-child,
.paper3l-subdetail .erp-table td:last-child{ border-right: 1px solid #9fb1d0; }
.paper3l-subdetail .erp-table th:first-child,
.paper3l-subdetail .erp-table td:first-child{ border-left: 1px solid #9fb1d0; }
.paper3l-subdetail .erp-table th{
  color: #124d8b;
  font-weight: 700;
  font-size: var(--field-label-size);
  letter-spacing: .5px;
  background: #e7ecf3;
  position: sticky;
  top: 0;
  z-index: 10;
  border-top: 1px solid #9fb1d0;
}
.paper3l-subdetail .erp-table th .th-text{
  display: inline-block;
  padding-left: 4px;
}

.paper3l-subdetail .subdetail-title{
  display: inline-block;
  padding: var(--tab-pad-y) var(--tab-pad-x);
  border-radius: 8px 8px 0 0;
  border: 1px solid #bdd2f7;
  border-bottom: 0;
  background: #fff;
  color: #124d8b;
  font-weight: 700;
  box-shadow: 0 2px 6px 0 #e4ecf7;
  font-size: var(--field-label-size);
  margin-bottom: 0;
}

.paper3l-subdetail .erp-table th { position: relative; }
.paper3l-subdetail .erp-table th .col-resizer{
  position: absolute;
  top: 0; right: 0; bottom: 0;
  width: 8px;
  cursor: col-resize;
  user-select: none;
  z-index: 20;
  display: block;
}
.paper3l-subdetail .erp-table th.resizing,
.paper3l-subdetail .erp-table td.resizing,
body.resizing { cursor: col-resize !important; }

.paper3l-subdetail .erp-table td .cell-view{
  display: block;
  width: 100%;
  min-height: 22px;
  text-align: inherit;
  padding: 2px 6px;
  box-sizing: border-box;
  white-space: nowrap;
  line-height: 20px;
}
.paper3l-subdetail .erp-table td .cell-edit{
  display: block;
  width: 100%;
  min-height: 22px;
  box-sizing: border-box;
  margin: 0;
  border: none;
  border-radius: 0;
  background: #fff;
  font-size: inherit;
  font-weight: inherit;
  font-family: inherit;
  line-height: 20px;
  text-align: inherit;
  padding: 2px 6px;
  white-space: nowrap;
}
.paper3l-subdetail .erp-table td .cell-edit.date-dropdown{
  padding-right: 14px;
}
.paper3l-subdetail .erp-table td .date-toggle{
  position: absolute;
  right: 3px;
  top: 50%;
  transform: translateY(-50%);
  width: 14px !important;
  height: 14px !important;
  border: 0;
  background: transparent;
  cursor: pointer;
  z-index: 3;
  padding: 0 !important;
  display: inline-flex !important;
  align-items: center;
  justify-content: center;
  line-height: 1 !important;
}
.paper3l-subdetail .erp-table td .date-toggle,
.paper3l-subdetail .erp-table td .cell-date-input{
  display: none !important;
}
.paper3l-subdetail .erp-table.date-edit td .date-toggle,
.paper3l-subdetail .erp-table.date-edit td .cell-date-input{
  display: inline-flex !important;
}
.paper3l-subdetail .erp-table td .date-toggle::before{
  content: "";
  display: block;
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 6px solid #6b7280;
  margin: 0 auto;
}
.paper3l-subdetail .erp-table td .cell-date-input{
  position: absolute;
  right: 3px;
  top: 50%;
  transform: translateY(-50%);
  width: 14px !important;
  height: 14px !important;
  opacity: 0;
  pointer-events: none;
  z-index: 2;
  padding: 0 !important;
  margin: 0 !important;
}
.paper3l-subdetail .erp-table td .cell-edit:focus{
  outline: 2px solid #0d6efd;
  outline-offset: -2px;
  background: #fffef0;
}

.paper3l-subdetail .erp-table td.lookup-cell .cell-view,
.paper3l-subdetail .erp-table td.lookup-cell .cell-edit{
  background: #FFFACD;
}

.paper3l-subdetail .erp-table td .cell-view.readonly-cell,
.paper3l-subdetail .erp-table td .cell-edit.readonly-cell{
  background: #e9ecef !important;
  color: #6c757d !important;
  cursor: not-allowed;
}
.paper3l-subdetail .erp-table td .cell-edit.readonly-cell:focus{
  outline: none;
  background: #e9ecef !important;
}

.lookup-dropdown-list{
  z-index: 2000;
  background: #fff;
  border: 1px solid #b6c2d9;
  border-radius: 6px;
  box-shadow: 0 8px 20px rgba(30, 41, 59, 0.18);
  overflow: auto;
}

.lookup-dropdown-item{
  display: block;
  width: 100%;
  border: 0;
  background: transparent;
  text-align: left;
  padding: 6px 10px;
  font-size: var(--field-value-size);
  cursor: pointer;
}

.lookup-dropdown-item:hover,
.lookup-dropdown-item:focus{
  background: #e2e8f0;
  outline: none;
}

.lookup-dropdown-item.is-selected{
  background: #dbeafe;
}
</style>
