@using System.Text.Json
@{
    var sd = ViewData["SubDetail1"] as PcbErpApi.Pages.DynamicTemplate.Paper3LDetailModel.SubDetailClientConfig;
    if (sd == null || string.IsNullOrWhiteSpace(sd.DictTable))
    {
        return;
    }

    var json = JsonSerializer.Serialize(sd, new JsonSerializerOptions { PropertyNamingPolicy = null });
}

<div class="paper3l-subdetail mt-0">
    <div class="d-flex align-items-center justify-content-between mb-0">
        <div class="subdetail-title">@sd.Title</div>
        <div class="text-muted small" id="paper3l-subdetail-count"></div>
    </div>
    <div id="paper3l-subdetail-container" class="erp-table-wrapper p-2" style="max-width:1400px;" data-dict-table="@sd.DictTable">
        <div class="alert alert-info mb-0">請先在上方明細選取一筆資料</div>
    </div>
</div>

<style>
  .paper3l-subdetail table th{ font-size: var(--field-label-size); }
  .paper3l-subdetail table td{ font-size: var(--field-value-size); }
</style>

<script>
(function() {
  const cfg = @Html.Raw(json);
  const container = document.getElementById('paper3l-subdetail-container');
  const countEl = document.getElementById('paper3l-subdetail-count');

  function cleanTableName(t) {
    return (t || '').toString().replace(/^dbo\./i, '').trim().toLowerCase();
  }

  function escapeHtml(v) {
    return String(v ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function normalizeFieldKey(k) { return (k || '').toString().trim().toLowerCase(); }

  function getValueCaseInsensitive(obj, key) {
    if (!obj || !key) return undefined;
    const k = normalizeFieldKey(key);
    const hitKey = Object.keys(obj).find(x => normalizeFieldKey(x) === k);
    return hitKey ? obj[hitKey] : undefined;
  }

  function hasFieldCaseInsensitive(obj, key) {
    if (!obj || !key) return false;
    const k = normalizeFieldKey(key);
    return Object.keys(obj).some(x => normalizeFieldKey(x) === k);
  }

  const LOOKUP_META_CACHE = new Map(); // tn -> Map(fieldLower -> { table, key, result, keySelf, field })
  const LOOKUP_DATA_CACHE = new Map(); // tn -> Map(fieldLower -> Map(key -> label))

  async function fetchLookupMeta(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Map();
    if (LOOKUP_META_CACHE.has(tn)) return LOOKUP_META_CACHE.get(tn);
    try {
      const res = await fetch(`/api/TableFieldLayout/GetTableFieldsFull?table=${encodeURIComponent(tn)}&lang=TW`);
      if (!res.ok) {
        const empty = new Map();
        LOOKUP_META_CACHE.set(tn, empty);
        return empty;
      }
      const rows = await res.json();
      const map = new Map();
      (rows || []).forEach(r => {
        const field = (r.fieldName || r.FieldName || '').toString();
        if (!field) return;
        const table = (r.lookupTable || r.LookupTable || '').toString();
        const key = (r.lookupKeyField || r.LookupKeyField || '').toString();
        const result = (r.lookupResultField || r.LookupResultField || '').toString();
        const ocxTable = (r.ocxLKTableName || r.OCXLKTableName || '').toString();
        const ocxResult = (r.ocxLKResultName || r.OCXLKResultName || '').toString();
        const ocxKeyField = (r.keyFieldName || r.KeyFieldName || '').toString();
        const ocxKeySelf = (r.keySelfName || r.KeySelfName || '').toString();
        const keyMapsRaw = (r.keyMapsJson || r.KeyMapsJson || '').toString();
        let keyMaps = [];
        if (keyMapsRaw) {
          try { keyMaps = JSON.parse(keyMapsRaw) || []; } catch { keyMaps = []; }
        }
        if (table && key && result) {
          map.set(field.toLowerCase(), { field, table, key, result, keySelf: '', source: 'lookup', keyMaps });
          return;
        }
        if (ocxTable && ocxKeyField && ocxResult) {
          map.set(field.toLowerCase(), { field, table: ocxTable, key: ocxKeyField, result: ocxResult, keySelf: ocxKeySelf, source: 'ocx', keyMaps });
        }
      });
      LOOKUP_META_CACHE.set(tn, map);
      return map;
    } catch {
      const empty = new Map();
      LOOKUP_META_CACHE.set(tn, empty);
      return empty;
    }
  }

  async function fetchLookupMaps(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Map();
    if (LOOKUP_DATA_CACHE.has(tn)) return LOOKUP_DATA_CACHE.get(tn);
    const meta = await fetchLookupMeta(dictTable);
    const fieldMap = new Map();
    for (const [field, cfg] of meta.entries()) {
      try {
        const url = `/api/TableFieldLayout/LookupData?table=${encodeURIComponent(cfg.table)}&key=${encodeURIComponent(cfg.key)}&result=${encodeURIComponent(cfg.result)}`;
        const res = await fetch(url);
        if (!res.ok) continue;
        const data = await res.json();
        const map = new Map();
        (data || []).forEach(row => {
          const key = row.key == null ? '' : String(row.key);
          if (key === '') return;
          const labelParts = Object.keys(row)
            .filter(p => p.startsWith('result'))
            .map(p => row[p])
            .filter(v => v != null && typeof v !== 'object' && String(v).trim() !== '')
            .map(v => String(v));
          const deduped = labelParts.filter(v => v.trim() !== key.trim());
          const label = (deduped.length ? deduped : labelParts).join(' - ');
          const trimmed = key.trim();
          map.set(key, label || key);
          if (trimmed && trimmed !== key) map.set(trimmed, label || trimmed);
        });
        fieldMap.set(field, map);
      } catch { }
    }
    LOOKUP_DATA_CACHE.set(tn, fieldMap);
    return fieldMap;
  }

  async function fetchFieldWidths(dictTable) {
    const tn = cleanTableName(dictTable);
    if (!tn) return new Map();
    try {
      const res = await fetch(`/api/TableFieldLayout/DictFields?table=${encodeURIComponent(tn)}&lang=TW`);
      if (!res.ok) return new Map();
      const rows = await res.json();
      const map = new Map();
      (rows || []).forEach(r => {
        const field = (r.fieldName || r.FieldName || '').toString();
        const w = r.fieldWidth ?? r.FieldWidth;
        const ds = r.displaySize ?? r.DisplaySize;
        if (!field) return;
        const px = Number.isFinite(w) ? Number(w) : (Number.isFinite(ds) ? Number(ds) * 10 : null);
        if (px && px > 0) map.set(field.toLowerCase(), Math.round(px));
      });
      return map;
    } catch {
      return new Map();
    }
  }

  function applyColumnWidth(table, ths, index, width) {
    const w = Math.max(30, Math.round(width));
    const th = ths[index];
    if (!th) return;
    th.style.width = `${w}px`;
    Array.from(table.querySelectorAll(`tbody tr td:nth-child(${index + 1})`)).forEach(td => td.style.width = `${w}px`);
  }

  function applySavedWidths(table, dictTable, fields) {
    const tn = cleanTableName(dictTable);
    if (!tn) return;
    try {
      const raw = localStorage.getItem(`colwidth:${tn}`);
      if (!raw) return;
      const cols = JSON.parse(raw) || [];
      const ths = Array.from(table.querySelectorAll('thead th'));
      cols.forEach(c => {
        const f = (c.fieldName || '').toString();
        const w = Number(c.width);
        if (!f || !Number.isFinite(w)) return;
        const idx = fields.findIndex(x => x.toLowerCase() === f.toLowerCase());
        if (idx >= 0) applyColumnWidth(table, ths, idx, w);
      });
    } catch { }
  }

  const resizeState = window.__paper3lResizeState || (window.__paper3lResizeState = {
    active: false,
    table: null,
    ths: [],
    dictTable: '',
    thIndex: -1,
    startX: 0,
    startWidth: 0,
    saveTimer: null
  });

  async function persistWidths(snapshot) {
    const table = snapshot?.table;
    const ths = snapshot?.ths || [];
    const dictTable = snapshot?.dictTable || '';
    const tn = cleanTableName(dictTable);
    if (!table || !ths.length || !tn) return;
    try {
      const payload = {
        tableName: tn,
        cols: ths.map(th => ({ fieldName: th.dataset.field, width: Math.round(th.getBoundingClientRect().width) }))
      };
      await fetch('/api/TableFieldLayout/SaveDetailLayout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      }).catch(() => { });
      localStorage.setItem(`colwidth:${tn}`, JSON.stringify(payload.cols));
    } catch { }
  }

  function debouncePersist(snapshot) {
    clearTimeout(resizeState.saveTimer);
    const snap = snapshot ? { ...snapshot } : null;
    resizeState.saveTimer = setTimeout(() => persistWidths(snap), 400);
  }

  if (!window.__paper3lResizeBound) {
    window.__paper3lResizeBound = true;
    document.addEventListener('mousemove', (e) => {
      if (!resizeState.active || !resizeState.table) return;
      const dx = e.pageX - resizeState.startX;
      const newW = Math.max(30, resizeState.startWidth + dx);
      applyColumnWidth(resizeState.table, resizeState.ths, resizeState.thIndex, newW);
    });
    document.addEventListener('mouseup', () => {
      if (!resizeState.active) return;
      resizeState.active = false;
      document.body.classList.remove('resizing');
      resizeState.ths.forEach(th => th.classList.remove('resizing'));
      Array.from(resizeState.table.querySelectorAll('tbody td.resizing')).forEach(td => td.classList.remove('resizing'));
      debouncePersist({ table: resizeState.table, ths: resizeState.ths, dictTable: resizeState.dictTable });
      resizeState.table = null;
      resizeState.ths = [];
      resizeState.dictTable = '';
      resizeState.thIndex = -1;
    });
  }

  function initColumnResize(table, dictTable) {
    if (!table) return;
    const ths = Array.from(table.querySelectorAll('thead th'));
    ths.forEach((th, idx) => {
      const handle = th.querySelector('.col-resizer');
      if (!handle) return;
      handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        resizeState.active = true;
        resizeState.table = table;
        resizeState.ths = ths;
        resizeState.dictTable = dictTable;
        resizeState.thIndex = idx;
        resizeState.startX = e.pageX;
        resizeState.startWidth = th.getBoundingClientRect().width;
        document.body.classList.add('resizing');
        th.classList.add('resizing');
        Array.from(table.querySelectorAll(`tbody tr td:nth-child(${idx + 1})`)).forEach(td => td.classList.add('resizing'));
      });
    });
  }

  async function loadSubDetail(rowData) {
    if (!container) return;
    if (!rowData) {
      container.innerHTML = '<div class="alert alert-info mb-0">請先在上方明細選取一筆資料</div>';
      if (countEl) countEl.textContent = '';
      window._paper3lSubDetailSelectedRows = window._paper3lSubDetailSelectedRows || {};
      window._paper3lSubDetailSelectedRows["1"] = null;
      return;
    }

    const filters = [];
    (cfg.KeyMap || []).forEach(km => {
      const parent = km.ParentField || km.parentField || km.Parent || km.Master;
      const child = km.ChildField || km.childField || km.Detail || km.Child;
      if (!parent || !child) return;
      const v = getValueCaseInsensitive(rowData, parent);
      if (v === undefined || v === null || String(v).trim() === '') return;
      filters.push({ Field: child, Op: '=', Value: String(v) });
    });

    // 若 mdKey 沒設定，至少用 PaperNum 兜底（避免整表撈）
    if (filters.length === 0) {
      const pn = getValueCaseInsensitive(rowData, 'PaperNum');
      if (pn) filters.push({ Field: 'PaperNum', Op: '=', Value: String(pn) });
    }

    if (filters.length === 0) {
      await renderTable([]);
      return;
    }

    filters.push({ Field: 'page', Op: '', Value: '1' });
    filters.push({ Field: 'pageSize', Op: '', Value: '9999' });

    container.innerHTML = '<div class="text-center py-4"><div class="spinner-border text-primary" role="status"></div></div>';

    try {
      const resp = await fetch('/api/DynamicTable/PagedQuery', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ table: cfg.DictTable, filters })
      });
      if (!resp.ok) {
        const text = await resp.text();
        throw new Error(text || `HTTP ${resp.status}`);
      }

      const json = await resp.json();
      const rows = (json && json.data) ? json.data : [];
      await renderTable(rows);
    } catch (err) {
      container.innerHTML = `<div class="alert alert-danger mb-0">載入失敗: ${escapeHtml(err && err.message ? err.message : err)}</div>`;
      if (countEl) countEl.textContent = '';
    }
  }

  function getCellValue(row, fieldName) {
    const v = getValueCaseInsensitive(row, fieldName);
    if (v == null) return '';
    if (typeof v === 'object') return '';
    const s = String(v);
    return s === '[object Object]' ? '' : v;
  }

  function applyEditMode(isEdit) {
    container?.querySelectorAll('.cell-view').forEach(el => el.classList.toggle('d-none', isEdit));
    container?.querySelectorAll('.cell-edit').forEach(el => el.classList.toggle('d-none', !isEdit));
  }

  function buildKeyFieldsFromRow(row) {
    const candidates = ['PaperNum', 'Item', 'SeqNum', 'Seq', 'SerialNum', 'LineNum', 'LineId', 'RowNo'];
    return candidates.filter(k => row && row[k] !== undefined);
  }

  async function renderTable(rows) {
    const lookupMeta = await fetchLookupMeta(cfg.DictTable);
    const lookupMaps = await fetchLookupMaps(cfg.DictTable);
    const lookupResultMap = new Map();
    for (const [fieldLower, cfgMeta] of lookupMeta.entries()) {
      const resultLower = (cfgMeta?.result || '').toString().toLowerCase();
      if (!resultLower) continue;
      const map = lookupMaps.get(fieldLower);
      if (!map) continue;
      if (!lookupResultMap.has(resultLower)) lookupResultMap.set(resultLower, { map, meta: cfgMeta });
    }
    if (!Array.isArray(rows) || rows.length === 0) {
      const fieldDefs = (cfg.Fields || []).length ? cfg.Fields : [];
      if (!fieldDefs.length) {
        container.innerHTML = '<div class="alert alert-info mb-0">無資料</div>';
        if (countEl) countEl.textContent = '0 / 0';
        window._paper3lSubDetailSelectedRows = window._paper3lSubDetailSelectedRows || {};
        window._paper3lSubDetailSelectedRows["1"] = null;
        return;
      }

      const fields = fieldDefs.map(f => f.FieldName || f.fieldName).filter(Boolean);
      let html = '<div style="overflow:auto;"><table class="erp-table"><thead><tr>';
      fieldDefs.forEach(f => {
        const fn = f.FieldName || f.fieldName;
        if (!fn) return;
        const lbl = f.DisplayLabel || f.displayLabel || fn;
        html += `<th data-field="${escapeHtml(fn)}" style="position:relative;"><span class="th-text">${escapeHtml(lbl)}</span><span class="col-resizer" draggable="false"></span></th>`;
      });
      html += '</tr></thead><tbody>';
      html += '<tr data-idx="0">';
      fields.forEach(fn => {
        html += `<td><span class="cell-view"></span><input class="cell-edit d-none" data-field="${escapeHtml(fn)}" value=""></td>`;
      });
      html += '</tr></tbody></table></div>';
      container.innerHTML = html;
      if (countEl) countEl.textContent = '0 / 0';
      window._paper3lSubDetailSelectedRows = window._paper3lSubDetailSelectedRows || {};
      window._paper3lSubDetailSelectedRows["1"] = null;
      const table = container.querySelector('table.erp-table');
      if (table) {
        applySavedWidths(table, cfg.DictTable, fields);
        const widthMap = await fetchFieldWidths(cfg.DictTable);
        if (widthMap.size) {
          const ths = Array.from(table.querySelectorAll('thead th'));
          fields.forEach((f, idx) => {
            const w = widthMap.get(f.toLowerCase());
            if (w) applyColumnWidth(table, ths, idx, w);
          });
          try {
            const tn = cleanTableName(cfg.DictTable);
            const cols = fields.map((f, idx) => ({ fieldName: f, width: Math.round(ths[idx].getBoundingClientRect().width) }));
            localStorage.setItem(`colwidth:${tn}`, JSON.stringify(cols));
          } catch { }
        }
        initColumnResize(table, cfg.DictTable);
      }
      applyEditMode(!!window.__headerIsEdit);
      return;
    }

    const fieldDefs = (cfg.Fields || []).length ? cfg.Fields : Object.keys(rows[0]).map(k => ({ FieldName: k, DisplayLabel: k }));
    const fields = fieldDefs.map(f => f.FieldName || f.fieldName).filter(Boolean);
    window._paper3lSubDetailSelectedRows = window._paper3lSubDetailSelectedRows || {};

    let html = '<div style="overflow:auto;"><table class="erp-table"><thead><tr>';
    fieldDefs.forEach(f => {
      const fn = f.FieldName || f.fieldName;
      if (!fn) return;
      const lbl = f.DisplayLabel || f.displayLabel || fn;
      html += `<th data-field="${escapeHtml(fn)}" style="position:relative;"><span class="th-text">${escapeHtml(lbl)}</span><span class="col-resizer" draggable="false"></span></th>`;
    });
    html += '</tr></thead><tbody>';

    rows.forEach((r, idx) => {
      html += `<tr data-idx="${idx}" data-state="unchanged">`;
      fields.forEach(fn => {
        const raw = getCellValue(r, fn);
        const hasField = hasFieldCaseInsensitive(r, fn);
        if (typeof raw === 'object') {
          html += `<td><span class="cell-view"></span><input class="cell-edit d-none" data-field="${escapeHtml(fn)}" value=""></td>`;
          return;
        }
        const fieldLower = fn.toLowerCase();
        let meta = lookupMeta.get(fieldLower);
        let lookupMap = lookupMaps.get(fieldLower);
        if (!meta) {
          const alt = lookupResultMap.get(fieldLower);
          if (alt) {
            meta = alt.meta;
            lookupMap = alt.map;
          }
        }
        let display = raw;
        const metaKeySelf = (meta?.keySelf || '').toString().toLowerCase();
        const metaKey = (meta?.key || '').toString().toLowerCase();
        const hasMultiKey = meta?.source === 'ocx'
          && Array.isArray(meta?.keyMaps)
          && meta.keyMaps.length > 1;
        const allowLookup = !!(meta && meta.table && meta.key && meta.result)
          && !hasMultiKey
          && fieldLower !== metaKeySelf
          && fieldLower !== metaKey;
        if (allowLookup && lookupMap) {
          let matched = false;
          let key = display;
          if ((!key || String(key).trim() === '') && (meta.keySelf || meta.key)) {
            const fallbackKey = meta.keySelf || meta.key || '';
            const fallback = getValueCaseInsensitive(r, fallbackKey);
            key = fallback == null ? '' : String(fallback);
          }
          const keyStr = key == null ? '' : String(key);
          if (keyStr && lookupMap.has(keyStr)) {
            display = lookupMap.get(keyStr) ?? keyStr;
            matched = true;
          }
          const trimmed = keyStr.trim();
          if (!matched && trimmed && lookupMap.has(trimmed)) {
            display = lookupMap.get(trimmed) ?? trimmed;
            matched = true;
          }
          if (!matched && meta?.source === 'ocx' && !hasField) display = '';
        } else if (typeof display === 'string' && display.includes(' - ')) {
          display = display.split(' - ')[0].trim();
        }
        if (hasMultiKey && !hasField && fieldLower !== metaKeySelf && fieldLower !== metaKey) {
          display = '';
        }
        const v = display == null || typeof display === 'object' ? '' : String(display);
        html += `<td><span class="cell-view">${escapeHtml(v)}</span><input class="cell-edit d-none" data-field="${escapeHtml(fn)}" value="${escapeHtml(raw)}"></td>`;
      });
      html += '</tr>';
    });

    html += '</tbody></table></div>';
    container.innerHTML = html;
    if (countEl) countEl.textContent = `0 / ${rows.length}`;
    window._paper3lSubDetailSelectedRows["1"] = rows[0] || null;

    const table = container.querySelector('table.erp-table');
    if (table) {
      applySavedWidths(table, cfg.DictTable, fields);
      const widthMap = await fetchFieldWidths(cfg.DictTable);
      if (widthMap.size) {
        const ths = Array.from(table.querySelectorAll('thead th'));
        fields.forEach((f, idx) => {
          const w = widthMap.get(f.toLowerCase());
          if (w) applyColumnWidth(table, ths, idx, w);
        });
        try {
          const tn = cleanTableName(cfg.DictTable);
          const cols = fields.map((f, idx) => ({ fieldName: f, width: Math.round(ths[idx].getBoundingClientRect().width) }));
          localStorage.setItem(`colwidth:${tn}`, JSON.stringify(cols));
        } catch { }
      }
      initColumnResize(table, cfg.DictTable);
    }

    const tbody = container.querySelector('tbody');
    if (tbody) {
      tbody.addEventListener('input', (e) => {
        const inp = e.target;
        if (!inp.classList.contains('cell-edit')) return;
        const tr = inp.closest('tr');
        if (tr && tr.dataset.state !== 'added') tr.dataset.state = 'modified';
        window.__unsavedChanges = true;
      });
      tbody.addEventListener('click', (e) => {
        const tr = e.target.closest('tr');
        if (!tr || !tbody.contains(tr)) return;
        tbody.querySelectorAll('tr.row-selected').forEach(x => x.classList.remove('row-selected'));
        tr.classList.add('row-selected');
        const idx = parseInt(tr.dataset.idx || '-1', 10);
        if (!isNaN(idx) && rows[idx]) {
          window._paper3lSubDetailSelectedRows["1"] = rows[idx];
        }
      });
    }

    applyEditMode(!!window.__headerIsEdit);

    window.__paper3lSubDetailCollectChanges = () => {
      const t = container?.querySelector('tbody');
      if (!t) return null;
      const changes = [];
      t.querySelectorAll('tr[data-state="modified"], tr[data-state="added"]').forEach(tr => {
        const row = {};
        tr.querySelectorAll('input.cell-edit[data-field]').forEach(inp => {
          const field = inp.dataset.field || '';
          if (!field) return;
          row[field] = (inp.value ?? '').trim();
        });
        if (Object.keys(row).length > 0) changes.push(row);
      });
      if (changes.length === 0) return null;
      const keyFields = buildKeyFieldsFromRow(changes[0]);
      return { tableName: cfg.DictTable, changes, keyFields };
    };
  }

  window.addEventListener('multiTabRowSelected', function(ev) {
    const detail = ev && ev.detail ? ev.detail : null;
    if (!detail) return;
    const tabId = detail.tabId;
    if ((cfg.ParentTabId || '').toString() && tabId !== cfg.ParentTabId) return;
    loadSubDetail(detail.rowData || null);
  });

  window.addEventListener('headerEditModeChanged', (e) => {
    applyEditMode(!!(e?.detail?.isEdit));
  });
})();
</script>

<style>
.paper3l-subdetail .erp-table-wrapper{
  background: #fff;
  box-shadow: 0 4px 18px 0 #c3d4e6;
  border-radius: 13px;
  border: 1px solid #d6dbe5;
  margin-top: 0;
}

.paper3l-subdetail .erp-table{
  width: max-content;
  display: inline-table;
  border-collapse: separate;
  border-spacing: 0;
  font-size: var(--field-value-size);
  background: #fff;
  table-layout: fixed;
}

.paper3l-subdetail .erp-table thead tr{ background: #e7ecf3; }
.paper3l-subdetail .erp-table th,
.paper3l-subdetail .erp-table td{
  background: #f1f5fb;
  padding: 0;
  border-bottom: 1px solid #c5d1e4;
  white-space: nowrap;
  text-align: center;
  font-weight: 500;
  border-right: 1px solid #dde4ed;
  height: 34px;
}
.paper3l-subdetail .erp-table th:last-child,
.paper3l-subdetail .erp-table td:last-child{ border-right: none; }
.paper3l-subdetail .erp-table th{
  color: #124d8b;
  font-weight: 700;
  font-size: var(--field-label-size);
  letter-spacing: .5px;
  background: #e7ecf3;
  position: sticky;
  top: 0;
  z-index: 10;
}

.paper3l-subdetail .subdetail-title{
  display: inline-block;
  padding: var(--tab-pad-y) var(--tab-pad-x);
  border-radius: 8px 8px 0 0;
  border: 1px solid #bdd2f7;
  border-bottom: 0;
  background: #fff;
  color: #124d8b;
  font-weight: 700;
  box-shadow: 0 2px 6px 0 #e4ecf7;
  font-size: var(--field-label-size);
  margin-bottom: 0;
}

.paper3l-subdetail .erp-table th { position: relative; }
.paper3l-subdetail .erp-table th .col-resizer{
  position: absolute;
  top: 0; right: 0; bottom: 0;
  width: 8px;
  cursor: col-resize;
  user-select: none;
  z-index: 20;
  display: block;
}
.paper3l-subdetail .erp-table th.resizing,
.paper3l-subdetail .erp-table td.resizing,
body.resizing { cursor: col-resize !important; }

.paper3l-subdetail .erp-table td .cell-view{
  display: block;
  width: 100%;
  min-height: 34px;
  text-align: inherit;
  padding: 7px 12px;
  box-sizing: border-box;
  white-space: nowrap;
  line-height: 20px;
}
.paper3l-subdetail .erp-table td .cell-edit{
  display: block;
  width: 100%;
  min-height: 34px;
  box-sizing: border-box;
  margin: 0;
  border: none;
  border-radius: 0;
  background: #fff;
  font-size: inherit;
  font-weight: inherit;
  font-family: inherit;
  line-height: 20px;
  text-align: inherit;
  padding: 7px 12px;
  white-space: nowrap;
}
.paper3l-subdetail .erp-table td .cell-edit:focus{
  outline: 2px solid #0d6efd;
  outline-offset: -2px;
  background: #fffef0;
}
</style>
